%%% -*-texinfo-*-
\tolerance=2000
\input texinfo
@c based on /geomview.texi/1.48/Tue Sep 25 23:09:21 2007//
@letterpaper
@setfilename geomview-pt_BR
@settitle Manual do Geomview

@include version-pt_BR.texi

@dircategory Graphics Applications
@direntry
* Geomview: (geomview-pt_BR).         Programa interativo de visualiza@,{c}@~ao tridimensional.
@end direntry

@titlepage
@sp 1
@center @titlefont{Manual do Geomview}
@sp 4
@center Vers@~ao @value{VERSION} do Geomview 
@sp 1
@center para GNU/Linux/Unix
@sp 1
@center @value{UPDATED-MONTH}
@comment 19 de Novembro de 2000
@sp 2
@center Mark Phillips et al.
@sp 14
@center Tradutor para o Portugu@^es do Brasil
@center Jorge Barros de Abreu
@center http://usr.solar.com.br/~ficmatin
@sp 2
@vskip 0pt plus 1filll
@center Copyright @copyright{} 1992-1998 The Geometry Center
@center Copyright @copyright{} 1998-2006 Stuart Levy, Tamara Munzner, Mark Phillips
@center Copyright @copyright{} 2006-2007 Claus-Justus Heine

@end titlepage
@page

@node Top, Intro, (dir), (dir)

Programa interativo de visualiza@,{c}@~ao tridimensional.

@menu
* Intro::                       Introdu@,{c}@~ao ao Geomview.
* Distrib::                     Como acessar a vers@~ao mais recente do Geomview.
* Copying::                     A Licen@,{c}a P@'ublica Geral Menor do GNU.
* History::                     Hist@'oria do Desenvolvimento do Geomview.
* Platforms::                   Plantaformas Suportadas.
* Pronunciation::               Como Pronunciar ``Geomview''.
* Overview::                    Vis@~ao Geral do Geomview.
* Tutorial::                    Tutorial Introdut@'orio.
* Interaction::                 Interagindo com Geomview.
* OOGL File Formats::           Formatos para Inser@,{c}@~ao de Dados Geom@'etricos.
* Customization::               Modificando o comportamento do Geomview.
* Modules::                     Programas que usam Geomview para exibi@,{c}@~ao de imagens.
* GCL::                         GCL: a Linguagem de Comandos do Geomview.
* Non-Euclidean Geometry::      Geometrias N@~ao Euclideanas.
* Mathematica::                 Gr@'aficos do Mathematica no Geomview ou no RenderMan.
* Installation::                Instalando o Geomview no seu computador.
* Support::                     acessando o Suporte T@'ecnico para o Geomview.

* Contributing::                Como contribuir com o Geomview.
* Function Index::              Acesso r@'apido a cada fun@,{c}@~ao da GCL.
* List of Figures::             Lista de Figuras.
@end menu

@node Intro, Distrib, Top, Top
@unnumbered Introduction to Geomview

Geomview @'{e} um programa interativo para visualizar e manipular
objetos geom@'{e}tricos, originalmente escrito pelos membros do estado maior do Geometry
Center na Universidade de Minesota (EUA), come@,{c}ando em 1991.  O Geomview pode ser usado
como um visualizador independente para objetos est@'{a}ticos ou como um mecanismo de visualiza@,{c}@~{a}o para
outros programas que produzem dinamicamente mudan@,{c}as geom@'{e}tricas.  Geomview roda sobre
muitos tipos de computadores Unix, incluindo Linux, SGI, Sun, e HP. Geomview tamb@'{e}m
executa com Cygwin. Esse manual descreve Geomview em sua vers@~{a}o 1.9. @refill

Geomview @'{e} um @dfn{software} livre, dispon@'{i}vel sob os termos da Licen@,{c}a P@'{u}blica Geral 
Menor do GNU ; veja @ref{Copying} para detalhes.

Geomview e esse manual podem ser encontrados em
@uref{http://www.geomview.org}.

@'{E} permitido fazer c@'{o}pias desse manual.

Se voc@^{e} tiver d@'{u}vidas ou coment@'{a}rios sobre o Geomview ou esse manual,
considere inscrever-se na lista de correio eletr@^{o}nico @file{geomview-users}, que @'{e} um
f@'{o}rum no qual usu@'{a}rios do Geomview comunicam-se para responder
outras quest@~{o}es e para compartilhar not@'{i}cias sobre o que eles est@~{a}o fazendo com o
Geomview.  Os autores do Geomview participam dessa lista e algumas vezes
enviam respostas a questionamentos existentes.  Para assinar a lista, visite a p@'{a}gina da lista
no s@'{i}tio @uref{http://lists.sourceforge.net/mailman/listinfo/geomview-users}.

@node Distrib, Copying, Intro, Top
@unnumbered Distribution

Geomview @'{e} um @dfn{software} livre; isso significa que qualquer um @'{e} livre para
us@'{a}-lo e livre para redistribu@'{i}-lo sob certas condi@,{c}@~{o}es.  
Geomview n@~{a}o @'{e} 
de dom@'{i}nio p@'{u}blico; @'{e} protegido por direitos autorais e existem restri@,{c}@~{o}es
sobre sua distribui@,{c}@~{a}o, mas essas restri@,{c}@~{o}es s@~{a}o montadas de forma a permitir
qualquer coisa que um bom cidad@~{a}o colaborador possa querer fazer.  O que n@~{a}o @'{e}
permitido @'{e} para tentar previnir outros de compartilhamento adicional de qualquer vers@~{a}o
do Geomview que eles possam pegar de voc@^{e}.  As condi@,{c}@~{o}es precisas podem ser
encontradas na Licen@,{c}a Geral Menor do GNU que acompanha o Geomview e tamb@'{e}m
aparece acompanhando essa se@,{c}@~{a}o.

Uma forma de acessar uma c@'{o}pia do Geomview @'{e} a partir de algu@'{e}m que j@'{a} possua o Geomview.  Voc@^{e}
n@~{a}o precisa perguntar por nossa permiss@~{a}o para fazer isso, ou informar qualquer coisa; apenas
fa@,{c}a a c@'{o}pia.  Se voc@^{e} tiver acesso @`{a} internet, voc@^{e} pode pegar a mais recente
vers@~{a}o do Geomview em @uref{http://www.geomview.org}.

Voc@^{e} tamb@'{e}m pode receber Geomview quando voc@^{e} compra um computador.  Fabricantes de
computadores est@~{a}o livres para distribuir c@'{o}pias sob os mesmos termos que s@~{a}o aplicados a
qualquer pessoa.  Esses termos requerem que os fabricantes forne@,{c}am a voc@^{e} o c@'{o}digo completo,
incluindo qualquer mudan@,{c}as que eles tenham feito, e permitam a voc@^{e} que
redistribua o Geomview recebido deles nos termos usuais da
Licen@,{c}a P@'{u}blica Geral Menor do GNU.  Em outras palavras, o programa deve ser livre para voc@^{e}
quando voc@^{e} o receber, n@~{a}o apenas livre para o fabricante.

@node Copying, History, Distrib, Top
@unnumbered Copying

@c cH: in my opinion the following paragraph is complete nonsense; programs
@c which simply communicate with other programs by means of streams
@c cannot inherit the restriction imposed by the GPL

@smallexample
NOTA: Geomview @'{e} distribu@'{i}do sob a LICEN@,{C}A P@'{U}BLICA GERAL
MENOR.  Para os prop@'{o}sitos dessa licen@,{c}a  n@'{o}s pensamos em Geomview como se ele
fosse uma "biblioteca", e dos m@'{o}dulos externos do Geomview como "programas que
se comunicam com a biblioteca".  Fazemos isso porque queremos especificamente
permitir que programas propriet@'{a}rios e m@'{o}dulos usem o Geomview.
@end smallexample

@unnumbered GNU LESSER PUBLIC LICENSE
@center Version 2.1, February 1999

@display
Licen@,{c}a P@'{u}blica Geral Menor do GNU

This is an unofficial translation of the GNU Lesser General Public
License into Portuguese. It was not published by the Free Software Foundation,
and does not legally state the distribution terms for software that uses the
GNU LGPL--only the original English text of the GNU LGPL does that. However,
we hope that this translation will help Portuguese speakers understand the
GNU LGPL better.

Esta @'{e} uma tradu@,{c}@~{a}o n@~{a}o-oficial da GNU Lesser General Public
License para o Portugu@^{e}s. Ela n@~{a}o @'{e} publicada pela Free Software Foundation
e n@~{a}o traz os termos de distribui@,{c}@~{a}o legal do software que usa a GNU LGPL -- estes termos est@~{a}o contidos apenas no texto da GNU LGPL original em ingl@^{e}s.
No entanto, esperamos que esta tradu@,{c}@~{a}o ajudar@'{a} no
melhor entendimento da GNU LGPL em Portugu@^{e}s.

Vers@~{a}o 2.1, Fevereiro de 1999

Copyright @copyright{} 1991, 1999 Free Software Foundation, Inc.
59 Temple Place, Suite 330, Boston, MA  02111-1307  USA [Estados Unidos da Am@'{e}rica]

@'{E} permitido a qualquer pessoa copiar e distribuir c@'{o}pias
sem altera@,{c}@~{o}es deste documento de licen@,{c}a, sendo vedada, entretanto, sua modifica@,{c}@~{a}o.

[Esta @'{e} a primeira vers@~{a}o da GPL Menor a ser lan@,{c}ada. Ela tamb@'{e}m constitui
a sucessora da Licen@,{c}a P@'{u}blica de Biblioteca do GNU, da@'{i} o n@'{u}mero 2.1. da vers@~{a}o].

[This is the first released version of the Lesser GPL.  It also counts
 as the successor of the GNU Library Public License, version 2, hence
 the version number 2.1.]
@end display

@unnumberedsec Introdu@,{c}@~{a}o

As licen@,{c}as da maioria dos softwares s@~{a}o elaboradas para suprimir sua
liberdade de compartilh@'{a}-los e modific@'{a}-los. As Licen@,{c}as P@'{u}blicas do GNU, ao contr@'{a}rio,
t@^{e}m o objetivo de assegurar sua liberdade para compartilhar e modificar
softwares livres para garantir que o software seja livre para todos os seus usu@'{a}rios.

A presente Licen@,{c}a P@'{u}blica Geral Menor se aplica a alguns
pacotes de software especialmente designados - normalmente bibliotecas - da
Free Software Foundation e de outros autores que decidam utiliz@'{a}-la. Voc@^{e}
pode utiliz@'{a}-la tamb@'{e}m, mas recomendamos que antes, voc@^{e} analise cuidadosamente se
esta licen@,{c}a, ou a Licen@,{c}a P@'{u}blica Geral comum, @'{e} a melhor
estrat@'{e}gia a ser adotada em cada caso espec@'{i}fico, tendo como base as explica@,{c}@~{o}es
abaixo.

Quando falamos de software livre, estamos nos referindo a liberdade de uso
e n@~{a}o de gratuidade de pre@,{c}o. Nossas Licen@,{c}as P@'{u}blicas Gerais s@~{a}o elaboradas para garantir que
voc@^{e} tenha liberdade para distribuir c@'{o}pias de software livre (cobrando
por esse servi@,{c}o se voc@^{e} assim o desejar); que voc@^{e} receba c@'{o}digo-fonte ou o obtenha,
se quiser; que voc@^{e} modifique o software e utilize partes dele
em novos programas livres; e que voc@^{e} tenha ci@^{e}ncia de que pode praticar
estes atos.

A fim de proteger seus direitos, @'{e} necess@'{a}rio que fa@,{c}amos restri@,{c}@~{o}es que pro@'{i}bam
distribu@'{i}dores de negar estes direitos a voc@^{e} ou de pedir que voc@^{e} que renuncie a
eles. Essas restri@,{c}@~{o}es se traduzem em determinadas responsabilidades que voc@^{e} dever@'{a}
assumir, se vier a distribuir c@'{o}pias da biblioteca ou modific@'{a}-la.

Por exemplo, se voc@^{e} distribuir c@'{o}pias da biblioteca, seja gratuitamente
ou mediante um valor, ter@'{a} de conceder a seus receptores todos os direitos que estamos concedendo
a voc@^{e}. Voc@^{e} ter@'{a} de garantir que eles, tamb@'{e}m, recebam ou possam obter o c@'{o}digo
fonte. Se voc@^{e} ligar outro c@'{o}digo com a biblioteca, voc@^{e} deve fornecer
os arquivos-objeto completos para os receptores, de modo que eles possam lig@'{a}-los novamente
com a biblioteca ap@'{o}s terem feito mudan@,{c}as na biblioteca e recompilado a
mesma. E voc@^{e} ter@'{a} de exibir a eles esses termos, para que eles conhe@,{c}am seus direitos.

Protegemos seus direitos atrav@'{e}s de um m@'{e}todo que envolve dois passos: (1) estabelecemos direitos autorais sobre a
biblioteca e (2) oferecemos a voc@^{e} esta licen@,{c}a, que d@'{a} a voc@^{e}
permiss@~{a}o para copiar, distribuir e/ou modificar a biblioteca.

Para proteger cada distribuidor, queremos deixar bem claro que
n@~{a}o h@'{a} nenhuma garantia para a biblioteca livre. Al@'{e}m disso, se a biblioteca for
modificada por algu@'{e}m e passada adiante, os receptores devem saber
que o que eles t@^{e}m n@~{a}o @'{e} a vers@~{a}o original, de modo que a reputa@,{c}@~{a}o do autor original
n@~{a}o ser@'{a} afetada por problemas que possam ser
introduzidos por outros.

Por fim, as patentes de software representam uma amea@,{c}a constante para a exist@^{e}ncia de
qualquer programa livre. Queremos assegurar que uma empresa n@~{a}o possa
efetivamente restringir os usu@'{a}rios de um programa livre por ter obtido uma
licen@,{c}a restritiva de um titular de direitos de patente. Por isso, insistimos que
qualquer licen@,{c}a de patente obtida para alguma vers@~{a}o da biblioteca seja
consistente com a plena liberdade de uso, especificada nesta licen@,{c}a.

A maior parte dos softwares do GNU, incluindo algumas bibliotecas, est@'{a} coberta pela
Licen@,{c}a P@'{u}blica Geral comum do GNU. A presente Licen@,{c}a P@'{u}blica
Geral Menor do GNU se aplica a determinadas bibliotecas designadas,
sendo bastante diferente da Licen@,{c}a P@'{u}blica Geral comum. Usamos
esta licen@,{c}a para determinadas bibliotecas, a fim de permitir a liga@,{c}@~{a}o dessas
bibliotecas a programas n@~{a}o-livres.

Quando um programa @'{e} ligado a uma biblioteca, seja estaticamente ou usando
uma biblioteca compartilhada, essa combina@,{c}@~{a}o das duas @'{e} em termos legais uma
obra combinada, uma deriva@,{c}@~{a}o da biblioteca original. Por essa raz@~{a}o, a
Licen@,{c}a P@'{u}blica Geral comum somente permite essa liga@,{c}@~{a}o se a combina@,{c}@~{a}o como um
todo atender a seus crit@'{e}rios de liberdade. A Licen@,{c}a P@'{u}blica
Geral Menor permite crit@'{e}rios mais flex@'{i}veis para a liga@,{c}@~{a}o de outros c@'{o}digos
@`{a} biblioteca.

Chamamos esta licen@,{c}a de Licen@,{c}a P@'{u}blica Geral "Menor" porque ela
faz Menos para proteger a liberdade do usu@'{a}rio do que a Licen@,{c}a P@'{u}blica
Geral comum. Ela tamb@'{e}m oferece a outros desenvolvedores de software livre uma Menor
vantagem na competi@,{c}@~{a}o com com programas n@~{a}o livres. Essas desvantagens
s@~{a}o o motivo pelo qual usamos a Licen@,{c}a P@'{u}blica Geral comum para muitas
bibliotecas. Por outro lado, em determinadas circunst@^{a}ncias especiais, a licen@,{c}a Menor
oferece vantagens.

Por exemplo, em raras ocasi@~{o}es, pode existir uma necessidade especial
de se incentivar a mais ampla utiliza@,{c}@~{a}o poss@'{i}vel de uma determinada biblioteca, para que ela
se torne um padr@~{a}o de fato. Para conseguir isso, deve-se permitir que programas n@~{a}o-livres
utilizem a biblioteca. Um caso mais freq@"{u}ente ocorre quando uma biblioteca livre
desempenha a mesma fun@,{c}@~{a}o de bibliotecas n@~{a}o-livres amplamente usadas. Nesse
caso, existem poucas vantagens em restringir a biblioteca livre somente para
software livre, ent@~{a}o utilizamos a Licen@,{c}a P@'{u}blica Geral Menor.

Em outros casos, a permiss@~{a}o para usar uma determinada biblioteca em programas n@~{a}o-livres
possibilita que um maior n@'{u}mero de pessoas use um amplo leque de
softwares livres. Por exemplo, a permiss@~{a}o para usar a Biblioteca C do GNU
permite que muito mais pessoas usem todo o sistema
operacional do GNU, bem como sua variante, o sistema operacional do
GNU/Linux.

Mesmo protegendo a liberdade dos usu@'{a}rios em menor grau,
a Licen@,{c}a P@'{u}blica Geral Menor garante ao usu@'{a}rio de um programa que esteja
ligado @`{a} Biblioteca a liberdade e os meios para executar
o programa, usando uma vers@~{a}o modificada da Biblioteca.

Seguem abaixo os termos e condi@,{c}@~{o}es exatos para a c@'{o}pia, distribui@,{c}@~{a}o e
modifica@,{c}@~{a}o. Preste muita aten@,{c}@~{a}o @`{a} diferen@,{c}a entre uma
"obra baseada na biblioteca" e uma "obra que usa a biblioteca". O
primeiro cont@'{e}m c@'{o}digo que @'{e} derivado da biblioteca, enquanto o segundo tem de ser
combinado @`{a} biblioteca para que possa ser executado.

@unnumberedsec TERMOS E CONDI@,{C}@~{O}ES PARA C@'{O}PIA, DISTRIBUI@,{C}@~{A}O E MODIFICA@,{C}@~{A}O

@enumerate 0
@item
O presente Contrato de Licen@,{c}a se aplica a qualquer biblioteca de software ou a outro
programa que contenha um aviso colocado pelo titular dos direitos autorais ou
outra parte autorizada, informando que ela pode ser distribu@'{i}da nos termos desta
Licen@,{c}a P@'{u}blica Geral Menor (tamb@'{e}m denominada "esta Licen@,{c}a").
Cada licenciado doravante ser@'{a} denominado "voc@^{e}".

Uma "biblioteca" significa uma cole@,{c}@~{a}o de fun@,{c}@~{o}es de software e/ou dados
preparados, de forma a serem convenientemente ligados com programas de aplica@,{c}@~{a}o
(que usam algumas dessas fun@,{c}@~{o}es e dados) para formar execut@'{a}veis.

O termo "Biblioteca", abaixo, refere-se a qualquer biblioteca de software ou obra
que tenha sido distribu@'{i}da de acordo com esses termos. Uma "obra baseada na
Biblioteca" significa tanto a Biblioteca como qualquer obra derivada, nos termos
da legisla@,{c}@~{a}o autoral: isto @'{e}, uma obra contendo a Biblioteca ou
parte dela, seja sem altera@,{c}@~{o}es ou com modifica@,{c}@~{o}es e/ou traduzida
diretamente para outra linguagem. (Doravante, o termo "modifica@,{c}@~{a}o"
inclui, sem reservas, o termo "tradu@,{c}@~{a}o").

O "c@'{o}digo-fonte" de uma obra significa o formato preferencial da obra para
que sejam feitas modifica@,{c}@~{o}es na mesma. Para uma biblioteca, o c@'{o}digo-fonte completo significa
todo o c@'{o}digo fonte para todos os m@'{o}dulos contidos na mesma, al@'{e}m de quaisquer arquivos de defini@,{c}@~{a}o de
interface associados, al@'{e}m dos scripts utilizados para controlar
a compila@,{c}@~{a}o
e a instala@,{c}@~{a}o da biblioteca.

Outras atividades que n@~{a}o a c@'{o}pia, distribui@,{c}@~{a}o e modifica@,{c}@~{a}o n@~{a}o s@~{a}o
cobertas por esta Licen@,{c}a; elas est@~{a}o fora de seu escopo. O ato de
executar um programa usando a Biblioteca n@~{a}o tem restri@,{c}@~{o}es, e o resultado gerado
a partir desse programa encontra-se coberto somente se seu conte@'{u}do constituir uma obra baseada
na Biblioteca (independente do uso da Biblioteca em uma ferramenta para
escrev@^{e}-lo). Na verdade, isto depender@'{a} daquilo que a Biblioteca faz
e o que o programa que usa a biblioteca faz.



@item
Voc@^{e} pode copiar e distribuir c@'{o}pias sem altera@,{c}@~{o}es do c@'{o}digo-fonte
completo da Biblioteca ao receb@^{e}-lo, em qualquer meio ou m@'{i}dia, desde que
publique, ostensiva e adequadamente, um aviso de direitos autorais (ou copyright)
apropriado e uma notifica@,{c}@~{a}o sobre a exonera@,{c}@~{a}o de garantias; mantenha intactas
as informa@,{c}@~{o}es, avisos ou notifica@,{c}@~{o}es referentes a esta Licen@,{c}a e @`{a} aus@^{e}ncia de qualquer
garantia; e distribua uma c@'{o}pia desta Licen@,{c}a junto com a
Biblioteca.

Voc@^{e} poder@'{a} cobrar um valor pelo ato f@'{i}sico de transferir uma c@'{o}pia,
e voc@^{e} pode oferecer, se quiser, a prote@,{c}@~{a}o de uma garantia em troca de um
valor.

@item
Voc@^{e} pode modificar sua c@'{o}pia ou c@'{o}pias da Biblioteca ou qualquer parte
dela, formando, assim, uma obra baseada na Biblioteca, bem como copiar e
distribuir essas modifica@,{c}@~{o}es ou obra, em conformidade com a Cl@'{a}usula 1
acima, desde que atenda, ainda, a todas as seguintes condi@,{c}@~{o}es:

@enumerate a
@item
A obra modificada tem de ser, por si s@'{o}, uma biblioteca de software.

@item
Voc@^{e} tem de fazer com que os arquivos modificados contenham avisos, em destaque,
de que voc@^{e} modificou os arquivos e a data de qualquer modifica@,{c}@~{a}o.

@item
Voc@^{e} tem de fazer com que a obra como um todo seja licenciada, sem nenhum
custo, a todos os terceiros, de acordo com esta Licen@,{c}a.

@item
Se um dispositivo, na Biblioteca modificada, se referir a uma fun@,{c}@~{a}o ou a
uma tabela de dados a ser fornecida por um programa de aplica@,{c}@~{a}o que usa
esse dispositivo, outro que n@~{a}o um argumento transmitido quando o dispositivo
@'{e} invocado, nesse caso, voc@^{e} ter@'{a} de fazer um esfor@,{c}o de boa-f@'{e} para assegurar que,
no caso de uma aplica@,{c}@~{a}o que n@~{a}o forne@,{c}a essa fun@,{c}@~{a}o ou
tabela, o dispositivo ainda assim opere, e ir@'{a} realizar qualquer parte de
sua finalidade que permanecer significativa.

(Por exemplo, uma fun@,{c}@~{a}o de uma biblioteca para computar ra@'{i}zes quadradas tem
uma finalidade que @'{e} completamente bem definida independentemente da
aplica@,{c}@~{a}o. Por essa raz@~{a}o, a letra d, da Cl@'{a}usula 2, exige que qualquer
fun@,{c}@~{a}o ou tabela fornecida pela aplica@,{c}@~{a}o, usada por essa fun@,{c}@~{a}o, tem de ser
opcional: se a aplica@,{c}@~{a}o n@~{a}o fornec@^{e}-la, a fun@,{c}@~{a}o de
ra@'{i}zes quadradas dever@'{a} ainda assim computar ra@'{i}zes quadradas).
@end enumerate

Essas exig@^{e}ncias se aplicam @`{a} obra modificada como um todo. Se
partes identific@'{a}veis dessa obra n@~{a}o forem derivadas da Biblioteca
e puderem ser consideradas razoavelmente, em si, como obras independentes e separadas,
nesse caso, esta Licen@,{c}a e seus termos n@~{a}o se aplicar@~{a}o a essas
partes quando voc@^{e} distribui-las como obras separadas. Todavia, quando voc@^{e}
distribuir essas mesmas partes como partes de um todo, que por si seja uma obra baseada
na Biblioteca, a distribui@,{c}@~{a}o desse todo dever@'{a} ser realizada de acordo com
esta Licen@,{c}a, cujas respectivas permiss@~{o}es para outros licenciados extendem-se @`{a}
integralidade deste todo, dessa forma, a toda e qualquer parte, independentemente de quem
a escreveu.

Assim, esta cl@'{a}usula n@~{a}o tem a inten@,{c}@~{a}o de afirmar direitos ou contestar
os seus direitos sobre uma obra escrita inteiramente por voc@^{e}; a inten@,{c}@~{a}o @'{e},
antes, de exercer o direito de controlar a distribui@,{c}@~{a}o de obras derivadas ou
obras coletivas baseadas na Biblioteca.

Al@'{e}m disto, a simples agrega@,{c}@~{a}o de outra obra, que n@~{a}o seja baseada na Biblioteca,
@`{a} Biblioteca (ou a uma obra baseada na Biblioteca) em um volume de
meio ou m@'{i}dia de armazenamento ou distribui@,{c}@~{a}o, n@~{a}o inclui esta outra obra no
@^{a}mbito desta Licen@,{c}a.

@item
Voc@^{e} poder@'{a} optar por aplicar os termos da Licen@,{c}a P@'{u}blica Geral
do GNU ao inv@'{e}s desta Licen@,{c}a, para uma determinada c@'{o}pia da Biblioteca. Para tanto,
voc@^{e} dever@'{a} alterar todos os avisos ou notifica@,{c}@~{o}es que se refiram a esta Licen@,{c}a,
para que eles se refiram @`{a} Licen@,{c}a P@'{u}blica Geral comum do GNU, vers@~{a}o 2,
ao inv@'{e}s desta Licen@,{c}a. (Se uma vers@~{a}o mais nova do que a vers@~{a}o 2 da
Licen@,{c}a P@'{u}blica Geral comum do GNU tiver sido gerada, ent@~{a}o voc@^{e} poder@'{a} especificar
essa vers@~{a}o, se preferir). N@~{a}o fa@,{c}a nenhuma outra altera@,{c}@~{a}o nesses
avisos ou notifica@,{c}@~{o}es.

Uma vez que essa altera@,{c}@~{a}o tenha sido feita em uma determinada c@'{o}pia, ela @'{e} irrevers@'{i}vel para
esta c@'{o}pia, passando a Licen@,{c}a P@'{u}blica Geral comum do GNU a ser aplicada para todas
as c@'{o}pias e obras derivadas subseq@"{u}entes, feitas a partir dessa c@'{o}pia.

Essa op@,{c}@~{a}o @'{e} @'{u}til quando voc@^{e} desejar copiar parte do c@'{o}digo da
Biblioteca em um programa que n@~{a}o seja uma biblioteca.

@item
Voc@^{e} poder@'{a} copiar e distribuir a Biblioteca (ou uma parte ou obra
derivada dela, de acordo com a Cl@'{a}usula 2) em c@'{o}digo-objeto ou formato execut@'{a}vel,
sob as Cl@'{a}usulas 1 e 2 acima, desde que inclua
todo o c@'{o}digo-fonte correspondente, pass@'{i}vel de leitura pela m@'{a}quina, que
deve ser distribu@'{i}do sob os termos das Cl@'{a}usulas 1 e 2 acima,
em um meio ou m@'{i}dia costumeiramente utilizado para o interc@^{a}mbio de software.

Se a distribui@,{c}@~{a}o do c@'{o}digo-objeto for feita pela oferta de acesso para c@'{o}pia
a partir de um local designado, ent@~{a}o a permiss@~{a}o de acesso equivalente para copiar o
c@'{o}digo-fonte a partir do mesmo local atende a exig@^{e}ncia de
distribui@,{c}@~{a}o do c@'{o}digo-fonte, mesmo que terceiros n@~{a}o sejam
levados a copiar a fonte junto com o c@'{o}digo-objeto.

@item
Um programa que n@~{a}o contenha nenhum derivativo de qualquer parte da
Biblioteca, mas que seja desenhado para operar com a Biblioteca ao ser compilado ou
ligado a ela, @'{e} chamado de uma "obra que usa a Biblioteca". Essa
obra, isoladamente, n@~{a}o @'{e} uma obra derivada da Biblioteca e,
portanto, fica de fora do @^{a}mbito desta Licen@,{c}a.

Entretanto, a liga@,{c}@~{a}o de uma "obra que usa a Biblioteca" com a Biblioteca
constitui um execut@'{a}vel que @'{e} um derivado da Biblioteca (pois
cont@'{e}m partes da Biblioteca), e n@~{a}o uma "obra que usa a
Biblioteca". O execut@'{a}vel @'{e}, assim, coberto por esta Licen@,{c}a.
A Cl@'{a}usula 6 estabelece os termos para a distribui@,{c}@~{a}o desses execut@'{a}veis.

Quando uma "obra que usa a Biblioteca" usar material de um arquivo de cabe@,{c}alho
que @'{e} parte da Biblioteca, o c@'{o}digo-objeto para a obra poder@'{a} ser uma
obra derivada da Biblioteca, mesmo que o c@'{o}digo-fonte n@~{a}o o seja.
Para que isto seja verdade, @'{e} especialmente importante se a obra pode ser
ligada sem a Biblioteca, ou se a obra @'{e}, em si mesma, uma biblioteca. O
limiar para que isto seja verdade n@~{a}o @'{e} definido com precis@~{a}o pela lei.

Se um arquivo-objeto usar somente par@^{a}metros num@'{e}ricos, layouts
e accessors da estrutura de dados, bem como pequenas macros e pequenas fun@,{c}@~{o}es
inline (dez linhas ou menos de extens@~{a}o), ent@~{a}o o uso do arquivo-objeto
n@~{a}o @'{e} restrito, independente de ser ele legalmente uma obra
derivada. (Execut@'{a}veis contendo este c@'{o}digo-objeto mais partes da
Biblioteca continuam submetidos aos termos da Cl@'{a}usula 6).

Do contr@'{a}rio, se a obra for um derivado da Biblioteca, voc@^{e} poder@'{a}
distribuir o c@'{o}digo objeto da obra sob os termos da Cl@'{a}usula 6.
Quaisquer execut@'{a}veis contendo esta obra tamb@'{e}m se submetmem @`{a} Cl@'{a}usula 6,
estejam ou n@~{a}o diretamente ligados @`{a} Biblioteca em si.

@item
Como exce@,{c}@~{a}o @`{a} Cl@'{a}usula acima, voc@^{e} tamb@'{e}m pode combinar ou
ligar uma "obra que usa a Biblioteca" @`{a} Biblioteca para produzir uma
obra contendo partes da Biblioteca e distribu@'{i}-la de acordo
com os termos de sua escolha, desde que estes termos permitam
modifica@,{c}@~{o}es na obra para uso pr@'{o}prio por parte do cliente e engenharia
reversa para depura@,{c}@~{a}o dessas modifica@,{c}@~{o}es.

Em cada c@'{o}pia da obra, voc@^{e} ter@'{a} de colocar um aviso, em destaque, de que a
Biblioteca foi usada e que ela e seu uso est@~{a}o cobertos por
esta Licen@,{c}a. Voc@^{e} dever@'{a} fornecer uma c@'{o}pia desta Licen@,{c}a. Se, durante a execu@,{c}@~{a}o, a obra
exibir avisos ou notifica@,{c}@~{o}es de direitos autorais (ou copyright), voc@^{e} ter@'{a} de incluir,
entre eles, o aviso de direitos autorais (ou copyright) referente @`{a} Biblioteca, bem como uma refer@^{e}ncia
direcionando o usu@'{a}rio para a c@'{o}pia desta Licen@,{c}a. Al@'{e}m disso, voc@^{e} dever tomar ao menos uma
das seguintes provid@^{e}ncias:

@enumerate a
@item
Incluir na obra todo o c@'{o}digo-fonte da Biblioteca, pass@'{i}vel de
leitura pela m@'{a}quina, incluindo quaisquer
modifica@,{c}@~{o}es que foram usadas na obra (as quais devem ser distribu@'{i}das conforme
as Cl@'{a}usulas 1 e 2 acima); e, se a obra for um execut@'{a}vel ligado
@`{a} Biblioteca, com toda a "obra que
usa a Bilblioteca" pass@'{i}vel de leitura pela m@'{a}quina, como c@'{o}digo-objeto e/ou c@'{o}digo-fonte, de modo que o
usu@'{a}rio possa modificar a biblioteca e, depois, religar para produzir um execut@'{a}vel modificado
contendo a Biblioteca modificada. (Fica entendido
que o usu@'{a}rio que modificar o conte@'{u}do dos arquivos de defini@,{c}@~{o}es da
Biblioteca n@~{a}o necessariamente ser@'{a} capaz de recompilar a aplica@,{c}@~{a}o
para usar as defini@,{c}@~{o}es modificadas).

@item
Usar um mecanismo adequado de biblioteca compartilhada para ligar com a
Biblioteca. Um mecanismo adequado @'{e} aquele que (a) usa, ao tempo da execu@,{c}@~{a}o, uma
c@'{o}pia da biblioteca j@'{a} presente no sistema do computador do usu@'{a}rio, e (2)
ir@'{a} operar adequadamente com uma vers@~{a}o modificada da biblioteca, se
o usu@'{a}rio instalar uma, desde que a vers@~{a}o modificada seja
compat@'{i}vel com a interface da vers@~{a}o com a qual a obra foi feita.

@item
Incluir na obra uma oferta por escrito, v@'{a}lida por pelo
menos 3 anos, oferencendo ao mesmo usu@'{a}rio os materiais
especificados na letra "a" da Cl@'{a}usula 6 acima, por um custo n@~{a}o superior
ao custo de fazer esta distribui@,{c}@~{a}o.

@item
Se a distribui@,{c}@~{a}o da obra for feita com a permiss@~{a}o de acesso para copiar,
a partir de um local designado, oferecer acesso equivalente para copiar os materiais
acima especificados, a partir do mesmo local.

@item
Certificar-se se o usu@'{a}rio j@'{a} recebeu uma c@'{o}pia desses
materiais ou de que voc@^{e} j@'{a} enviou uma c@'{o}pia a esse usu@'{a}rio.
@end enumerate

Para um execut@'{a}vel, o formato exigido da "obra que usa a
Biblioteca" deve incluir quaisquer dados e programas utilit@'{a}rios necess@'{a}rios para
reprodu@,{c}@~{a}o do execut@'{a}vel a partir dele. Todavia, como uma exce@,{c}@~{a}o especial,
os materiais a serem distribu@'{i}dos n@~{a}o necessitam incluir algo que seja
normalmente distribu@'{i}do (tanto no formato fonte quanto bin@'{a}rio) com os componentes mais
importantes (compilador, kernel, e assim por diante) do sistema operacional
no qual execut@'{a}vel @'{e} executado, a menos que esse componente, em si,
acompanhe o execut@'{a}vel.

Pode ocorrer que essa exig@^{e}ncia contradiga as restri@,{c}@~{o}es da
licen@,{c}a de outras bibliotecas propriet@'{a}rias que normalmente n@~{a}o
acompanham o sistema operacional. Essa contradi@,{c}@~{a}o significa que voc@^{e} n@~{a}o pode
utilizar ambas e a Biblioteca juntas em um execut@'{a}vel distribu@'{i}do
por voc@^{e}.

@item
Voc@^{e} pode colocar dispositivos da biblioteca que sejam uma obra baseada na
Biblioteca lado-a-lado em uma @'{u}nica biblioteca junto com outros dispositivos de
bibliotecas, desde que uma distribui@,{c}@~{a}o separada da obra baseada na
Biblioteca e dos outros dispositivos de bibliotecas seja, de outro modo,
permitida e desde que voc@^{e} tome uma das seguintes provid@^{e}ncias:

@enumerate a
@item
Incluir na biblioteca combinada uma c@'{o}pia dessa obra
baseada na Biblioteca sem a combina@,{c}@~{a}o com quaisquer outros dispositivos de
biblioteca. Essa c@'{o}pia tem de ser distribu@'{i}da de acordo com as condi@,{c}@~{o}es das
cl@'{a}usulas acima.

@item
Junto com a biblioteca combinada, fornecer um aviso, em destaque, sobre o fato de
que parte dela @'{e} uma obra baseada na Biblioteca, e explicando
onde encontrar o formato n@~{a}o combinado incluso dessa mesma obra.
@end enumerate

@item
Voc@^{e} n@~{a}o poder@'{a} copiar, modificar, sublicenciar, ligar, ou distribuir
a Biblioteca, exceto conforme expressamente disposto nesta Licen@,{c}a. Qualquer
tentativa de, de outro modo, copiar, modificar, sublicenciar, ligar ou
distribuir a Biblioteca @'{e} inv@'{a}lida, e automaticamente terminar@'{a} seus
direitos sob esta Licen@,{c}a. Todavia, terceiros que tiverem recebido c@'{o}pias
ou direitos de voc@^{e}, de acordo com esta Licen@,{c}a, n@~{a}o ter@~{a}o seus direitos
rescindidos, enquanto estes terceiros mantiverem o seu pleno cumprimento.

@item
Voc@^{e} n@~{a}o @'{e} obrigado a aceitar esta Licen@,{c}a, uma vez que voc@^{e} n@~{a}o
a assinou. Entretanto, nada mais concede a voc@^{e} permiss@~{a}o para modificar ou
distribuir a Biblioteca ou suas obras derivadas. Esses atos s@~{a}o
proibidos por lei se voc@^{e} n@~{a}o aceitar esta Licen@,{c}a. Portanto, ao
modificar ou distribuir a Biblioteca (ou qualquer obra baseada na
Biblioteca), voc@^{e} manifesta sua aceita@,{c}@~{a}o desta Licen@,{c}a para faz@^{e}-lo,
bem como de todos os seus termos e condi@,{c}@~{o}es para c@'{o}pia, distribui@,{c}@~{a}o ou modifica@,{c}@~{a}o
da Biblioteca ou obras nela baseadas.

@item
A cada vez que voc@^{e} redistribuir a Biblioteca (ou qualquer obra nela baseada),
o receptor automaticamente recebe uma licen@,{c}a do
licenciante original para copiar, distribuir, ligar ou modificar a Biblioteca,
sujeito a estes respectivos termos e condi@,{c}@~{o}es. Voc@^{e} n@~{a}o poder@'{a} impor quaisquer restri@,{c}@~{o}es
adicionais ao exerc@'{i}cio, pelos receptores, dos direitos concedidos por este instrumento.
Voc@^{e} n@~{a}o tem responsabilidade de promover o cumprimento desta licen@,{c}a por parte
de terceiros.

@item
Se, como resultado de uma senten@,{c}a judicial ou alega@,{c}@~{a}o de viola@,{c}@~{a}o de patente,
ou por qualquer outro motivo (n@~{a}o restrito @`{a}s quest@~{o}es de patentes),
forem impostas a voc@^{e} condi@,{c}@~{o}es (tanto atrav@'{e}s de mandado judicial, contrato ou
qualquer outra forma) que contradigam as condi@,{c}@~{o}es desta Licen@,{c}a, voc@^{e} n@~{a}o estar@'{a}
desobrigado quanto @`{a}s condi@,{c}@~{o}es desta Licen@,{c}a. Se voc@^{e} n@~{a}o puder
atuar como distribuidor de modo a satisfazer simultaneamente suas obriga@,{c}@~{o}es sob esta
Licen@,{c}a e quaisquer outras obriga@,{c}@~{o}es pertinentes, ent@~{a}o, como conseq@"{u}@^{e}ncia, voc@^{e}
n@~{a}o poder@'{a} distribuir a Biblioteca de nenhuma forma. Por exemplo, se uma licen@,{c}a
sob uma patente n@~{a}o permite a redistribui@,{c}@~{a}o por parte de
todos aqueles que tiverem recebido c@'{o}pias, direta ou indiretamente de voc@^{e}, sem o pagamento de royalties, ent@~{a}o,
a @'{u}nica forma de cumprir tanto com esta exig@^{e}ncia quanto com esta licen@,{c}a ser@'{a}
deixar de distribuir, por completo, a Biblioteca.

Se qualquer parte desta Cl@'{a}usula for considerada inv@'{a}lida ou n@~{a}o execut@'{a}vel, sob
qualquer circunst@^{a}ncia espec@'{i}fica, o restante da cl@'{a}usula dever@'{a} continuar a ser
aplicado e a cl@'{a}usula, como um todo, dever@'{a} ser aplicada em outras
circunst@^{a}ncias.

Esta cl@'{a}usula n@~{a}o tem a finalidade de induzir voc@^{e} a infringir quaisquer
patentes ou direitos de propriedade, nem de contestar a validade de quaisquer
reivindica@,{c}@~{o}es deste tipo; a @'{u}nica finalidade desta cl@'{a}usula @'{e} proteger a
integridade do sistema de distribui@,{c}@~{a}o do software livre, o qual @'{e}
implementado mediante pr@'{a}ticas de licen@,{c}as p@'{u}blicas. Muitas pessoas t@^{e}m feito
generosas contribui@,{c}@~{o}es @`{a} ampla gama de software distribu@'{i}do
atrav@'{e}s desse sistema, confiando na aplica@,{c}@~{a}o consistente deste
sistema; cabe ao autor/doador decidir se deseja distribuir software
atrav@'{e}s de qualquer outro sistema e um licenciado n@~{a}o pode
impor esta escolha.

Esta cl@'{a}usula visa deixar absolutamente claro o que se acredita
ser uma conseq@"{u}@^{e}ncia do restante desta Licen@,{c}a.

@item
Se a distribui@,{c}@~{a}o e/ou uso da Biblioteca for restrito em
determinados pa@'{i}ses, tanto por patentes ou por interfaces protegidas por direito autoral, o
titular original dos direitos autorais que colocar a Biblioteca sob esta Licen@,{c}a
poder@'{a} acrescentar uma limita@,{c}@~{a}o geogr@'{a}fica de distribui@,{c}@~{a}o expl@'{i}cita excluindo esses
pa@'{i}ses, de modo que a distribui@,{c}@~{a}o seja permitida somente nos pa@'{i}ses ou entre os
pa@'{i}ses que n@~{a}o foram exclu@'{i}dos dessa forma. Nesse caso, esta Licen@,{c}a passa a incorporar
a limita@,{c}@~{a}o como se esta tivesse sido escrita no corpo desta Licen@,{c}a

@item
A Free Software Foundation [Funda@,{c}@~{a}o Software Livre] poder@'{a} de tempos em tempos
publicar vers@~{o}es revisadas e/ou novasda Licen@,{c}a P@'{u}blica Geral Menor.
Essas novas vers@~{o}es ser@~{a}o semelhantes em esp@'{i}rito @`{a} presente vers@~{a}o, podendo,
por@'{e}m, ter diferen@,{c}as nos detalhes, para tratar de novos problemas ou preocupa@,{c}@~{o}es.

Cada vers@~{a}o recebe um n@'{u}mero distinto de vers@~{a}o. Se a Biblioteca
especificar um n@'{u}mero de vers@~{a}o desta Licen@,{c}a, aplic@'{a}vel @`{a} Biblioteca ou a
"qualquer vers@~{a}o posterior", voc@^{e} ter@'{a} a op@,{c}@~{a}o de seguir os termos e
condi@,{c}@~{o}es tanto daquela vers@~{a}o como de qualquer vers@~{a}o posterior publicada pela
Free Software Foundation. Se a Biblioteca n@~{a}o especificar um
n@'{u}mero de licen@,{c}a da vers@~{a}o, voc@^{e} poder@'{a} escolher qualquer vers@~{a}o j@'{a} publicada pela
Free Software Foundation.

@item
Se voc@^{e} desejar incorporar partes da Biblioteca em outros programas
livres cujas condi@,{c}@~{o}es de distribui@,{c}@~{a}o sejam incompat@'{i}veis com estas,
escreva ao autor para solicitar permiss@~{a}o. Para software cujos
direitos autorais pertencerem @`{a} Free Software Foundation, escreva @`{a}
Funda@,{c}@~{a}o; algumas vezes, fazemos exce@,{c}@~{o}es nesse sentido. Nossa
decis@~{a}o ser@'{a} guiada pelos dois objetivos de preservar a condi@,{c}@~{a}o livre
de todos os derivados de nosso software livre e de promover o compartilhamento
e reutiliza@,{c}@~{a}o de softwares, de modo geral.

@heading EXCLUS@~{A}O DE GARANTIA

@item
COMO A BIBLIOTECA @'{E} LICENCIADA SEM CUSTO, N@~{A}O H@'{A} NENHUMA
GARANTIA PARA A BIBLIOTECA, NO LIMITE PERMITIDO PELA LEI APLIC@'{A}VEL.
EXCETO QUANDO DE OUTRA FORMA ESTABELECIDO POR ESCRITO, OS TITULARES DOS DIREITOS AUTORAIS E/OU
OUTRAS PARTES FORNECEM A BIBLIOTECA "NO ESTADO EM QUE SE ENCONTRA", SEM NENHUMA GARANTIA DE QUALQUER
TIPO, TANTO EXPRESSA COMO IMPL@'{I}CITA, INCLUINDO, DENTRE OUTRAS, AS
GARANTIAS IMPL@'{I}CITAS DE COMERCIABILIDADE E ADEQUA@,{C}@~{A}O PARA UMA
FINALIDADE ESPEC@'{I}FICA. O RISCO INTEGRAL QUANTO @`{A} QUALIDADE E DESEMPENHO DA BIBLIOTECA @'{E} ASSUMIDO POR VOC@^{E}. CASO A
BIBLIOTECA CONTENHA DEFEITOS, VOC@^{E} ARCAR@'{A} COM
OS CUSTOS DE TODOS OS SERVI@,{C}OS, REPAROS OU CORRE@,{C}@~{O}ES NECESS@'{A}RIAS.

@item
EM NENHUMA CIRCUNST@^{A}NCIA, A MENOS QUE EXIGIDO PELA LEI APLIC@'{A}VEL OU ACORDADO
POR ESCRITO, QUALQUER TITULAR DE DIREITOS AUTORAIS OU QUALQUER OUTRA PARTE QUE POSSA MODIFICAR
E/OU REDISTRIBUIR A BIBLIOTECA, CONFORME PERMITIDO ACIMA, SER@'{A} RESPONS@'{A}VEL PARA COM VOC@^{E}
POR DANOS, INCLUINDO ENTRE OUTROS QUAISQUER
DANOS GERAIS, ESPECIAIS, FORTUITOS OU EMERGENTES, ADVINDOS DO USO OU IMPOSSIBILIDADE DE USO DA
BIBLIOTECA (INCLUINDO, ENTRE OUTROS, PERDA DE DADOS, DADOS SENDO
GERADOS DE FORMA IMPRECISA, PERDAS SOFRIDAS POR VOC@^{E} OU TERCEIROS OU A
IMPOSSIBILIDADE DA BIBLIOTECA DE OPERAR COM QUALQUER OUTRO SOFTWARE), MESMO QUE
ESSE TITULAR, OU OUTRA PARTE, TENHA SIDO AVISADO SOBRE A POSSIBILIDADE DESSES
DANOS.
@end enumerate

@heading FINAL DOS TERMOS E CONDI@,{C}@~{O}ES

@page
@unnumberedsec Como Aplicar Estes Termos para Suas Novas Bibliotecas
Se voc@^{e} desenvolver uma nova biblioteca e quiser que ela seja da maior
utilidade poss@'{i}vel para o p@'{u}blico, n@'{o}s recomendamos fazer dela um software livre que
todos possam redistribuir e modificar. Voc@^{e} pode fazer isto permitindo
a redistribui@,{c}@~{a}o sob estes termos (ou, alternativamente, sob os termos
da Licen@,{c}a P@'{u}blica Geral comum)

Para fazer isto, anexe as notifica@,{c}@~{o}es seguintes @`{a} biblioteca.
@'{E} mais seguro anex@'{a}-las ao come@,{c}o de cada arquivo-fonte, de modo a
transmitir do modo mais eficiente a exclus@~{a}o de garantia; e cada arquivo deve
ter ao menos a linha de "direitos autorais reservados" e uma indica@,{c}@~{a}o de onde a notifica@,{c}@~{a}o
completa se encontra.


@smallexample
@var{uma linha para informar o nome da biblioteca e uma breve id@'{e}ia do que ela faz.}
Direitos Autorais Reservados (C) <ano>  @var{nome do autor}

Esta biblioteca @'{e} software livre; voc@^{e} pode redistribu@'{i}-la e/ou
modific@'{a}-la sob os termos da Licen@,{c}a P@'{u}blica Geral
Menor do GNU conforme publicada pela Free Software Foundation; tanto a
vers@~{a}o 2.1 da Licen@,{c}a, ou (a seu crit@'{e}rio) qualquer vers@~{a}o posterior.

Esta biblioteca @'{e} distribu@'{i}do na expectativa de que seja @'{u}til,
por@'{e}m, SEM NENHUMA GARANTIA; nem mesmo a garantia impl@'{i}cita de
COMERCIABILIDADE OU ADEQUA@,{C}@~{A}O A UMA FINALIDADE ESPEC@'{I}FICA. Consulte a Licen@,{c}a P@'{u}blica
Geral Menor do GNU para mais detalhes.

Voc@^{e} deve ter recebido uma c@'{o}pia da Licen@,{c}a P@'{u}blica Geral Menor
do GNU junto com esta biblioteca; se n@~{a}o, escreva para a Free Software
Foundation, Inc., no endere@,{c}o 59 Temple Street, Suite 330, Boston, MA 02111-1307 USA.
@end smallexample

Inclua tamb@'{e}m informa@,{c}@~{o}es sobre como contatar voc@^{e} por correio eletr@^{o}nico e por meio
postal.
Voc@^{e} tamb@'{e}m pode solicitar a seu empregador (se voc@^{e} for um programador) ou
a sua institui@,{c}@~{a}o acad@^{e}mica, se for o caso, para assinar uma "ren@'{u}ncia de direitos autorais" sobre a biblioteca, se
necess@'{a}rio. Segue um exemplo; altere os nomes:
    
@smallexample
A Yoyodyne Ltda., neste ato, renuncia a todos eventuais direitos autorais sobre a
biblioteca 'Frob' (uma biblioteca para ajustar fechaduras), escrita por James
Random Hacker.

<Assinatura de Ty Coon>, 1 de abril de 1990
Ty Coon, Presidente
@end smallexample

Isso @'{e} tudo!

@node History, Platforms, Copying, Top
@unnumbered History of Geomview's Development

Geomview foi originalmente escrito no Geometry Center da the University
of Minnesota in Minneapolis.
O Geometry Center era um centro de pesquisa e educa@,{c}@~{a}o
fundado pela National Science Foundation, com a miss@~{a}o de promover
pesquisa e comunica@,{c}@~{a}o de assuntos relacionados @`{a} matem@'{a}tica.  A maioria do trabalho era
direcionado ao uso de computadores para ajudar a visualiza@,{c}@~{a}o de conceitos matem@'{a}ticos.

O projeto que eventualmente levou ao Geomview
come@,{c}ou no ver@~{a}o de 1988 com o trabalho de Pat
Hanrahan sobre um programa de visualiza@,{c}@~{a}o chamado MinneView.  Pouco tempo
depois Charlie Gunn come@,{c}ou o desenvolvimento da OOGL
(Object Oriented Graphics Language) juntamente com o
MinneView.  Muitas pessoas comtribuiram para a OOGL e o MinneView,
incluindo Stuart Levy, Mark Meuer, Tamara Munzner, Steve
Anderson, Mario Lopez, Todd Kaplan.

Em 1991 o staff do Geometry Center come@,{c}ou o trabalho sobre uma nva e melhorada
vers@~{a}o da OOGL, e um novo e melhorado programa de visualiza@,{c}@~{a}o, o qual eles
chamaram Geomview.  Naquele tempo essencialmente o @'{u}nico jogo no comercio para
gr@'{a}ficos interativos em tr@^{e}s dimens@~{o}es era Silicon Graphics (SGI), de forma que Geomview foi
desenvolvido inicialmente em esta@,{c}@~{o}es de trabalho SGI, usando a IRIS GL.  A primeira
vers@~{a}o foi finalizada em Janeiro de 1992.  Essa primeira vers@`{a}o tornou-se muito
popular entre visitantes do Geometry Center, e atrav@'{e}s do ftp do
Centro (isso ocorreu antes do advento da web) pessoas em outras institui@,{c}@~{o}es come@,{c}aram
a usar essa primeira vers@~{a}o tamb@'{e}m.

Adicionalmente a esta@,{c}@~{o}es de trabalho SGI o Geometry Center tinha
algumas esta@,{c}@~{o}es NeXT completas, de forma que ap@'{o}s Geomview estar sendo executado
em m@'{a}quinas SGIs a equipe desenvolveu uma vers@~{a}o para NeXTStep tamb@'{e}m.
Nessa @'{e}poca ouveram muitos milhares de pessoas usando Geomview
ao redor do mundo.

Alguns anos depois a equipe portou Geomview para o X windows e a OpenGL, e
eventualmente, com o desaparecimento da NeXT, a vers@~{a}o para NeXT seguiu o mesmo
caminho.

Nessa miss@~{a}o de incentivar a comunica@,{c}@~{a}o entre pesquisadores e educadores,
o Geometry Center desenvolveu um web site, www.geom.umn.edu, mais tarde
em 1993.  esse foi um dos primeiros 300 web sites que existiram no mundo.  Uma parte desse
web site era certamente devotado ao Geomview, e ajudou a propagar o
trabalho durante sua exist@^{e}ncia.

O Geometry Center fechou suas facilidades de "tijolos e cimento" em Agosto
de 1998 (NSF cortou suas verbas), mas o web site continuou a exixtir, e
Geomview continuou a ser popular ao redor do mundo.  Em Dezembro de
1999 algum membro da equipe original do Geometry Center configurou
@uref{http://www.geomview.org} como casa permanente na web para o
Geomview.

Os autores originais do Geomview, bem como v@'{a}rios outros volun@'{a}rios
ao redor do mundo, est@~{a}o ainda ativamente envolvidos na utiliza@,{c}@~{a}o e no desenvolvimento do
Geomview.

@menu
* Authors::                     Autores.
@end menu

@node Authors,  , History, History
@unnumberedsec Authors

Tamara Munzner, Stuart Levy, e Mark Phillips s@~{a}o os autores originais do
Geomview. Celeste Fowler, Charlie Gunn, e Nathaniel Thurston tamb@'{e}m
fazem contribui@,{c}@~{o}es sgnificativas.  Daniel Krech e Scott Wisdom fizeram o
NeXTStep e a adapta@,{c}@~{a}o do RenderMan, e Daeron Meyer e Tim Rowley fizeram a
adapta@,{c}@~{a}o para o X windows.  Muitos outros membros do estado maior do Geometry Center, bem como
muitas pessoas em muitos lugares, tamb@'{e}m contribu@'{i}ram.

Mark Phillips escreveu esse manual, com ajuda substancial de Stuart Levy
e Tamara Munzner.  Incont@'{a}veis usu@'{a}rios do Geomview tamb@'{e}m foram de grande
ajuda por meio da leitura do manual e indicando nossos enganos.


@node Platforms, Pronunciation, History, Top
@unnumbered Supported Platforms

Geomview 1.9 pode -- em princ@'{i}pio -- compilar e executarsobre qualquer claramente
recente sistemas operacionais semelhantes ao Unix. Especificamente, Geomview executa sobre Linux e sobre
Cygwin (Cygwin emula um ambiente semelhante ao SystemV Unix environment sob o Microsoft
Windows). Desafortunadamente Geomview compila com MacOS X (Darwin), mas
aparentemente comunica@,{c}@~{o}es com Geomview por meio de pipes e sockets
causam falha de segmentac@~{a}o. Sinta-se livre para consertar essa falha! Veja @ref{Contributing},
para detalhes.

@c Geomview runs on a wide variety of Unix systems. It has been tested on
@c each of the following systems: Linux, FreeBSD, SGI, Sun either (Sun-OS
@c 4.1.x and Solaris), HP RISC, Dec Alpha, RS/6000, and NeXT.  Precompiled
@c distributions are available for all of these systems.  Using either
@c OpenGL or the generic X11 renderer it can probably be compiled on other
@c Unix systems as well.

@c There is not a version of Geomview for Microsoft Windows.  The main
@c reason for this is that at the time when Geomview was written, personal
@c computers were not fast enough to make interactive 3D graphics feasible,
@c and by the time fast-enough PCs came around, the Geometry Center,
@c where Geomview was developed, was in the process of being closed.  The
@c staff started work on a port to Windows but was not able to finish it
@c before the Center shut down.

@c If you would like to see a version of Geomview for Windows, 
@c you can contribute to its development in several ways.
@c @xref{Contributing}, for details.

@c There is also no version of Geomview for Macintosh.

@node Pronunciation, Overview, Platforms, Top
@unnumbered How to Pronounce ``Geomview``

A palavra 'Geomview' @'{e} uma combina@,{c}@~{a}o da primeira s@'{i}laba da palavra
'geometry', e da palavra 'view'. Os autores pronunciam Geomview
como uma palavra ox@'{i}tona, isto @'{e}, tonicidade na primeira s@'{i}laba.

@display
  GE-om-view
@end display

Algumas pessoas colocam a tonicidade na segunda s@'{i}laba, onde Geomview
cai na palavra 'geometry', mas os autores originais, que
criaram o nome, preferem a pron@'{u}ncia com tonicidade na primeira
s@'{i}laba.


@comment
@comment @node node-name, next, previous, up
@comment

@comment ****************************************************************
@node Overview, Tutorial, Pronunciation, Top
@chapter Overview

O principal objetivo do Geomview @'{e} mostrar objetos cuja geometria @'{e} fornecida,
permitindo controle interativo sobre detalhes tais como ponto de vis@~{a}o, velocidade
de movimento, apar@^{e}ncia de superf@'{i}cies e linhas, e assim por diante.  Geomview pode
manusear qualquer n@'{u}mero de objetos e permite controle coletivo ou
separado sobre eles.

A maneira mais simples de usar Geomview @'{e} como um visualizador independente para ver
e manipular objetos.  Geomview pode mostrar objetos descritos em uma variedade
de formatos de arquivo.  Geomview @'{e} acompanhado com uma larga variedade de objetos como exemplo, e
voc@^{e} pode criar seus pr@'{o}prios objetos.

Voc@^{e} pode tamb@'{e}m usar Geomview para manusear os dados a serem mostrados provenientes de
outro programa que est@'{a} sendo executado simult@^{a}neamente.  Como o outro programa
modifica os dados, a im@'{a}gem no geomview reflete as modifica@,{c}òes.  Programas
que geram objetos e utilizam o Geomview para mostr@'{a}-los s@~{a}o chamados
@emph{m@'{o}dulos externos}.  M@'{o}dulos externos podem controlar quase todos os
asp@'{e}ctos do Geomview.  A id@'{e}ia aqui @'{e} que muitos asp@'{e}ctos de visualiza@,{c}@~{a}o
e partes da intera@,{c}@~{a}o de programas geom@'{e}tricos s@~{a}o independentes do
conte@'{u}do geom@'{e}trico e podem ser coletados conjuntamente em uma pe@,{c}a simples de
programa que pode ser usada em uma larga variedade de situa@,{c}@~{o}es.  O autor
de um m@'{o}dulo externo pode concentrar-se sobre a implementa@,{c}@~{a}o dos algor@'{i}tmos
desejados e deixar os asp@'{e}ctos de visualiza@,{c}@~{a}o ao Geomview.  Geomview @'{e} acompanhado
por uma cole@,{c}@~{a}o de m@'{o}dulos externos a t@'{i}tulo de exemplo, e esse manual descreve
como escrever seu pr@'{o}prio @emph{m@'{o}dulo externo}.

Geomview @'{e} o produto de um esfor@,{c}o no @dfn{Geometry Center} para disponibilizar
um @dfn{software} de geometria interativa que @'{e} particularmente apropriado para
pesquisa matem@'{a}tica e educa@,{c}@~{a}o.  Em particular, Geomview pode mostrar
coisas no espa@,{c}o hiperb@'{o}lico e no espa@,{c}o esf@'{e}rico bem como no espa@,{c}o Euclidiano.

Geomview permite m@'{u}ltiplos objetos que s@~{a}o controlados independentemente e
c@^{a}meras.  As c@^{a}meras fornecem controle interativo para movimento, apar@^{e}ncias
(incluindo ilumina@,{c}@~{a}o, sombreamento, e materiais), selecionando um objeto,
aresta ou n@'{i}vel de v@'{e}rtice, instant@^{a}neos em um arquivo de imagem SGI ou no formato
Renderman RIB, a adi@,{c}@~{a}o ou apagamento de objetos @'{e} poss@'{i}vel atrav@'{e}s da manipula@,{c}@~{a}o
direta do mouse, pain@'{e}is de controle, e teclas de atalho via teclado.

Geomview suporta os seguintes tipos de dados simples: poliedros com
v@'{e}rtices compartilhados (.off), quadril@'{a}teros, malhas retangulares, vetores,
e ajustes em superf@'{i}cies de Bezier de grau arbitr@'{a}rio incluindo ajustes
racionais. Hierarqu@'{i}as de objetos podem ser constru@'{i}das com listas de objetos
e inst@^{a}ncias de objeto(s) transformado(s) por uma ou mais matrizes 4x4.
Por@,{c}@~{o}es arbitr@'{a}rias de modifica@,{c}@~{o}es de hierarqu@'{i}as podem ser transmitidas por meio
da cria@,{c}@~{a}o de refer@^{e}ncias nomeadas.

Geomview pode mostrar sa@'{i}das gr@'{a}ficas tridimensionais provenientes do Mathematica e do Maple.

@comment ****************************************************************
@node Tutorial, Interaction, Overview, Top
@chapter Tutorial

Esse cap@'{i}tulo conduzir@'{a} voc@^{e} atrav@'{e}s de alguns usos elementares do Geomview.
Trabalhando do come@,{c}o ao fim desse cap@'{i}tulo de frente a um computador onde voc@^{e} pode tentar
acompanhar os exemplos fornecidos aqui voc@^{e} pegar@'{a} um pouco do que voc@^{e} pode fazer com
Geomview.

Para iniciar o Geomview, coloque seu usu@'{a}rio e sua senha no computador e abra uma janela de shell.  Uma
janela de shell @'{e} uma janela na qual voc@^{e} pode digitar comandos Unix; o prompt
na janela usualmente termina com um '%'.  Na janela de shell (o cursor do
mouse deve estar posicionado sobre a janela) digite o seguinte (@kbd{@key{Enter}} aqui
significa pressione a tecla "Enter"):

@example
geomview tetra dodec @key{Enter}
@end example

Esse comando inicia o geomview e chama dois objetos exemplo, um
tetraedro e um dodecaedro.  Ap@'{o}s poucos segundos tr@^{e}s janelas
ir@~{a}o aparecer; @pxref{figinitial, Figure}.

@float Figure,figinitial
@image{figs/initial}
@caption{Tela Inicial do Geomview.}
@end float

O painel @`{a} esquerda @'{e} o painel de controle principal do Geomview; Esse painel @'{e} chamado
de painel @emph{Main} (principal).  O painel menor ao centro @'{e} o
painel @emph{Tools} (de ferramentas) e serve para selecionar diferentes tipos de movimentos.
A janela do lado direito @'{e} a janela de c@^{a}mera e nessa janela voc@^{e} v@^{e} um
tetraedro largo e um dodecaedro que est@'{a} parcialmente obscurecido
pelo tetraedro.

Geomview tem alguns pain@'{e}is mais por padr@~{a}o ele mostra somente esses tr@^{e}s.
iremos descrever alguns asp@'{e}ctos desses tr@^{e}s e alguns dos outros nesse
tutorial.  Voc@^{e} pode ler mais sobre esses e outros pain@'{e}is nos cap@'{i}tulos
adiante neste manual.

Coloque o cursor do mouse na janela de c@^{a}mera e pressione e mantenha pressionado o
bot@~{a}o esquerdo do mouse.  Agora, enquanto mant@'{e}m pressionado o bot@~{a}o, lentamente mova o
mouse com movimentos pequenos.  Voc@^{e} ver@'{a} a figura rotacionar na dire@,{c}@~{a}o na qual voc@^{e}
mover o mouse.    Se voc@^{e} liberar o bot@~{a}o do mouse enquanto move o
mesmo, a figura continua girando.  Para parar o movimento de rota@,{c}@~{a}o, mantenha o mouse sobre a
figura e pressione rapdamente o bot@~{a}o esquerdo do mesmo.

Geomview utiliza o modelo da @emph{esfera de vidro} para os movimentos iniciados atrav@'{e}s do mouse.  Isso
significa que voc@^{e} est@'{a} supondo o objeto como estando dentro de uma
esfera invis@'{i}vel e o cursor do mouse como sendo uma al@,{c}a fora da esfera provida de uma ventosa.
Quando voc@^{e} mant@'{e}m pressionado o bot@~{a}o esquerdo do mouse, a ventosa da al@,{c}a gruda na
esfera; quando voc@^{e} libera o bot@~{a}o do mouse, a ventosa da al@,{c}a libera a
esfera.  Movendo o mouse enquanto mant@'{e}m pressionado o bot@~{a}o faz com que a
esfera (e conceq@"{u}@^{e}ntemente o objeto) mova-se na mesma dire@,{c}@~{a}o que o
mouse.

Adicionalmente para os dois s@'{o}lidos que est@~{a}o atualmente na tela voc@^{e} pode tamb@'{e}m ver duas molduras de fios
em forma de caixa na janela de c@^{a}mera.  Essas s@~{a}o as "caixas associadas" dos dois
objetos.  Por padr@~{a}o Geomview coloca uma caisa associada em torno de cada objeto
que @'{e} mostrada de forma que voc@^{e} tenha uma id@'{e}ia de o quanto grande o objeto @'{e}.

Note que quando voc@^{e} move o mouse em torno do tetraedro e do
dodecaedro eles se movem como se fossem uma @'{u}nica figura.  Isso ocorre porque por padr@~{a}o o que voc@^{e} est@'{a}
movendo atualmente @'{e} o "World" (mundo).  Para mover um dos objetos individualmente em lugar de
o mundo como um todo, mova o cursor do mouse para o navegador de alvos (@emph{Targets}) no
painel principal (@emph{Main}).  Clique (qualquer bot@~{a}o) sobre a palavra @emph{tetra}.
Isso faz com que o tetraedro seja o "objeto alvo".  Agora mova o cursor
de volta @`{a} janela de c@^{a}mera e voc@^{e} poder@'{a} rotacionar apenas o tetraedro.

O movimento que voc@^{e} aplicou at@'{e} agora foi a rota@,{c}@~{a}o,
porque esse @'{e} o modo de modo de movimento selecionado no painel de ferramentas
(@emph{Tools}).  Para efetuar o movimento de transla@,{c}@~{a}o em lugar do movimento de rota@,{c}@~{a}o, clique sobre o bot@~{a}o transla@,{c}@~{a}o (@emph{Translate}).
Agora quando voc@^{e} mover o mouse na janela de c@^{a}mera enquanto mant@'{e}m pressionado o
bot@~{a}o esquerdo, o tetraedro (que deve ser ainda o objeto alvo
de antes) ir@'{a} ser transladado na dire@,{c}@~{a}o que voc@^{e} move o mouse.  Note
que voc@^{e} pode transladas o tetraedro na dire@,{c}@~{a}o da borda da janela enquanto voc@^{e}
mant@'{e}m pressionado o bot@~{a}o esquerdo do mouse.  Se voc@^{e} liberar o bot@~{a}o do
mouse enquanto move o mesmo, o tetraedro ir@'{a} continuar o movimento sozinho.  O tetraedro
mover-se-@'{a} ao contr@'{a}rio do que ocorria antes muito rapidamente de forma que @'{e} muito f@'{a}cil perder o rastro de onde ele se encontra.

Se voc@^{e} acidentalmente perder o tetraedro atrav@'{e}s de transla@,{c}@~{a}o para muito longe
da vis@~{a}o da janela, voc@^{e} pode peg@'{a}-lo de vlta atrav@'{e}s de um clique sobre o
bot@~{a}o Centro (@emph{Center}) no painel de ferramentas (@emph{Tools}).  Isso far@'{a} com que o tetraedro
retorne para a sua posi@,{c}@~{a}o inicial.

Clique sobre o bot@~{a}o Centro (@emph{Center}) para trazer o tetraedro ao centro da janela de c@^{a}mera, e
ent@~{a}o coloque-o em uma posi@,{c}@~{a}o de forma que voc@^{e} possa ver completamente o
dodecaedro.

Seu mundo agora tem dois objetos que est@~{a}o um ao lado do outro.  Voc@^{e}
pode ver o dodecaedro no meio da janela de c@^{a}mera e pode ver parte
do tetraedro parcialmente fora da janela de c@^{a}mera.  Volte para o navegador de alvos
(@emph{Targets}) no painel principal (@emph{Main}) e clique sobre o "World" para selecionar o
referido mundo novamente.  Agora clique sobre o bot@~{a}o "Olhar Para" (@emph{Look At}) no
painel de ferramentas (@emph{Tools}). Voc@^{e} pode ver o dodecaedro e o tetraedro
ajustando-se ao meio da janela (figura
@pxref{figlookatworld}).  O bot@~{a}o "Olhar Para" (@emph{Look At}) posiciona a c@^{a}mera em uma posi@,{c}@~{a}o tal
que o objeto alvo fique centrado na janela.
@float Figure,figlookatworld
@image{figs/fig2}
@caption{Olhando para o Mundo.}
@end float
Agora coloque o cursor sobre o meio do dodecaedro e d@^{e} sobre ele um duplo clique com
o bot@~{a}o direito do mouse.  Isso significa clicar no mouse para baixo e para cima duas vezes em
uma r@'{a}pida sucess@~{a}o.  Note que o dodecaedro torna-se o objeto
alvo; voc@^{e} pode ver isso no navegador de alvos (@emph{Targets})
do painel principal (@emph{Main}).  Um duplo clique no bot@~{a}o direito do mouse sobre um objeto
@'{e} outra forma de fazer esse objeto tornar-se o objeto alvo.

@float Figure,figappearance
@image{figs/ap}
@caption{A Painel Apar@^{e}ncia.}
@end float
V@'{a} para o menu @emph{Inspect} no topo do painel principal (@emph{Main}) e selecione
Apar@^{e}ncia (@emph{Appearance}).  Isso faz aparecer o painel "Apar@^{e}ncia"
(@emph{Appearance}).  Quando ele aparece, se estiver parcialmente obscurecido por outra janela do Geomview
voc@^{e} pode mov@^{e}-lo para um lado arrastando sua moldura com o bot@~{a}o
do meio do mouse pressionado.

O painel Apar@^{e}ncia (@emph{Appearance}) permite a voc@^{e} controlar v@'{a}rias coisas sobre a
maneira como o Geomview desenha objetos.  Note os bot@~{o}es rotulados com @emph{[af] Faces} e
@emph{[ae] Edges} (arestas).  Clique sobre o @emph{[ae] Edges} uma vez, e note
que Geomview est@'{a} agora ressalta/destaca as arestas do dodecaedro.  Clique sobre o @emph{[ae] Edges}
novamente e as arestas desaparecem.  Clique muitas vezes e assista as arestas
indo e voltando.  Quando voc@^{e} tiver feito isso o suficiente, deixe as arestas habilitadas
e clique sobre o bot@~{a}o @emph{[af] Faces}.  Essa a@,{c}@~{a}o alterna entre exibir
ou n@~{a}o as faces.  Clique sobre o bot@~{a}o novamente para de forma que a exibi@,{c}@~{a}o das face fique habilitada.

Agora clique sobre o bot@~{a}o @emph{[Cf] Faces} sob a palavra @emph{COLOR}. Um
painel de escolha de cores aparecer@'{a} (@pxref{figcolorchooser, Figure}).
@float Figure,figcolorchooser
@image{figs/color}
@caption{Painel de Escolha de Cores.}
@end float

@ifset forms
Coloque o cursor no hex@'{a}gono de cor nesse painel e pressione o bot@~{a}o 
esquerdo do mouse.  Lentamente mova o mouse em torno desse ponto.  Isso arrasta o pequeno
ponto negro em volta para escolher uma nova cor para o dodecaedro.
@end ifset

@ifclear forms
Note os tr@^{e}s bot@~{o}es deslizantes, @emph{H}, @emph{S}, e @emph{V},
controlando a matiz (@emph{hue}), satura@,{c}@~{a}o, e valor (ilumina@,{c}@~{a}o).
Clicando sobre o bot@~{a}o @emph{HSV} fornece um diferente conjunto de bot@~{o}es deslizantes,
um para vermelho (@emph{red}), outro para verde (@emph{green}), e outro para azul (@emph{ blue}).
Valores num@'{e}ricos para ambos os sistemas de cores RGB e HSV
podem ser vistos ou editados na parte inferior do painel.
@end ifclear
A cor iinicial do dodecaedro foi especificada no arquivo
@file{dodec} que voc@^{e} chamou quando iniciamos o Geomview.  A cor que
voc@^{e} especificou com o painel de
cores sobrescreveu as cores antigas.  Voc@^{e} pode ajustar a intensidade da
cor com o bot@~{a}o deslizante @emph{Intensity}.  Quando voc@^{e} encontrar uma cor que
voc@^{e} gosta, clique sobre o bot@~{a}o @emph{Done}.  

Agora coloque o cursor do mouse em algum lugar sobre sobre o fundo cinza da janela de c@^{a}mera e duplo-clique
no bot@~{a}o direito; isso seleciona "World" como objeto alvo.
Clique no bot@~{a}o @emph{Look At} para para olhar para o mundo novamente.

Note que no painel de Apar@^{e}ncia (@emph{Appearance}) as escolhas dos bot@~{o}es
se modificavam @`{a} medida que o lado esquerdo tamb@'{e}m mudava com o dodecaedro.  Isso ocoore
porque o painel @emph{Appearance} sempre mostra as escolhas para
o objeto alvo, que agora @'{e} o mundo, o qual ainda tem suas
escolhas padr@~{a}o.

Clique sobre o bot@~{a}o @emph{[ab] BBox} sob a palavra @emph{Draw}.
A caixa associada desaparece.  agora pona o cursor de volta na janela de
c@^{a}mera.  No teclado, digite as teclas @kbd{a }b.  Note que a
caixa associada aparece novamente.  @kbd{a }b @'{e} o atalho de teclado para
o bot@~{a}o que alterna entre a exibi@,{c}@~{a}o ou n@~{a}o da caixa associada; a seq@"{u}@^{e}ncia de caracteres "[ab]" aparece sobre o
bot@~{a}o para indicar isso.  A maioria dos bot@~{o}es do Geomview possuem atalhos
de teclado que voc@^{e} pode usar se preferir.  Isso ser@'{a} @'{u}ltil quando voc@^{e}
estiver familiarizado com o Geomview e n@~{a}o quiser ter de se mover
entre uma montanha de pain@'{e}is.

Agora selecione o tetraedro, use qualquer das duas formas: duplo-clicando o bot@~{a}o direito
do mouse sobre o tetraedro, ou selecionando "tetra" no navegador de alvos (@emph{Targets}).
Ent@~{a}o clique sobre o bot@~{a}o @emph{Delete} do menu @emph{Edit} no painel principal (@emph{Main}).  O
tetraedro deve desaparecer.  Essa @'{e} a forma de voc@^{e} se livrar de um objeto.

Voc@^{e} pode tamb@'{e}m chamar objetos de dentro do Geomview.  Clique sobre o menu
@emph{File} no painel principal (@emph{Main}) e escolha abrir (@emph{Open}).
O painel de arquivos (@emph{Files}) ir@'{a} aparecer.
@c
Abaixo do meio desse painel, onde se l@^{e} @emph{Path List}, temos um navegador com tr@^{e}s linhas detro dele; a
segunda linha @'{e} um diret@'{o}rio com montanhas de exemplos do Geomview dentro dele.
Clique sobre aquela segunda linha; @pxref{figfilespanel, Figure}. Role para baixo
na lista de arquivos at@'{e} voc@^{e} ver @file{tref.off}.  Clique sobre aquela linha,
e ent@~{a}o clique sobre o bot@~{a}o @emph{OK}.  Um grande tubo em forma de trevo
ir@'{a} aparecer em sua janela.  Clique sobre o bot@~{a}o @emph{Hide} no painel
@emph{Files} para dispensar o painel.

@float Figure,figfilespanel
@image{figs/secondlinelist}
@caption{O Painel de Arquivos.}
@end float

Agora clique sobre o bot@~{a}o @emph{Reset} no painel de ferramentas (@emph{Tools}).  Isso
far@'{a} com que todas as figuras rtornem ao centro da janela de c@^{a}mera.  Voc@^{e} pode ver um
dodecaedro e uma protuber@^{a}ncia do trevo (@pxref{figtrefdodec, Figure}).

Brinque com a protuber@^{a}ncia do trevo e o dodecaedro.  Fa@,{c}a experi@^{e}ncias com
alguns outros bot@~{o}es no painel de ferramentas (@emph{Tools}).  Tente colorir o
trevo com o painel de apar@^{e}ncia (@emph{Appearance}).

Para um tutorial sobre criar seus pr@'{o}prios objetos para cham@'{a}-los dentro do Geomview,
veja @file{doc/oogltour} distribuido com Geomview.  As coisas
naquele arquivo ir@~{a}o ser incorporadas em futuras vers@~{o}es desse manual.

@float Figure,figtrefdodec
@image{figs/trefdodecinter}
@caption{Trevo e Dodecaedro.}
@end float

@comment ****************************************************************
@node Interaction, OOGL File Formats, Tutorial, Top
@chapter Interaction

Esse cap@'{i}tulo descreve como voc@^{e} interage com Geomview atrav@'{e}s do
mouse e do teclado.

@menu
* Starting Geomview::           Iniciando o Geomview.
* Command Line Options::        Op@,{c}@~{o}es de Linha de Comando.
* Basic Interaction::           Intera@,{c}@~{o}es B@'{a}sicas: O Painel Principal.
* Loading::                     Chamando Objetos Dentro do Geomview.
* Mouse Motions::               Usando o Mouse para Manipular Objetos.
* Appearance::                  Modificando a Forma de Ver as Coisas.
* Cameras::                     C@^{a}meras.
* Saving::                      Gravando seu Trabalho.
* Commands::                    O Painel de Comandos.
* Keyboard Shortcuts::          Atalhos de Teclado.
@end menu

@comment ================================================================
@node Starting Geomview, Command Line Options, Interaction, Interaction
@section Starting Geomview

A forma usual para iniciar o Geomview @'{e} digitar @kbd{geomview @key{Enter}} em uma janela
de shell (@key{Enter} significa pressionar a tecla "Enter").  Esse procedimento carrega o Geomview na mem@'{o}ria do computador em
uns poucos segundos; uma ou mais janelas ir@~{a}o aparecer e voc@^{e} pode come@,{c}ar a
interagir com o Geomview imediatamente.

@'{E} tamb@'{e}m poss@'{i}vel especificar a@,{c}@~{o}es para o Geomview executar no
momento de iniciar fornecendo argumentos na linha de comando do shell.
Veja @ref{Command Line Options}.


@comment ================================================================
@node Command Line Options, Basic Interaction, Starting Geomview, Interaction
@section Command Line Options

Aqui est@~{a}o as op@,{c}@~{o}es de linha de comando que o Geomview permite:

@table @samp
@item -b @var{r} @var{g} @var{}b
Escolhe a cor de fundo da janela de c@^{a}mera para valores fornecidos de
@var{r} @var{g} @var{}b.
@c added by jorge
@c -b 0 0 1 - azul
@c -b 0 0 0 - preto
@c -b 1 1 1 - branco
@c -b 0.5 0.5 0.5 - cinza
@item -c @var{arquivo}
Interpreta os comandos GCL em @var{arquivo}, que pode ser o s@'{i}mbolo
especial @file{-} para a entrada padr@~{a}o.  Paa uma descri@,{c}@~{a}o de GCL,
veja @ref{GCL}.

@item -c @var{comando}
Comandos podem tamb@'{e}m serem fornecidos literalmente, como em
@example
-c "(ui-panel main off)"
@end example
Uma vez que @var{comando} inclui par@^{e}ntesis, que possuem significado especial para
o shell, @var{comando} deve receber ap@'{o}strofo.  Multiplas op@,{c}@~{o}es @var{-c} s@~{a}o permitidas.

@item -wins @var{n}
Faz com que Geomview mostre inicialmente @var{n} janelas de c@^{a}mera.

@item -wpos @var{largura},@var{altura}[@@@var{xmin},@var{ymin}]
Especifica a localiza@,{c}@~{a}o inicial e o tamanho da primeira janela de c@^{a}mera.  Os
valores para @var{largura}, @var{altura}, @var{xmin}, e @var{ymin} est@~{a}o em
coordenadas de tela (pixel).

@item -M[cg][ps[un|in|in6]] @var{PIPENOME}|@var{TCPPORT}
A op@,{c}@~{a}o @samp{-M} aceita modificadores: um sufixo @samp{g} espera
dados geom@'{e}tricos (o padr@~{a}o), enquanto um sufixo @samp{c} espera comandos
GCL. Um @samp{p} implica que a conec@,{c}@~{a}o pode usar um pipe nomeado (o
padr@~{a}o para tudo exceto para "NeXT"), enquanto @samp{s} implica no uso de
um "UNIX-domain socket" (o padr@~{a}o em "NeXT"). Uma vez que na vers@~{a}o 1.9 do
Geomview "Internet domain sockets" s@~{a}o tamb@'{e}m suportados; use @samp{sin} para
fazer o Geomview escutar uma porta IPv4 fornecida por @var{TCPPORT}, ou use
@samp{sin6} para fazer Geomview escute uma porta IPv6 (tamb@'{e}m como especificado
em @var{TCPPORT}). @samp{sun} @'{e} um sin@^{o}nimo para @samp{s}, i.e. use o
"Unix domain socket" com o nome @var{PIPENOME}. Se @var{PIPENOME}
inicia com uma barra ('/'), ent@~{a}o esse nome @'{e} assumido ser um caminho
absoluto, de outra forma o pipe nomeado  ou socket @'{e} criado sob o diret@'{o}rio
@file{$@{TMPDIR@}/geomview/}.

@b{Escutando fluxo de comando em portas TCP pode ser um risco de seguran@,{c}a,
como Geomview por si mesmo n@~{a}o toma nenhum tipo de precau@,{c}@~{a}o de seguran@,{c}a, Geomview simplesmente
executa todos os comandos alimentados a ele atrav@'{e}s do socket de rede. Isso
tamb@'{e}m implica entrada e sa@'{i}da para unidades de armazenamento locais devem ser permitidas remotamente.}

Exemplos:
@table @code
@item -M @var{nome_de_objeto}
Mostra (possivelmente mudando dinamicamente) geometria enviada de
programas @code{geomstuff} ou @code{togeomview}.  Essa op@,{c}@~{a}o "-M" escuta o
pipe nomeado @file{/tmp/geomview/nome_de_objeto}; voc@^{e} pode conseguir o mesmo
efeito com os comandos de shell abaixo:
@example
mkdir /tmp/geomview
mknod /tmp/geomview/nome_de_objeto p
@end example
(assumindo que o diret@'{o}rio e o pipe nomeado n@~{a}o existam atualmente), ent@~{a}o
executando o comando GCL:
@example
(geometry nome_de_objeto  < /tmp/geomview/nome_de_objeto)
@end example
(@pxref{geometry,@code{(geometry @dots{})}})

@item -Mc @var{pipenome}
Como @samp{-M} acima, mas espera comandos GCL, em lugar de dados
geom@'{e}tricos OOGL, na conec@,{c}@~{a}o.

@item -Mcs nome
L@^{e} comandos a partir do "UNIX-domain socket" nomeado.
@file{/tmp/geomview/nome}

@item -Mcsin 40000
L@^{e} comandos a partir da porta IPv4 @samp{40000}. Geomview por si mesmo n@~{a}o
toma qualquer precau@,{c}@~{a}o de seguran@,{c}a, de forma que "-Mcsin 40000" pode ser um risco de seguran@,{c}a.
@end table

@item -noopengl
Desabilita o uso de OpenGL para (possivelmente) convers@~{a}o acelerada de hardware,
mesmo que o bin@'{a}rio do Geomview tenha suporte a OpenGL compilado internamente. "-noopengl"
tamb@'{e}m desabilita o suporte a transpar@^{e}ncia e texturas na
janelas de c@^{a}mera. Instant@^{a}neos "RenderMan" ainda ter@~{a}o a transpar@^{e}ncia correta
e suporte a alguma textura limitada.

@item -nopanels
Inicia sem mostrar nenhum painel, somente a janelas gr@'{a}ficas.  Pain@'{e}is podem ser
invocados mais tarde da forma usual com as teclas de atalho @kbd{Px} ou com
comando @code{ui-panel}. Veja @ref{ui-panel, @code{(ui-panel @dots{})}}.

@item -noinit
N@~{a}o l@^{e} nenum arquivo de inicializa@,{c}@~{a}o. Por padr@~{a}o, geomview l@^{e} o arquivo
@file{.geomview} do systema, seguido daqueles em @file{$@{HOME@}/.geomview} e em
@file{./.geomview}.

@item -e @var{modulo}
Inicial um m@'{o}dulo externo; @var{modulo} @'{e} o nome associado ao
m@'{o}dulo chamado, aparecendo no painel principal no navegador de "Applications", como definido
pelo comando @code{emodule-define}. Veja @ref{emodule-define,
@code{(emodule-define @dots{})}}.

@item -start @var{module} @var{args} @dots{}
Como -e mas permite a voc@^{e} enviar argumentos para o m@'{o}dulo externo.  "--"
sinaliza o fim da lista de argumentos; o "--" pode ser omitido se for
o @'{u}ltimo argumento na linha de comando do Geomview.

@item -run @var{coamando-shell} @var{args} @dots{}
Como "-start" mas toma o caminho de arquivos do execut@'{a}vel do m@'{o}dulo externo
em lugar do nome do m@'{o}dulo.  Os caminhos de arquivo de todos os diret@'{o}rios de m@'{o}dulos conhecidos
s@~{a}o anexados ao final do caminho de busca do UNIX quando for invocado o @var{comando-shell}.

@end table

@comment ================================================================
@node Basic Interaction, Loading, Command Line Options, Interaction
@section Basic Interaction: The Main Panel

Normalmente quando voc@^{e} invoca Geomview, tr@^{e}s janelas aparecem: O
painel principal (@emph{Main}), o painel de ferramentas (@emph{Tools}), e uma janela de c@^{a}mera.
Geomview tem muitas outras janelas mas muitas coisas podem ser realizadas com essas
tr@^{e}s de forma que por padr@~{a}o as outras n@~{a}o aparecem.  Essa se@,{c}@~{a}o do
manual introduz alguns conceitos b@'{a}sicos que s@~{a}o usados nas se@,{c}@~{o}es restantes
do manual e descreve o painel principal (@emph{Main}).
@c
@float Figure,figmainpanel
@image{figs/main}
@caption{O Painel Principal}
@end float
@c
Geomview pode mostrar um n@'{u}mero arbitr@'{a}rio de objetos simultaneamente.  O
navegador @emph{Targets} no painel principal (@emph{Main}) mostra uma lista de todos
os objetos dos quais Geomview atualmente abertos.  Esse navegador tem uma
linha para cada objeto que voc@^{e} tiver chamado, adicionalmente algumas linhas para outros
objetos.  Um desses outros objetos @'{e} chamado @code{World} e corresponde a
a todos os objetos atualmente chamados, tratados como se eles fossem um
objeto.  A maioria das opera@,{c}@~{o}eos que voc@^{e} pode fazer sobre um objeto, tais como
aplicar um movimento ou mudar uma cor, pode tamb@'{e}m ser feita para o objeto
"World".

O navegador de alvos (@emph{Targets}) tamb@'{e}m possui uma entrada para cada c@^{a}mera.  Por
padr@~{a}o existe somente uma c@^{a}mera; @'{e} poss@'{i}vel adicionar mais delas atrav@'{e}s da
entrada @emph{New Camera} do painel principal (@emph{Main}) via menu @emph{File}.
Geomview trata c@^{a}meras na maioria das vezes como
trata objetos geom@'{e}tricos.  Por exemplo, voc@^{e} pode mover c@^{a}meras pelas proximidades
e adicion@'{a}-las e apag@'{a}-las como objetos geom@'{e}tricos.  C@^{a}meras n@~{a}o
s@~{a}o mostradas na tela como um objeto que voc@^{e} v@^{e}.  Cada
c@^{a}mera tem uma janela de c@^{a}mera separada que mostra a vis@~{a}o como vista atrav@'{e}s da lente
daquela c@^{a}mera.  (@'{E} pass@'{i}vel para cada c@^{a}mera mostrar uma representa@,{c}@~{a}o
geom@'{e}trica de outras c@^{a}meras.  Veja @ref{Cameras}.)

Devido ao fato de Geomview tratar c@^{a}meras e objetos geom@'{e}tricos muito similarmente,
o termo @dfn{objeto} nessa documenta@,{c}@~{a}o @'{e} usado para referir-se a qualquer dos dois
indistintamente.  Quando precisamos disting@"{u}ir entre os dois tipos de objetos, usamos
o termo "@dfn{geom}" para denotar um objeto geom@'{e}trico e a palavra
@dfn{c@^{a}mera} para denotar uma c@^{a}mera.

O objeto que est@'{a} selecionado (luminosidade alta) no navegador
"@emph{Targets}" @'{e} chamado objeto alvo.  Esse @'{e} o objeto que
recebe quaisquer a@,{c}@~{o}es que voc@^{e} faz com o mouse ou com o teclado.  Voc@^{e} pode
mudar o objeto alvo selecionando uma linha diferente no
navegador de alvos (@emph{Targets}).  Outro caminho de modificar o objeto alvo @'{e}
colocar o cursor do mouse diretamente sobre um geom na janela de c@^{a}mera
e rapidamente dar um duplo clique no bot@~{a}o direito do mouse.  Esse processo @'{e} chamado
@dfn{selecionar}; o objeto selecionado torna-se o novo alvo.

Objetos do Geomview s@~{a}o todos conhecidos por dois nomes, ambos dos quais s@~{a}o mostrados no
navegador de alvos (@emph{Targets}).  O primeiro nome l@'{a} fornecido, que aparece
entre colch@^{e}tes ([ ]), @'{e} um nome curto atribuido pelo Geomview quando voc@^{e}
chama o objeto.  Esse nome consiste da letra `g' para geometria e da letra `c' para
c@^{a}meras, seguindo por um n@'{u}mero.  O segundo nome @'{e} maior e mais
descritivo; por padr@~{a}o esse @'{e} o nome do arquivo do qual o
objeto foi chamado.  Os dois nomes s@~{a}o equivalentes at@'{e} no que diz respeito ao
Geomview; em qualquer ponto onde voc@^{e} precisar especificar um nome voc@^{e} pode fornecer
qualquer dos dois.

Para manipular um objeto, esteja certo de que aquele objeto que voc@^{e} quer mover seja o
objeto alvo, e coloque o cursor do mouse em uma janela de c@^{a}mera.  Movimentos s@~{a}o
aplicados pressionando ou o bot@~{a}o esquerdo ou o bot@~{a}o do meio do mouse e
movendo o mouse.  Existem muitos modos de movimento diferentes, cada modo de movimento
aplicando um diferente tipo de movimento.  O navegador de modos de movimento (@emph{MOTION MODE})
no painel principal indica o modo de movimento atual.  O
padr@~{a}o @'{e} a rota@,{c}@~{a}o ("Rotate").  Voc@^{e} pode mudar o modo corrente de movimento
selecionando um no modo de movimento no navegador de modos de movimento (@emph{MOTION MODE}), ou usando o
painel de ferramentas (@emph{Tools}).  Para maiores informa@,{c}@~{o}es sobre modos de movimento,
veja @ref{Mouse Motions}.

O navegador de m@'{o}dulos (@emph{Modules}) lista m@'{o}dulos externos do Geomview.  Um
m@'{o}dulo externo @'{e} um programa separado que interage com Geomview para
extender suas funcionalidades.  Para informa@,{c}@~{o}es sobre m@'{o}dulos externos,
veja @ref{Modules}.

@ifset forms
O bot@~{a}o @emph{Load} no painel principal @emph{Main} faz surgir o
painel de arquivos (@emph{Files}) para chmar um arquivo.  O arquivo pode conter ou um
geom, ou uma c@^{a}mera, ou comandos GCL.  Para detalhes, veja @ref{Loading}.

O bot@~{a}o @emph{Delete} faz com que o objeto
alvo seja apagado.  Geomview seleciona outro objeto para ser o novo
alvo.  Voc@^{e} pode apagar c@^{a}meras da mesma forma que geoms dessa forma.  Se voc@^{e}
pressionar o bot@~{a}o delete @emph{Delete} enquanto o objeto alvo for "World",
Geomview aagar@'{a} todos os geoms.

Os tr@^{e}s bot@~{o}es na parte de baixo do painel principal (@emph{Main}), rotulados
@emph{Euclidean}, @emph{Hyperbolic}, e @emph{Spherical}, permitem
a voc@^{e} modificar a geometria do espa@,{c}o que Geomview mostra.  Por
padr@~{a}o @emph{Euclidean} @'{e} selecionado.  Para detalhes sobre como usar
espa@,{c}os @emph{Hyperbolic} e @emph{Spherical}, veja @ref{Non-Euclidean
Geometry}.
@end ifset

@ifclear forms
A barra de menu no topo do painel principal oferece menus para opera@,{c}@~{o}es comuns.

Para criar novas janelas, chame novos objetos, grave os objetos ou outras informa@,{c}@~{o}es,
ou saia do geomview, veja o menu @emph{File}.  

Para copiar ou apagar objetos, veja o menu @emph{Edit}.

Voc@^{e} pode chamar qualquer painel a partir do menu @emph{Inspect}.

O menu @emph{Space} permite a voc@^{e} escolher se geomview trabalha
no modo Euclidiano, Hiperbolico ou Esf@'{e}rico.  O modo Euclideano @'{e} usado
por padr@~{a}o.  Para detalhes sobre a utiliza@,{c}@~{a}o do modo espa@,{c}o @emph{Hyperbolic} e do modo
@emph{Spherical}, veja @ref{Non-Euclidean Geometry}.
@end ifclear

A maioria das a@,{c}@~{o}es que voc@^{e} pode fazer atrav@'{e}s dos pain@'{e}is do Geomview possuem equivalentes
atalhos de teclado de forma que voc@^{e} pode fazer a mesma a@,{c}@~{a}o atav@'{e}s de digita@,{c}@~{a}o de uma
seq@"{u}@^{e}ncia de teclas no teclado.  Isso @'{e} @'{u}til para usu@'{a}rios avan@,{c}ados que
est@~{a}o familiarizados com as capacidades do Geomview e querem trabalhar rapidamente
sem ter montanhas de pain@'{e}is amontoando-se na tela.
Atalhos de teclado s@~{a}o usualmente indicados ente colch@^{e}tes ([ ]) pr@'{o}ximo
ao item correspondente em um apinel.  Por exemplo, o atalho de teclado
para o modo @emph{Rotate} @'{e} 'r'; isso @'{e} indicado par "[r]" que aparece
antes da palavra "Rotate" no navegador @emph{MOTION MODE}.  Para
usar esse atalaho de teclado, apenas pressione a tecla @kbd{r} enquanto o cursor do
mouse estiver em qualquer janela  do Geomview.  N@~{a}o @'{e} necess@'{a}rio pressionar a tecla @kbd{@key{Enter}}
posteriormente.

Alguns atalhos de teclado consistem em mais de uma tecla.  Nesses caso
apenas digite as teclas uma ap@'{o}s a outra, sem pressionar @kbd{@key{Enter}}
posteriormente ou entre as teclas pressionadas.  Atalhos de teclado s@~{a}o sens@'{i}veis @`{a} caixa alta/baixa.

Muitas teclas de atalho podem ser precedidas de um par@^{a}metro num@'{e}rico.
Por exemplo, digitando @code{ae} muda o estado do desenho de arestas,
enquanto @code{1ae} sempre habilita o desenho de arestas.

O campo @emph{keyboard} no canto superior esquerdo do painel principal
(@emph{Main}), imediatamente acima da palavra "Targets", ecoa o estado atual das teclas de atalho.

@ifset forms
O bot@~{a}o rotulado @emph{?} pr@'{o}ximo ao canto superior direito do
painel principal (@emph{Main}) faz com que Geomview mostre uma lista de todos os atalhos de
teclado na sa@'{i}da padr@~{a}o.

O bot@~{a}o @emph{Quit} no painel principal encerra o Geomview.
@end ifset
@ifclear forms
Para uma lista de todas as teclas de atalho, pressione a telca @emph{@code{?}}.
@end ifclear


@comment ================================================================
@node Loading, Mouse Motions, Basic Interaction, Interaction
@section Loading Objects Into Geomview

Existem muitos caminhos para chamar um objeto dentro do Geomview.

@table @asis
@item No painel de arquivos (@emph{Files})
Se voc@^{e} clicar no bot@~{a}o @emph{Load} no painel principal do Geomview (@emph{Main}),
o painel de arquivos (@emph{Files}) ir@'{a} aparecer. 

@float Figure,figmyfilelist
@image{figs/myfilelist}
@caption{O Painel de Arquivos.}
@end float
Esse painel permite que voc@^{e} selecione um arquivo a partir de uma variedade de diret@'{o}rios.
O topo do painel @'{e} um navegador de arquivos padr@~{a}o do Motif.  Abaixo deste est@'{a}
uma lista de diret@'{o}rios no caminho de busca padr@~{a}o do Geomview; clique sobre um
desses para navegar entre os arquivos naquele diret@'{o}rio.

Para selecionar um arquivo, duplo-clique sobre o seu nome no navegador no canto superior direito,
ou clique sobre o seu nome e pressione a tecla @key{Enter}, ou ainda digite o nome do arquivo
dentro da caixa de texto na parte inferior do navegador e pressione a tecla @key{Enter}.
@refill

Se o arquivo selecionado contiver dados geom@'{e}tricos OOGL, esse arquivo ir@'{a} ser adicionado ao
navegador de alvos (@emph{Targets}) do geomview.  Se esse arquivo contiver comandos GCL em lugar de conter dados geom@'{e}tricos OOGL,
o arquivo ser@'{a} interpretado. Veja @ref{GCL}.

Quando o apinel de arquivos (@emph{Files}) aparecer pela primeira vez, o diret@'{o}rio selecionado no
navegador de diret@'{o}rios @'{e} o diret@'{o}rio atual --- que corresponde ao diret@'{o}rio a partir do qual voc@^{e}
chamou o Geomview.  O navegador de arquivos mostra @emph{todos} os arquivos nesse
diret@'{o}rio, incluindo os que n@~{a}o s@~{a}o arquivos do Geomview.  Se voc@^{e} tentar
chamar u arquivo que n@~{a}o contenha nem um objeto OOGL nem comandos do
Geomview, o Geomview ir@'{a} mostrar uma mensagem de errp.

O navegador de diret@'{o}rios tamb@'{e}m lista um segundo e um terceiro diret@'{o}rios
adicionalmente al@'{e}m do diret@'{o}rio atual.  O segundo, que termina em
@file{data/geom}, @'{e} o diret@'{o}rio de exemplos de dados do Geomview.  Esse diret@'{o}rio cont@'{e}m
uma grande variedade de amostras de objetos.  Esse diret@'{o}rio tamb@'{e}m cont@'{e}m muitos
subdiret@'{o}rios.  Em particular, os subdiret@'{o}rios @file{hyperbolic} e o
subdiret@'{o}rio @file{spherical} possuem amostras de objetos hiperb@'{o}licos
e esf@'{e}ricos, respectivamente.  Entradas no navegador de diret@'{o}rios s@~{a}o vistas apenas como
entradas de arquivos; para visualizar um subdiret@'{o}rio, clique sobre o nome do referido diret@'{o}rio.

O terceiro diret@'{o}rio mostrado mostrado no navegador de diret@'{o}rio, que termina em
@file{geom}, cont@'{e}m muitos subdiret@'{o}rios com outros arquivos do Geomview
dentro deles.  Esses arquivos s@~{a}o usados menos freq@"{u}@^{e}ntemente que os outros no
diret@'{o}rio @file{data/geom}.

Voc@^{e} pode mudar a lista de diret@'{o}rios mostra no navegador de diret@'{o}rios
do painel de arquivos (@emph{Files}) usando o comando @code{set-load-path};
Veja @ref{set-load-path, @code{(set-load-path @dots{})}}.

@item a tecla de atalho @kbd{<}:
Se voc@^{e} digitar @kbd{<} em qualquer janela do Geomview, o painel @emph{Load} ir@'{a}
aparecer.  Esse painel @'{e} uma pequena vers@~{a}o do painel de arquivos (@emph{Files}); o painel @emph{Load} cont@'{e}m
um campo de texto no qual voc@^{e} o nome de um arquivo a ser chamado (ou um
comando GCL entre par@^{e}ntesis).  Ap@'{o}s digitar o nome do arquivo
a ser chamado, aperte a tecla @kbd{@key{Enter}}; Geomview ir@'{a}
chamar o arquivo como se voc@^{e} o tivesse chamado com o bot@~{a}o @emph{Add} no
painel de arquivos (@emph{Files}).  Se, ap@'{o}s fazer surgir o pequeno painel @emph{Load}
com @kbd{<}, voc@^{e} decidir que quer usar o grande painel de arquivos (@emph{Files})
ap@'{o}s tudo, pressione o bot@~{a}o @emph{File Browser}.
@float Figure,figloadpanel
@image{figs/load}
@caption{O Painel de Chamar Arquivos.}
@end float

@item comandos para chamar objetos geom@'{e}tricos:
Os comandos GCL @code{load}, @code{geometry}, @code{new-geometry},
e @code{read} permitem a voc@^{e} chamar um objeto dentro do Geomview;
veja @ref{GCL}. Veja @ref{load, @code{(load @dots{})}}. Veja @ref{new-geometry,
@code{(new-geometry @dots{})}}. Veja @ref{read, @code{(read @dots{})}}.
@refill

@end table

@comment ================================================================
@node Mouse Motions, Appearance, Loading, Interaction
@section Using the Mouse to Manipulate Objects

Geomview permite a voc@^{e} manipular objetos com o mouse.  Existem seis
diferentes modos de movimento do mouse: rota@,{c}@~{a}o (@emph{Rotate}), transla@,{c}@~{a}o (@emph{Translate}),
v@^{o}o da c@^{a}mera (@emph{Cam Fly}), zoom da c@^{a}mera (@emph{Cam Zoom}), homotetia de um objeto geom@'{e}trico (@emph{Geom Scale}), e
@'{o}rbita de c@^{a}mera (@emph{Cam Orbit}).  O painel de ferramentas tem um bot@~{a}o para cada um desses
modos; para tracar os modos, clique sobre o bot@~{a}o correspondente.  voc@^{e} pode tamb@'{e}m
selecionar um modo atrav@'{e}s do navegador de modos de movimento (@emph{Motion Mode}) no
painel principal (@emph{Main}).@refill

Essa se@,{c}@~{a}o descreve a intera@,{c}@~{a}o b@'{a}sica com o mouse.  Para detalhes,
veja @ref{Commands}.

@float Figure,figtools
@image{figs/tools}
@caption{O Painel de Ferramentas.}
@end float

Cada um dos modos de movimento usa um paradigma comum para como o movimento @'{e}
aplicado.  Em particular, cada modo de movimento depende do objeto alvo (@emph{target})
atual e do atual objeto do centro (@emph{center}.  O obejto alvo atual e o atual objeto do centro s@~{a}o explicados
nos par@'{a}grafos seguintes.

O objeto alvo atual @'{e} mostrado no campo @emph{Target} no
painel de ferramentas (@emph{Tools}).  Isso @'{e} o mesmo que o objeto selecionado no
navegador de alvos (@emph{Targets}) no painel principal (@emph{Main}), e voc@^{e} pode
mudar o alvo ou selecionando um novo objeto no navegador, digitando
uma nova entrada no campo, ou selecionando um objeto na janela
de c@^{a}mera duplo-clicando no bot@~{a}o direito do mouse com o cursor sobre
o objeto.

O atual objeto do centro @'{e} mostrado no campo @emph{Center} no
painel de ferramentas(@emph{Tools}).  Seu valor padr@~{a}o @'{e} a palavra especial "target",
que significa que o odbjeto do centro @'{e} o objeto que estiver designado como objeto alvo.
Voc@^{e} pode mudar o objeto atual do centro para qualquer objeto digitando seu nome no campo
@emph{Center}.  A or@'{i}gem do objeto do centro @'{e} mantido fixo no modo rota@,{c}@~{a}o @emph{Rotate} e
no modo @emph{Orbit}.  Normalmente o objeto do centro @'{e} um dos objetos geom@'{e}tricos
(geoms) existentes listados no navegador de alvos (@emph{Targets}), o centro atual das
rota@,{c}@~{o}es @'{e} a or@'{i}gem daquele sistema de coordenadas daquele objeto.
@'{E} poss@'{i}vel, todavia, selecionar um ponto arbitr@'{a}rio de interesse sobre
um objeto como o centro. Para detalhes, veja @ref{Point of Interest}.

Isso tamb@'{e}m @'{e} poss@'{i}vel mudando o bot@~{a}o @emph{BBox Center} para escolher o
centro de movimento como sendo o centro do objeto atual da caixa
associada. Uma vez modificado o centro da caixa geom@'{e}trica ativa associada ir@'{a} tornar-se
o centro do movimento, se voc@^{e} selecionar outro objeto, ent@~{a}o o centro do
movimento ir@'{a} tornar-se o centro da caixa associada @`{a} aquele objeto. Nada modifica@,{c}@~{a}o
ocorrer@'{a} quando uma c@^{a}mera ou o mundo (@emph{World}) for selecionado, voc@^{e} tem que
digitar a palavra @code{target} no campo @emph{Center} para retornar ao
valor padr@~{a}o.

Voc@^{e} aplica um movimento de mouse pressionando ou o bot@~{a}o esquerdo ou o bot@~{a}o do meio
do mouse com o cursor em uma janela de c@^{a}mera e movendo o mouse.  A maioria dos
modos de movimento possui in@'{e}rcia (@emph{inertia}), que significa que se voc@^{e} soltar o
bot@~{a}o enquanto move o mouse, o movimento ir@'{a} continuar.  Para imaginar a in@'{e}rcia pode ser
@'{u}til imaginar o cursor do mouse como sendo uma al@,{c}a; quando voc@^{e} pressiona um
bot@~{a}o do mouse para baixo, o mouse agarra firmemente no objeto alvo e voc@^{e} pode mover esse objeto.  Quando
voc@^{e} libera o bot@~{a}o do mouse, a al@,{c}a libera o objeto.
Liberando o bot@~{a}o do mouse enquanto move o mesmo @'{e} como abandonar
o objeto --- o objeto continua movendo-se independentemente do mouse.
In@'{e}rcia pode ser desligada; veja o menu de movimento (@emph{Motion}) no painel principal (@emph{Main}),
descrito abaixo.

Generally, the bot@~{a}o esquerdo do mouse controla movimento no plano da tela,
enquanto o bot@~{a}o m@'{e}dio do mouse controla movimento ao longo ou em torno da dire@,{c}@~{a}o de avan@,{c}o.

Pressionando o tecla "shift" enquanto arrasta com o bot@~{a}o esquerdo ou m@'{e}dio do mouse
na maioria dos modos de movimento fornece movimentos de baixa velocidade , @'{u}til para ajustes finos.

Voc@^{e} pode selecionar qualquer ponto sobre um objeto (n@~{a}o apenas sua or@'{i}gem) como centro do
movimento pressionando a tecla "shift" enquanto clica no bot@~{a}o direito do mouse;
isso escolhe o ponto de interesse.

@table @emph

@item Rotate
No modo rota@,{c}@~{a}o (@emph{Rotate}), pressione o bot@~{a}o esquerdo do mouse para rotacionar o
objeto alvo en torno do objeto do centro.  A rota@,{c}@~{a}o ocorre na
dire@,{c}@~{a}o que voc@^{e} move o mouse.  Especificamente, o eixo de rota@,{c}@~{a}o
passa atrav@'{e}s da or@'{i}gem do objeto do centro, @'{e} paralelo ao
plano de vis@~{a}o da c@^{a}mera, e @'{e} perpendicular @`{a} dire@,{c}@~{a}o do movimento do
mouse.  Quando o centro for o alvo ("target"), isso significa que o objeto
alvo rotaciona em torno de sua pr@'{o}pria or@'{i}gem.

O bot@~{a} do meio do mouse no modo de movimento tipo rota@,{c}@~{a}o (@emph{Rotate}) rotaciona o objeto
alvo em torno de um eixo perpendicular ao plano de vis@~{a}o.

@item Translate
No modo transla@,{c}@~{a}o (@emph{Translate}), mantenha pressionado o bot@~{a}o esquerdo do mouse para transladar
o objeto alvo na dire@,{c}@~{a}o do movimento do mouse.  O bot@~{a}o do meio do
mouse translada o alvo ao longo de um eixo perpendicular ao plano de
visualiza@,{c}@~{a}o.

No espa@,{c}o Euclideano, o objeto do centro @'{e} essencialmente irrelevante para
transla@,{c}@~{o}es.  Nos espa@,{c}os hiperb@'{o}licos e esf@'{e}ricos, onde transla@,{c}@~{o}es
possuem um @'{u}nico eixo, esse eixo @'{e} escolhido para ir atrav@'{e}s da or@'{i}gem do
objeto do centro.

@item Cam Fly
O V@^{o}o de C@^{a}mera (@emph{Cam Fly}) @'{e} um simulador de v@^{o}o muito simples que permite a voc@^{e} voar em torno
da cena.  @emph{Cam Fly} trabalha atrav@'{e}s do movimento da c@^{a}mera.
Movimente o mouse enquanto mant@'{e}m pressionado o bot@~{a}o esquerdo do mouse para
posicionar a c@^{a}mera em uma dire@,{c}@~{a}o diferente.  Para mover adiante ou para tr@'{a}s,
mantenha pressionado o bot@~{a} do meio e mova o mouse verticalmente.  Os dois movimentos
aqui descritos possuem in@'{e}rcia; tipicamente o caminho mais f@'{a}cil para voar em torno de uma
cena @'{e} fornecer a c@^{a}mera um passo adiante pressionando o
bot@~{a} do meio enquanto move-se o mouse para cima, e ent@~{a}o usar o bot@~{a}o
esquerdo para pilotar.

@emph{Cam Fly} afeta a janela de c@^{a}mera onde o mouse est@'{a} correntemente posicionado; @emph{Cam Fly}
ignora o objeto alvo e o objeto do centro.

@item Cam Orbit
O modo Órbita de C@^{a}mera (@emph{Cam Orbit}) permite a voc@^{e} rotacionar a c@^{a}mera atual c@^{a}mera em torno do
centro atual. O bot@~{a}o esquerdo do mouse faz essa rota@,{c}@~{a}o.  O bot@~{a}o do
do meio do mouse no modo @emph{Cam Orbit} atua da mesma forma que no
modo @emph{Cam Fly}: O bot@~{a}o do do meio do mouse move a c@^{a}mera para adiante e para tr@'{a}s.

Em geral @emph{Cam Orbit} n@~{a}o move o objeto alvo, embora
se a c@^{a}mera atual for selecionada como o alvo e o centro for tamb@'{e}m
o alvo, @emph{Cam Orbit} ir@'{a} apenas pivotar aquela c@^{a}mera sobre s@'{i} mesma como no
modo @emph{Cam Fly}.

@item Cam Zoom
O modo Zoom de C@^{a}mera (@emph{Cam Zoom}) permite a voc@^{e} modificar o campo atual de
vis@~{a}o com o mouse; mantenha pressionado o bot@~{a}o esquerdo do mouse e mova o mouse
para modificar o campo de vis@~{a}o.  O valor num@'{e}rico do campo de vis@~{a}o @'{e} mostrado no
campo @emph{FOV} (field of view) no painel de c@^{a}mera (@emph{Camera}).

@item Geom Scale
O modo @emph{Geom Scale} permite a voc@^{e} ampliar ou diminuir um objeto geom@'{e}trico (geom).  @emph{Geom Scale} atua
sobre o objeto alvo se aquele objeto for um geom.  Se o alvo for uma
c@^{a}mera, @emph{Geom Scale} atual sobre o geom que foi o objeto alvo
mais recentemente.  Movendo o mouse enquanto mantem-se pressionado o bot@~{a}o esquerdo do mouse
homotetiza-se o objeto ou ampliando ou reduzindo o mesmo, dependendo da dire@,{c}@~{a}o do
movimento do mouse.  o centro da transforma@,{c}@~{a}o homot@'{e}tica aplicada @'{e} o
objeto do centro.

Homotetia possui significado somente no espa@,{c}o Euclideano; tentativas do palicar homotetia s@`{a}o
ignoradas em outros espa@,{c}os.

O modo @emph{Geom Scale} n@~{a}o possui in@'{e}rcia.

@end table

Os bot@~{o}es @emph{Stop}, @emph{Look At}, @emph{Center}, e
@emph{Reset} no painel de ferramentas (@emph{Tools}) executam a@,{c}@~{o}es relacionadas a movimentos
mas n@~{a}o modificam o modo atual de movimento (nota do tradutor: de rota@,{c}@~{a}o para transla@,{c}@~{a}o por exemplo).


@table @emph

@item Stop
O bot@~{a}o @emph{Stop} faz com que cessem todos os movimentos.  O bot@~{a}o @emph{Stop} afeta todos
os objetos em movimento, n@~{a}o apenas o objeto alvo.  Sua tecla de atalho
@'{e} @kbd{H}.

O comando de teclado @kbd{h}, que n@~{a}o corresponde a um
bot@~{a}o do painel, cessa o movimento atual para o objeto alvo somente.

@item Look At
O bot@~{a}o @emph{Look At} faz com que a c@^{a}mera atual seja movida
para uma posi@,{c}@~{a}o tal que a referida c@^{a}mera esteja olhando para o objeto alvo, e de forma
que o objeto alvo mais ou menos ajuste-se @`{a} janela.

O comando @emph{Look At} n@~{a}o funciona perfeitamente em espa@,{c}os n@~{a}o Euclideanos.

@item Center
O bot@~{a}o @emph{Center} desfaz transforma@,{c}@`{a}o do objeto alvo,
movendo o objeto alvo de volta @`{a} sua posi@,{c}@~{a}o inicial padr@~{a}o, que @'{e} onde ele estava quando voc@^{e}
originalmente o chamou a partir do Geomview.

@item Reset
O bot@~{a}o @emph{Reset} cessa todo movimento e faz com que todos os objetos sejam
movidos de vota @`{a}s suas posi@,{c}@~{o}es iniciais padr@~{a}o.

@end table

O painel de ferramentas (@emph{Tools}) possui um bot@~{a}o @emph{Main}, para invocar o
painel principal no caso de esse painel tiver sido dispensado ou sepultado, e um bot@~{a}o @emph{Done}
para fechar o painel de ferramentas @emph{Tools}.

O painel principal do menu de movimento (@emph{Motion}) tem controles especiais
que afetam como movimentos do mouse s@~{a}o interpretados; as modifica@,{c}@~{o}es s@~{a}o tamb@'{e}m
acess@'{i}veis atrav@'{e}s de comandos GCL. @xref{ui-motion, @code{(ui-motion
@dots{})}}.

@table @emph

@item [ui] Inertia
Normalmente, ao mover objetos tem-se in@'{e}rcia: se o mouse estiver ainda se movendo
quando o bot@~{a}o for liberado, o objeto selecionado continua a mover-se.
Quando a in@'{e}rcia (@emph{Inertia}) for desabilitada, objetos cessam se movimento no momento em que voc@^{e} libera
o mouse.

@item [uc] Constrain Motion
@'{E} necess@'{a}rio algumas vezes ter ao alcance da m@~{a}o o movimento de um objeto em uma dire@,{c}@~{a}o alinhada com um
eixo coordenado: exatamente na horizontal ou na vertical.  Selecionando
restringir movimento (@emph{Constrain Motion}) a interpreta@,{c}@~{a}o de movimentos do mouse @'{e} modificada
para permitir isso; arrastros de mouse aproximadamente horizontais ou aproximadamente verticais
transformam-se em movimentos exatamente horizontais ou exatamente verticais.  Note que o movimento @'{e}
ainda ao longo dos eixos X ou Y da c@^{a}mera na qual voc@^{e} move o mouse,
n@~{a}o necess@'{a}riamente no sistema de coordenadas do objeto.

@item [uo] Own Coordinates
@'{E} necess@'{a}rio algumas vezes ter ao alcance da m@~{a}o o movimento de objetos objetos com rela@,{c}@~{a}o ao sistema de coordenadas
onde o referido objeto foi definido, em lugar de com rela@,{c}@~{a}o ao sistema de coordenadas da c@^{a}mera atrav@'{e}s da qual esse objeto est@'{a} sendo visto.  Enquanto
@emph{Own Coordinates} estiver selecionado, todos os movimentos s@~{a}o interpretados da forma citada nesse item:
arrastando o mouse para a diretia no modo transla@,{c}@~{a}o corresponde a mover o objeto em sua pr@'{o}pria dire@,{c}@~{a}o
+X, e assim por diante.  Pode ser especialmente @'{u}til conjuntamente com
o bot@~{a}o Restringir Movimento (@emph{Constrain Motion}).

@end table

@comment ================================================================
@menu
* Point of Interest::           Pontos de Interesse.
@end menu

@node Point of Interest,  , Mouse Motions, Mouse Motions
@subsection Selecting a Point of Interest

@'{E} algumas vezes @'{u}til especificar um ponto em particular sobre algum objeto em uma
janela do window como o ponto de centro para movimentos do mouse.  Voc@^{e} pode fazer isso
segurando a tecla shift e clicando o bot@~{a}o direito do mouse (i.e. clique no bot@~{a}o direito uma vez
enquanto mant@'{e}m pressionada a tecla shift do teclado) com o cursor sobre
o ponto desejado.  Esse ponto torna-se ent@~{a}o o @emph{ponto de
interesse}.  O ponto de interesse deve estar sobre um objeto existente.

Selecionado um ponto de interesse simplifica o exame de uma pequena por@,{c}@~{a}o de um
grande objeto.  Mantendo a tecla shift pressionada e clicando sobre o ponto de interesse com o bot@`{a}o direito do mouse, e seleccionando
o modo @'{o}rbita (@emph{Orbit}).  Use o bot@~{a} do meio do mouse para aproximar, e o
esquerdo para orbitar o ponto, examinando a regi@~{a}o de diferentes
dire@,{c}@~{o}es.

Quando voc@^{e} tiver selecionado um ponto de interesse, o atual objeto do centro
@'{e} modificado para um objeto chamado "CENTER", que @'{e} um objeto invis@'{i}vel
localizado no ponto de interesse.  Adicionalmente, movimentos de mouse para a
janela na qual voc@^{e} fez a sele@,{c}@~{a}o s@~{a}o ajustados de forma que o ponto de
interesse acompanhe o mouse.

Voc@^{e} pode mudar o ponto de interesse a qualqeur momento selecionando um novo ponto de interesse
shift-clicando o bot@~{a}o direito do mouse novamente.  Voc@^{e} pode cancelar
o ponto de interesse completamente shift-clicando o bot@~{a}o
direito do mouse com o cursor no plano de fundo (i.e. n@~{a}o sobre qualquer objeto).
Isso modifica o objeto do centro de volta a seu valor padr@~{a}o, "target".

O objeto que possui o nome de "CENTER", que serve como um objeto do centro para o
ponto de interesse, @'{e} um tipo especial de geom chamado "alien".  Esse "Alien"
n@~{a}o aparece no navegador de alvos (@emph{Targets}).  Por padr@~{a}o esse objeto "Alien" n@~{a}o tem geometria
associada e concequ@"{u}@^{e}ntemente @'{e} invis@'{i}vel.  Voc@^{e} pode, Todavia, explicitamente
fornecer ao Alien alguma geometria usando um comando GCL, fazendo com que o Alien aparece no navegador de alvos.  Use
o comando @code{geometry} para fazer isso: @code{(geometry CENTER
@var{geometry})}, onde @var{geometry} @'{e} qualquer geometria v@'{a}lida.  Por
exemplo, @code{(geometry CENTER @{ < xyz.vect @})} faz com que o arquivo
@file{xyz.vect}, que @'{e} um dos arquivos de exemplo padronizados distribu@'{i}dos
com geomview, seja usado na geometria para CENTER. Veja @ref{geometry,
@code{(geometry @dots{})}}.


O que acontece internamente quando voc@^{e} seleciona um ponto de interesse @'{e}
que o contro @'{e} escolhido par o objeto chamado CENTER, e aquele objeto @'{e}
posicionado no ponto de interesse.  Adicionalmente, com o ovjetivo de para movimentos de
mouse rastreiem o ponto de interesse, o atual comprimento focal da
c@^{a}mera @'{e} escolhido para ser a dist@^{a}ncia da c@^{a}mera at@'{e} o ponto de
interesse.  Voc@^{e} pode realizar isso via GCL com os seguintes comandos:
@example
(if (real-id CENTER) nil (new-alien CENTER @{@}))
(ui-center CENTER)
(transform-set CENTER universe universe translate @var{x} @var{y} @var{z})
(merge camera @var{cam-id} @{ focus @var{d} @})
@end example
@noindent
onde @code{(@var{x},@var{y},@var{z})} s@~{a}o as coordenadas (universe)
do ponto de interesse, e @var{d} @'{e} a dist@^{a}ncia daquele ponto @`{a}
atual c@^{a}mera, @var{cam-id}.  O primeiro comando acima cria o
"alien" CENTER se esse Alien n@~{a}o existir ainda.

@comment ================================================================
@node Appearance, Cameras, Mouse Motions, Interaction
@section Changing the Way Things Look

Geomview utiliza uma hierarquia de apar@^{e}ncias para controlar o caminho atrav@'{e}s do qual olha-se coisas.
Uma apar@^{e}ncia (@dfn{appearance}) @'{e} uma especifica@,{c}@~{a}o de informa@,{c}@~{a}o sobre como
alguma coisa pode ser desenhada.  Isso pode incluir muitas caracter@'{i}sticas como
cor, brilho, propriedades do material, etc.  Apar@^{e}ncias trabalham de uma
maneira hier@'{a}rquica: se uma certa propriedade de apar@^{e}ncia, por exemplo cor
de face, n@~{a}o for especificada em uma apar@^{e}ncia particular de algum objeto, esse bojeto
@'{e} desenhado usando aquele propriedade de uma hierarquia superior.  Se ambas as
apar@^{e}ncias de hierarquias, a atual e a superior, especificam uma propriedade, a hierarquia atual tem
preced@^{e}ncia a menos que a hierarquia superior n@~{a}o for escolhida para sobrescrev@^{e}-la.

Todo geom no Geomview tem uma apa@^{e}ncia associada.  Existe
tamb@'{e}m uma apar@^{e}ncia associada ao geom do tipo "World", que comporta-se como
hierarquia superior a cada apar@^{e}ncia individual de qualquer geom.  Finalmente, existe uma
apa@^{e}ncia b@'{a}sica global, que @'{e} a hierarquia superior da apar@^{e}ncia "World".

A apar@^{e}ncia b@'{a}sica especifica valores razo@'{a}veis para toda informa@,{c}@~{a}o de
apar@^{e}ncia, e por padr@~{a}o nenhuma outra apar@^{e}ncia especifica
qualquer coisa, o que significa que as apar@^{e}ncias erdam seus valores a apartir da apar@^{e}ncia
b@'{a}sica.  Isso significa que por padr@~{a}o todos os objetos s@~{a}o desenhados usando a
apar@^{e}ncia b@'{a}sica.

Se voc@^{e} modificar uma certa propriedade de apar@^{e}ncia de um geom, aquela propriedade
@'{e} usada na constru@,{c}@~{a}o daquele geom.  A apar@^{e}ncia de hierarquia superior @'{e} usada para quaisquer
propriedades que voc@^{e} n@~{a}o explicitamente escolheu.

Geomview possui tr@^{e}s pain@'{e}is que levam voc@^{e} a modificar apar@^{e}ncias.  

@menu
* Appearance Panel::            Cor etc.
* Materials Panel::             Propriedades do Material da Superf@'{i}cie.
* Lighting Panel::              Par@^{a}metros de Ilumina@,{c}@~{a}o.
@end menu

@comment ----------------------------------------------------------------
@node Appearance Panel, Materials Panel, Appearance, Appearance
@subsection The Appearance Panel

O painel de Apar@^{e}ncia (@emph{Appearance}) leva voc@^{e} a modificar os mais comuns propriedades de
apar@^{e}ncia do objeto alvo.
@float Figure,figap
@image{figs/ap}
@caption{O Painel de Apar@^{e}ncia.}
@end float
Se o alvo for um geom individual, ent@~{a}o modifica@,{c}@~{a}oes que voc@^{e} fizer no
painel de apar@^{e}ncias aplicam-se a apar@^{e}ncia daquele objeto geom@'{e}trico.  Se o alvo for o
"World", ent@~{a}o as modifica@,{c}@~{o}es no painel de apar@^{e}ncias aplicam-se @`{a} apar@^{e}nca do objeto atual
@emph{e} a apar@^{e}ncia de todos os outros objetos individuais.  (Usu@'{a}rios acham que
esse comportamento @'{e} mais desej@'{a}vel que ter as modifica@,{c}@~{o}es somente aplicadas a apar@^{e}ncia do
"World"e.)  Se o alvo for uma c@^{a}mera, ent@~{a}o as modifica@,{c}@~{o}es do painel de apar@^{e}ncia
aplica-se ao geom que ocupou mais recentemente a posi@,{c}@~{a}o de alvo.

Os cinco bot@~{o}es pr@'{o}ximos ao canto superior esquerdo sob a palavra
@emph{Show} (mostrar) controlam que partes do geom alvo s@~{a}o desenhadas.

@table @emph

@item Faces
Esse bot@~{a}o especifica se faces s@~{a}o desenhadas.

@item Edges
Esse bot@~{a}o especifica se arestass s@~{a}o desenhadas.

@item Normals
Esse bot@~{a}o especifica se vetores normais @`{a} superf@'{i}cie s@~{a}o desenhados.

@item BBox
Esse bot@~{a}o especifica se a caixa associada @'{e} desenhada.

@item Vects
Esse bot@~{a}o especifica se objetos VECT s@~{a}o desenhados.  VECTs s@~{a}o um tipo
de objeto OOGL que representa pontos e segmentos de reta em espa@,{c}o tridimencional;
os VECTs s@~{a}o distintos de arestas ou de outros tipos de objetos, e @'{e} desej@'{a}vel
algumas vezes ter controle separado sobre se eles s@~{a}o desenhados.

@end table

Os quatro bot@~{o}es sob @emph{Color} rotulados @emph{Faces}, Arestas (@emph{Edges}),
Normais (@emph{Normals}), e @emph{BBox} permitem a voc@^{e} especificar a cor do
aspecto correspondente de um geom alvo.  Clicando sobre um
deles faz com que apare@,{c}a um painel de escolha de cores.
@float Figure,figcolorchooserpanel
@image{figs/color}
@caption{Painel de Escolha de Cor.}
@end float
Esse painel oferece dois conjuntos de bot@~{o}es deslizantes: H(ue) S(Saturation) V(alue), ou
R(ed) G(reen) B(lue), cada um no intervalo real fechado de 0 a 1.  O quadrado
mostra a cor atual, que @'{e} fornecida numericamente em ambos os sitemas HSV e RGB
nas caixas de texto correspondentes.

No sistema de cores HSV, hue H mostra vermelho em 0, verde em .333, azul em .667,
e volta ao vermelho em 1.0.  Satura@,{c}@~{a}o fornece a fra@,{c}@~{a}o de branco misturada
na cor, de 0 para cinza puro a 1 para a cor pura.  Valor fornece o
brilho, de 0 para preto a 1 para brilho m@'{a}ximo.

Pressionado o bot@~{a}o @emph{RGB} ou o bot@~{a}o @emph{HSV} ao centro do topo do painel alterna
os bot@~{o}es deslizantes para outro sistema de cores.  Voc@^{e} pode ajustar cores ou atrav@'{e}s dos
bot@~{o}es deslizantes, ou atrav@'{e}s de digita@,{c}@~{a}o nas caixas de texto RGB ou HSV.

Clique @emph{OK} para aceitar as cores que voc6e tiver escolhido, ou
@emph{Cancel} para reter as escolhas anteriores de cor.


O navegador @emph{SHADING} permite a voc@^{e} especificar o modelo de tonalidade que
Geomview utilizar@'{a} para desenhar o geom alvo.

@table @emph

@item Constant
Toda face do objeto @'{e} desenhada com uma cor constante que n@~{a}o
depende da localiza@,{c}@~{a}o da face, nem da c@^{a}mera, nem tamb@'{e}m das fontes de luz.
Se o objeto n@~{a}o contiver cores por face ou por v@'{e}rtice, a
cor difusa de apar@^{e}ncia do objeto @'{e} usada.  Se o objeto
contiver cores por face, essas cores ser@~{a}o usadas.  Se o objeto contiver
cores por v@'{e}rtice, cada face @'{e} pintada usando a cor de seu primeiro
v@'{e}rtice.

@item Flat
Cada face do objeto @'{e} desenhadacom uma cor que depende da
localiza@,{c}@~{a}o relaiva da face, da c@^{a}mera, e das fontes de luz.
A cor @'{e} constante ao longo da face mas pode mudar conforme muda a face,
a c@^{a}mera, ou o movimento das luzes.

@item Smooth
Cada face do objeto @'{e} desenhada com cores lisamente interpoladas baseadas
nos vetores normais em cada v@'{e}rtice.  Se o objeto n@~{a}o contiver
normais por v@'{e}rtice, "Smooth" tem o mesmo efeito que o modo de tonalidade "Flat".  Se o
objeto tiver normais por v@'{e}rtice raso@'{a}veis, o efeito @'{e} alisamento
sobre as arestas e entre as faces.

@item CSmooth
Cada face do objeto @'{e} desenhada com as cores exatamente especificada(s),
independente de ilumina@,{c}@~{a}o, orienta@,{c}@~{a}o, e porpriedades de material.  Se o
objeto for definido com cores por v@'{e}rtice, as cores ser@~{a}o interpoladas
lisamente ao longo da face; de outra forma o efieto @'{e} o mesmo que ocorre no
estilo de tonalidade "Constant".

@end table

O bot@~{a}o @emph{Facing Normals} no painel de apar@^{e}ncia (@emph{Appearance})
indica se indicates se Geomview pode arranjar aqueles vetores normais ou se n@~{a}o pode
sempre conforme a visualiza@,{c}@~{a}o.  Se um vetor normal direciona-se afastando-se do visualizador
a cor da face correspondente ou v@'{e}rtice correspondente usualmente @'{e} mais forte do que @'{e}
desejado.  Geomview pode evitar isso atrav@'{e}s do uso da normal oposta em
c@'{a}lculos de tonalidade.  Esse comportametno @'{e} o padr@~{a}o.  Usando @emph{Facing Normals}
podemos fornecer estranha suavidade pesada ou estranhos efeitos de tonalidade de luz, embora, proximo
ao horizonte de um objet distantemente liso facetado.
Pressione esse bot@~{a}o para usar as normais fornecidas com o objeto.


Os tr@^{e}s campos no canto inferior esquerdo no canto inferior esquerdo do painel de apar@^{e}ncia
(@emph{Appearance}) s@~{a}o:

@table @emph

@item Line Width
A espessura, em pixels, para linhas desenhadas pelo Geomview.

@item Normal Length
Isso @'{e} atualmente um fator de homotetia; quando vetores normais forem desenhados, Geomview
desenha-os de forma que tenham um comprimento que @'{e} seu comprimento natural vezes esse
n@'{u}mero.

@item Patch Dicing
Geomview desenha retalhos de Bezier primeiro convertendo-so em malhas.  Esse
par6ametro especifica a resolu@,{c}@~{a}o da malha: se @emph{Patch Dicing}
for @var{n}, ent@~{a}o uma malha @var{n} por @var{n} @'{e} usada para desenhar cada retalho de
Bezier.  Se @emph{Patch Dicing} for 1, a resolu@,{c}@~{a}o reverte-se para um
valor padr@~{a}o interno.

@end table

O bot@~{a}o @emph{Revert} no painel de apar@^{e}ncia (@emph{Appearance}) desfaz todas
as escolhas na apar@^{e}ncia do alvo.  Isso faz com que o geom alvo
herde todas as suas propriedades de apar@^{e}ncia de seus pais.

O bot@~{a}o do painel de apar@^{e}ncia (@emph{Appearance}) determina se
controles de apar@^{e}ncia devem sobrescrever escolhas feitas nos objetos em si mesmos --
por exemplos, escolhendo a cor de face ir@'{a} afetar todas as faces de objetos com
faces multicoloridas.  De outra forma, controles de apar@^{e}ncia somente fornecem escolhas
que n@~{a}o forem especificadas nos objetos em si mesmos n@~{a}o especificarem.
Por padr@~{a}o, @emph{Override} est@'{a} habilitado.  Esse bot@~{a}o aplica-se a todos os objetos,
e a todos os pain@'{e}is relacionados a apar@^{e}ncia.

@comment ----------------------------------------------------------------
@node Materials Panel, Lighting Panel, Appearance Panel, Appearance
@subsection The Materials Panel

O painel de materiais (@emph{Materials}) controla as propriedades materiais das surperf@'{i}cies.
O painel de materiais trabalha com o objeto alvo da mesma forma que o
painel de apar@^{e}ncia (@emph{Appearance}) faz.
@float Figure,figmatpanel
@image{figs/mat}
@caption{O Painel de Materiais.}
@end float

@table @emph

@item Transparent

Esse bot@~{a}o determina se a transpar@^{e}ncia est@'{a} habilitada.  Geomview por si mesmo
n@~{a}o suporta a transpar@^{e}ncia completamente ainda e o funcionando em algumas m@'{a}quinas a transpar@^{e}ncia n@~{a}o
trabalha de forma completa.  (A pe@,{c}a omitida @'{e} implementa@,{c}@~{a}o de um algor@'{i}timo
intensidade e precis@~{a}o num@'{e}rica no bloco de redenriza@,{c}@~{a}o; n@~{a}o @'{e} dif@'{i}cil, mas @'{e} simplesmente n@~{a}o realizado
ainda.)  Use RenderMan se voc@^{e} quiser transpar@^{e}ncia real: Quando a transpar@^{e}ncia estiver
habilitada, um instant@^{a}neo de RenderMan ir@'{a} conter a informa@,{c}@~{a}o alfa.

@item Alpha
O bot@~{a}o deslizante determina a opacidade/transpar@^{e}ncia quando a transpar@^{e}ncia estiver
habilitada.  0 (zero) significa totalmente transparente, 1 significa totalmente opaco.

@item Diffuse Reflectance
Esse bot@~{a}o deslizante controla a reflect@^{a}ncia difusa de uma superf@'{i}cie.  Isso tem
a ver com o quanto a superf@'{i}cie dispersa a luz que reflete.

@item Shininess
Esse bot@~{a}o deslizante controla o quanto brilhante a superf@'{i}cie @'{e}. Esse bot@~{a}o  determina o
tamanho de destaques especulares sobre a superf@'{i}cie.  Valores pequenos fornecem @`{a}
superf@'{i}cie uma apar@^{e}ncia sombria.

@item Ambient Reflectance
This bot@~{a}o deslizante controla o quanto da luz ambiente uma superf@'{i}cie reflete.

@item Specular Reflectance
Esse bot@~{a}o deslizante controla a reflect@^{a}ncia especular de uma  superf@'{i}cie.  Isso tem
a ver com como a superf@'{i}cie reflete diretamente os raios luminosos.  Valores
maiores fornecem destaques de brilho especular.

@item Done
Esse bot@~{a}o dispensa o painel de materiais (@emph{Materials}).

@end table

@comment ----------------------------------------------------------------
@node Lighting Panel,  , Materials Panel, Appearance
@subsection The Lighting Panel

O painel de ilumina@,{c}@~{a}o (@emph{Lighting}) controla o n@'{u}mero, a posi@,{c}@~{a}o, e a cor das
fontes de luz usadas no sombreamento.
@float
@image{figs/light}
@caption{O Painel de Ilumina@,{c}@~{a}o.}
@end float

O painel de ilumina@,{c}@~{a}o (@emph{Lighting}) @'{e} diferente do painel de apar@^{e}ncia (@emph{Appearance}) e
dos pain@'{e}is de material (@emph{Material}) no sentido de que o painel de ilumina@,{c}@~{a}o sempre trabalha com a apar@^{e}ncia
base.  Isso ocorre pelo fato de fazer sentido usar o mesmo conjunto
de luzes para desenhar todos os objetos na sua cena.

@table @emph

@item LIGHTS
O navegador de luzes (@emph{LIGHTS}) mostra a luz atualmente selecionada.  Modifica@,{c}@~{o}es
s@~{a}o feitas usando os outros meios de escolha sobre esse painel aplicado a essa luz.  Existe
sempre pelo menos uma luz, a luz ambiente.

@item Intensity
Esse bot@~{a}o deslizante controla a intensidade da luz atual.

@item Color
Esse bot@~{a}o faz surgir um modificador de corres que lhe permite selecionar a cor
da luz que atualmente ilumina o objeto.

@item Add
Esse bot@~{a}o adiciona uma luz.

@item Delete
Esse bot@~{a}o exclui a luz atual.

@item Show Lights
Esse bot@~{a}o permite a voc@^{e} ver e modificar a posi@,{c}@~{a}o das fontes de ilumina@,{c}@~{a}o
em uma janela de c@^{a}mera.  Cada luz @'{e} movida ao longo de um cilindro que @'{e}
suposto para lembrar a voc@^{e} um raio de luz.  Quando voc@^{e} clica sobre o bot@~{a}o
@emph{Show Lights} Geomview entra no modo "light edit", durante
o qual voc@^{e} pode rotacionar a ilumina@,{c}@~{a}o atual mantendo pressionado o bot@~{a}o esquerdo do mouse
e movendo o mouse.  Ilumina@,{c}@~{a}o colocada dessa forma est@~{a}o infinitamente distantes,
de forma que o que voc@^{e} est@'{a} modificando @'{e} a posi@,{c}@~{a}o angular.  Clique sobre o bot@~{a}o
@emph{Show Lights} novamente para retornar ao modo anterior de movimento
e para sair movendo os raios de luz.

@item Done
Esse bot@~{a}o dispensa o painel de ilumina@,{c}@~{a}o (@emph{Lighting}).

@end table

Os pain@'{e}is do Geomview @emph{Appearance}, @emph{Materials}, e
@emph{Lighting} s@~{a}o constru@'{i}dos para permitir a voc@^{e} fazer facilmente a maioria das coisas
relacionadas a apar@^{e}ncia que voc@^{e} pode querer fazer.  A hierarquia de apar@^{e}ncia
Geomview suporta internamente, todavia, @'{e} muito complexa e existem
certas opera@,{c}@~{o}es que voc@^{e} n@~{a}o pode fazer com os pain@'{e}is.  A linguagem de comandos
co geomview (GCL) fornece suporte completo a opera@,{c}@~{o}es sobre
apar@^{e}ncia.  Em particular, o comando @code{merge-baseap} pode ser usado
para modificar a apar@^{e}ncia de base (a qual, exceto para ilumina@,{c}@~{a}o, n@~{a}o pode ser
modificada atrav@'{e}s de pain@'{e}is do Geomview).  O comando @code{merge-ap} pode ser usado
para modificar a apar@^{e}ncia de um geom individualmente.  Apar@^{e}ncias podem tamb@'{e}m serem
especificadas nos arquivos OOGL; para detalhes veja,
@ref{Appearances}. @ef{merge-baseap,@code{(merge-baseap
@dots{})}}. @ref{merge-ap,@code{(merge-ap @dots{})}}.


@comment ================================================================
@node Cameras, Saving, Appearance, Interaction
@section Cameras

Uma c@^{a}mera no Geomview @'{e} o objeto que corresponde a uma janela de c@^{a}mera.
Por padr@~{a}o existe somente uma c@^{a}mera, mas @'{e} poss@'{i}vel ter tantas quantas
voc@^{e} quiser.  Voc@^{e} pode controlar certos aspectos do objeto vis@'{i}vel atualmente na janela de c@^{a}mera
arrastando em cada janela de c@^{a}mera via o painel @emph{Cameras}.
@float Figure,figcamerapanel
@image{figs/cam}
@caption{O Painel de C@^{a}mera.}
@end float
Se o objeto alvo for uma c@^{a}mera, o painel de c@^{a}meras (@emph{Cameras}) afeta essa
c@^{a}mera.  Se o objeto alvo n@~{a}o for uma c@^{a}mera, o painel de c@^{a}meras (@emph{Cameras})
afeta a c@^{a}mera atual (@dfn{current camera}).  A c@^{a}mera atual @'{e} a  c@^{a}mera da
janela que o cursor do mouse est@'{a} nela, ou estava mais recentemente se o
cursor n@~{a}o estiver em uma janela de c@^{a}mera.  Dessa forma, se voc@^{e} usa teclas
de atalho para as a@,{c}@~{o}es no painel de c@^{a}meras (@emph{Cameras}) enquanto o cursor
estiver em uma janela de c@^{a}mera, as a@,{c}@~{o}es aplicam-se a aquela  c@^{a}mera, a menos que voc@^{e} tenha
explicitamente selecionado outra c@^{a}mera.

Para criar novas janelas de c@^{a}mera, use a tecla de atalho @kbd{v+},
ou veja o menu arquivo (@emph{File}) no painel principal (@emph{Main}).

@table @emph

@item Single-Buffering
Normalmente, janelas do geomview s@~{a}o armazenadas em @'{a}reas de mem@'{o}ria duplas (@emph{double-buffered}): geomview desenha a
figura seguinte em uma janela escondida, ent@~{a}o alterna as @'{a}reas de mem@'{o}ria para fazer
essa janela completamente vis@'{i}vel em algum momento.  Sobre muitos sistemas operacionais, a mem@'{o}ria para a @'{a}rea de mem@'{o}ria escondida
vem da apropria@,{c}@~{a}o indevida de metade dos bits de cada pixel de tela, reduzindo a resolu@,{c}@~{a}o de
cor.  Quando a op@,{c}@~{a}o @'{a}rea de mem@'{o}ria simples (single-buffering) for habilitada, as pel@'{i}culas de tela de cada
cena est@'{a} sendo desenhada, mas voc@^{e} pode pegar imagens planas com redu@,{c}@~{a}o de granularidade
estremecendo artefatos.  @'{A}rea de mem@'{o}ria simples @'{e} poss@'{i}vel se Geomview for compilado com
GL ou com OpenGL, mas n@~{a}o com gr@'{a}ficos desennhados com recursos @'{u}nicos e exclusivos do X.

@item Dither
Muitos monitores oferecem menos que 24 bits por pixel (8 bits apra cada vermelho, verde,
e azul) convencionalmente suficiente para mostrar grada@,{c}@~{o}es de cor simplesmente.  
Quando tenta mostrar uma cor n@~{a}o acuradamente dispon@'{i}vel no monitor,
Geomview normalmente estremece (@emph{dithers}), modificando as cores do pixel para algumas vezes mais brilhante,
algumas vezes mais escuro que o valor desejado, de forma que a cor dispon@'{i}vel sobre uma @'{a}rea
@'{e} uma melhor aproxima@,{c}@~{a}o para a cor verdadeira que um pixel simples pode ter.
Efetivamente perdas de resolu@,{c}@~{a}o espacial s@~{a}o para ganhar resolu@,{c}@~{a}o de cor.
Esse compartamento n@~{a}o @'{e} sempre desej@'{a}vel, todavia.  Desabilitando @emph{Dither}
fornece menor granularidade, mas a precis@~{a}o de cores @'{e} menor, das imagens.

@item Software Shading
Esse bot@~{a}o controla se Geomview faz c@'{a}lculos de tonalidade via software.
O padr@~{a}o @'{e} permitir que o hardware manseie esses c@'{a}lculos, e no espa@,{c}o Euclideano
esse caminho @'{e} o melhor sempre porque @'{e} o caminho mais r@'{a}pido.  No espa@,{c}o hiperb@'{o}lico e
tamb@'{e}m no espa@,{c}o esf@'{e}rico, todavia, os c@'{a}lculos de tonalidade que o hardware
faz s@~{a}o incorretos.  Clique sobre esse bot@~{a}o para habilitar a forma correta mas lenta
do c@'{a}lculo de tonalidade via software.

@item Background Color
Esse bot@~{a}o faz surgir um modificador de cores que voc@^{e} pode usar para escolher a
cor de fundo da janela da c@^{a}mera.

@item PROJECTION
Esse navegador permite a voc@^{e} selecionar entre proje@,{c}@~{a}o perspectiva ou proje@,{c}@~{a}o ortogr@'{a}fica
para essa c@^{a}mera.

@item Near clip
Essa caixa de texto determina a dist@^{a}ncia nas coordenadas do mundo do pr@'{o}ximo plano de
corte a partir do ponto de vis@~{a}o.  Deve ser um n@'{u}mero positivo.

@item Far clip
Essa caixa de texto determina a dist@^{a}ncia nas coordenadas do mundo do plano de corte
mais distante a partir do ponto de vis@~{a}o.  Deve ser um n@'{u}mero positivo e em geral
deve ser maior que o valor de @emph{Near clip}.

@item FOV
Essa caixa de texto @'{e} o campo de vis@~{a}o da c@^{a}mera, medido em sua menor dire@,{c}@~{a}o.
No modo perspectiva, essa caixa corresponde a um @^{a}ngulo em graus.  No modo ortogr@'{a}fico,
essa caixa de texto corresponde ao tamanho lineardo campo de vis@~{a}o.  Esse n@'{u}mero pode ser modificado
com o mouse no modo @emph{Cam Zoom}.

@item Focal Length
A dist@^{a}ncia focal pretende pretende sugerir a dist@^{a}ncia da c@^{a}mera a
um plano imagin@'{a}rio de interesse.  Seu valor @'{e} usado quando alternamos
entre as visualiza@,{c}@~{o}es ortogr@'{a}fica e perspectiva (e durante visualiza@,{c}@~{a}o stereo),
de forma a preservar o tamanho aparente de objetos sendo desonesto quanto @`{a} dist@^{a}ncia focal
da c@^{a}mera.  Dist@^{a}ncia focal tamb@'{e}m afeta a interpola@,{c}@~{a}o de movimentos de transla@,{c}@~{a}o
efetuados usando o mouse.  A velocidade do movimento para adiante (nos modos transla@,{c}@~{a}o, v@^{o}o e
no modo orbital) @'{e} proporcional @`{a} dist@^{a}ncia focal; e objetos desonestos quanto @`{a}
dist@^{a}ncia focal da c@^{a}mera translacionam lateralmente na mesma raz@~{a}o que
o cursor do mouse.  Finalmente, no modo de proje@,{c}@~{a}o N-Dimencional, c@^{a}meras s@~{a}o substitu@'{i}das
de volta atrav@'{e}s da dist@^{a}ncia focal a partir da proje@,{c}@~{a}o tridimensional a partir da or@'{i}gem do objeto mundo.

@item Lines Closer
Esse n@'{u}mero tem a ver com o caminho pelo qual as linhas s@~{a}o desenhadas.  Normalmente a @'{a}rea de armazenamento tempor@'{a}rio do algor@'{i}tmo que controla as
coordenadas do eixo z do podem confundir-se na hora de desenhar linhas que localizam-se
exatamente sobre superf@'{i}cies (tais como as arestas de um objeto); devido a erros de arredondamento
de m@'{a}quina, algumas vezes as linhas parecem estarem em frente @`{a}
superf@'{i}cie e algumas vezes elas parecem estarem por detr@'{a}s da superf@'{i}cie.  O valor
@emph{Lines Closer} @'{e} um fator de corre@,{c}@~{a}o --- Geomview modifica sutilmente todas as linhas que o algor@'{i}tm da @'{a}rea de armazanamento tempor@'{a}ria desenha
fechando para a c@^{a}mera atrav@'{e}s desse fator.  O n@'{u}mero deve ser um inteiro
pequeno; tente 5 ou 10.  O valor zero (0) desabilita esse recurso completamente.  Escolhendo
valores grandes tornar@'{a} as linhas vis@'{i}veis mesmo quando elas devam ser
escondidas.

@item SPACE MODEL
Essa op@,{c}@~{a}o determina o modelo usado para desenhar o mundo.  @'{E} mais @'{u}til em
espa@,{c}os hiperb@'{o}licos e esf@'{e}ricos.  Voc@^{e} provavelmente n@~{a}o necessitar@'{a} tocar esse
navegador se voc@^{e} permanecer no espa@,{c}o Euclideano.  Para mais informa@,{c}@~{a}o sobre
esses modelos, veja @ref{Non-Euclidean Geometry}.
@table @emph
@item Virtual
Esse @'{e} o modelo padr@~{a}o e representa a visializa@,{c}@~{a}o natural de dentro
do espa@,{c}o.

@item Projective
Corresponde ao modelo projetivo do espa@,{c}o hiperb@'{o}lico e do espa@,{c}o esf@'{e}rico.  Geoms movem-se
obedecendo as isometrias do espa@,{c}o, e c@^{a}meras movem-se atrav@'{e}s de movimentos Euclideanos.
Por padr@~{a}o em modelos projetivos, a esfera unit@'{a}ria Euclidiana @'{e} desenhada.
No espa@,{c}o hiperb@'{o}lico essa esfera localiza-se no infinito.  No espa@,{c}o Euclideano
o modelo projetivo @'{e} o mesmo que o modelo virtual exceto que a
esferea @'{e} desenhada por padr@~{a}o.

@item Conformal
Corresponde ao modelo conformal do espa@,{c}o hiperb@'{o}lico e do espa@,{c}o esf@'{e}rico.  Geoms movem-se obedecendo
as isometrias do espaco, e c@^{a}meras move-se atrav@'{e}s de movimentos Euclideanos.  No
espa@,{c}o Euclidiano, o modelo conformal equivale a inverter tudo na
esfera unit@'{a}ria.
@end table

@item Draw Sphere
Essa op@,{c}@~{a}o controla se Geomview desenha a esfera unit@'{a}ria ou n@~{a}o.  Por padr@~{a}o a
esfera unit@'{a}ria aparece no modelo projetivo e no modelo conformal.  No
espa@,{c}o hiperb@'{o}lico a esfera @'{e} colocada no infinito.  No espa@,{c}o esf@'{e}rico corresponde
@`{a} esfera equatorial.

@item Done
Esse bot@~{a}o dispensa o painel de @emph{Cameras}.

@end table

@comment ================================================================
@node Saving, Commands, Cameras, Interaction
@section Saving your work

O painel @emph{Save} do Geomview permite a voc@^{e} armazenar objetos do Geomview e outra
informa@,{c}@~{a}o em arquivos que voc@^{e} pode recuperar dentro do Geomview ou a partir de outros
programas.
@float Figure,figsavepanel
@image{figs/save}
@caption{O Painel Gravar.}
@end float
Para usar o painel @emph{Save} voc@^{e} seleciona o formato desejado no
navegador perto da palavra @emph{Save}, informe o nome do objeto que voc@^{e}
quer gravar no campo de texto perto da palavra @emph{for}, e informe
o nome do local no qual voc@^{e} deseja gravar o arquivo no campo longo de texto perto
da palavra @emph{in}.  Voc@^{e} pode ou pressionar @kbd{@key{Enter}} ou clicar
sobre o bot@~{a}o @emph{OK}.  Quando o arquivo tiver sido gravado no local desejado, o painel 
@emph{Save} desaparecer@'{a}.  Caso voc@^{e} queira dispensar o painel @emph{Save} sem
gravar um arquivo, clique no bot@~{a}o @emph{Cancel}.

Caso voc@^{e} especifique @file{-} como nome de arquivo, Geomview mostrar gravar o arquivo
a sa@'{i}da padr@~{a}o, i.e. na janela de shell a partir da qual voc@^{e} invocou o
Geomview.

Os poss@'{i}veis formatos s@~{a}o fornecidos abaixo.  O tipo de objeto que pode
ser escrito com cada formato @'{e} fornecido entre par@^{e}ntesis.

@table @emph

@item Commands @asis{(qualquer objeto)}
A op@,{c}@~{a}o "Commands" escreve um arquivo de comandos GCL contendo todas as informa@,{c}@~{o}es sobre
o objeto.  Chamando o arquivo posteriormente ir@'{a} restaurar o objeto bem como
todas as outras informa@,{c}@~{o}es sobre o referido objeto, tais como apar@^{e}ncia, transforma@,{c}@~{o}es,
etc.

@item Geometry alone @asis{(geom)}
A op@,{c}@~{a}o "Geometry alone" escreve um arquivo OOGL contendo apenas a geometria do objeto.

@item Geometry [in world] @asis{(geom)}
A op@,{c}@~{a}o "Geometry [in world]" escreve um arquivo OOGL contendo a geometria do objeto,
transformado sob a transforma@,{c}@~{a}o atual do Geomview para esse objeto.
Use a op@,{c}@~{a}o "Geometry [in world]" caso voc@^{e} tenha movido o objeto de sua posi@,{c}@~{a}o inicial e queira
a nova posi@,{c}@~{a}o em rela@,{c}@~{a}o ao mundo.

@item Geometry [in universe] @asis{(geom)}
A op@,{c}@~{a}o "Geometry [in universe]" grava um arquivo OOGL contendo apenas a geometria do geom,
transformado sob transforma@,{c}@~{o}es sofridas pelo objeto e tamb@'{e}m sob transforma@,{c}@~{o}es sofridas
pelo mundo.

@item RMan [->tiff] @asis{(camera)}
A op@,{c}@~{a}o "RMan [->tiff]" escreve um arquivo que quando for renderizado cria uma im@'{a}gem
tiff. Transpar@^{e}ncia e textura (a mais recente somente at@'{e} certo ponto) estar@'{a}
dispon@'{i}vel.

@item RMan [->frame] @asis{(camera)}
A op@,{c}@~{a}o "RMan [->frame]" escreve um arquivo RenderMan que quando for rederizado faz com que uma imagem apare@,{c}a em
uma janela na tela. Transpar@^{e}ncia e textura (a mais recente somente at@'{e}
certo ponto) estar@'{a} dispon@'{i}vel.

@item SGI snapshot @asis{(camera)}
A op@,{c}@~{a}o "SGI snapshot" escreve um arquivo de varredura SGI.  Uma campainha toca quando o instant@^{a}neo for completado.
Somente dispon@'{i}vel em sistemas SGI.

@item PPM GLX-offscreen snapshot @asis{(camera)}
Renderiza uma cena completa novamente dendo da mem@'{o}ria off-screen; GLX fornece os
meios para usar um Pixmap como @'{a}rea de renderiza@,{c}@~{a}o. A vantagem de renderizar dentro
da mem@'{o}ria @emph{off}-screen em rela@,{c}@~{a}o a pegar um instant@^{a}neo de tela @'{e} que a janela
de c@^{a}mera n@~{a}o precisa ser mapeada e tamb@'{e}m n@~{a}o precisa aparece na hora do intant@^{a}neo @'{e}
realizado. De forma que com o intant@^{a}nei off-screen se pode seguramente colocar a janela de c@^{a}mera don formato
de @'{i}cone (mas n@~{a}o fech@'{a}-la!), ativar a prote@,{c}@~{a}o de tela e ir dormir
enquanto algum script avan@,{c}a as cenas e grava os instant@^{a}neos.

@item PPM Screen snapshot @asis{(camera)}
Grava os instant@^{a}neos a partir da janela fornecida e grava no formato de imagem PPM.
Se voc@^{e} especificar uma seq@"{u}@^{e}ncia de caracteres come@,{c}ando com um barra vertical (@kbd{|})
como nome de arquivo, isso @'{e} interpretado com um ocmando de redirecionmento do shell
para o qual os dados do PPM dever@~{a}o ser canalizados, como em
@samp{| pnmtotiff > snap.tiff} ou em @samp{| convert -geometry 50% ppm:- snap.gif}.

PPM screen snapshots are only available with GL and Open GL, not plain X
graphics.  The window should be entirely on the screen.  Geomview will
ensure that no other windows cover it while the snapshot is taken. It is
probably a better idea to use GLX-@emph{off-screen} snapshots, as
explained above.

@item PPM software snapshot @asis{(camera)}
Writes a snapshot of that window's current view, as a PPM image, to the
given file.  The file name may be a Bourne shell command preceded by a vertical
bar (@kbd{|}), as with the PPM screen snapshot.  The software snapshot, though,
is produced by using a built-in software renderer (related to the X-windows
renderer).  It doesn't matter se the window is visible or not,
and doesn't depend on GL or OpenGL.  It also doesn't support some features,
such as texture mapping.

@item Postscript snapshot @asis{(camera)}
Writes a Postscript snapshot da camera's view.  It's made by
breaking up the scene into lines and polygons, sorting by depth, and
generating Postscript lines and polygons for each one.  Advantages over
pixel-based snapshot images: resolution is very high, so edges
look sharp even on high-resolution printers, or comparable-resolution images
are typically much more compact.  Disadvantages: depth-sorting
gives good results on some scenes, but can be wildly wrong as a hidden-surface
removal algorithm for other scenes.  Also, Postscript doesn't offer
smoothly interpolated shading, only flat shading for each facet.

@item Camera @asis{(camera)}
Writes an OOGL file of a camera.

@item Transform [to world] @asis{(any objeto)}
Writes an OOGL transform file giving Geomview's transform for the objeto.

@item Transform [to universe] @asis{(any objeto)}
Writes an OOGL transform file giving a transform which is the
composition of Geomview's transform for the objeto and the transform for
the world.

@item Window @asis{(camera)}
Writes an OOGL window file for a camera.

@item Panels
Writes a GCL file containing commands which record
the state of all the Geomview panels.  Loading this file later will
restore the positions of all the panels.

@end table

@comment ================================================================
@node Commands, Keyboard Shortcuts, Saving, Interaction
@section The Commands Panel

The @emph{Commands} panel lets you type in a GCL command.  When
you hit @kbd{@key{Enter}}, Geomview interprets the command and prints any
resulting output or error messages on standard output.  You can edit the
text and hit @kbd{@key{Enter}} as many times as you like, in general,
whenever you hit @kbd{@key{Enter}} with the cursor in the @emph{Commands}
panel, Geomview tries to interpret whatever text you have typed in the
text field as a command.
@float Figure,figcommandpanel
@image{figs/command}
@caption{O Painel de Comandos.}
@end float

@ifset forms
The @emph{Obscure} panel is for relatively obscure things that don't
really belong on any dos other panels.  In the present version of
Geomview, the @emph{Obscure} panel includes the @emph{NORMALIZE GEOMETRY}
browser, which controls the kind of geometry normalization that Geomview does,
and several bot@~{o}es affecting movimento style.
@float Figure,figobscurepanel
@image{figs/obscure}
@caption{The Obscure Panel.}
@end float
@end ifset
[Move this.]
Normalization is a kind of scaling; Geomview can scale an objeto so that
it fits within a certain region.  The main point of normalization is to
allow you to easily view all of an objeto without having to worry about
how big it is.  We are gradually replacing Geomview's normalization
feature with more robust c@^{a}mera positioning features.  In general, the
best way to make sure you are seeing all of an objeto is to use the
@emph{Look At} bot@~{a}o on the @emph{Tools} panel.  Normalization may
be completely replaced by this and other features in a future version of
Geomview.

Normalization is a property that applies to each geom separately.  The
@emph{NORMALIZE GEOMETRY} browser affects the normalization property
of target geom.  If the target geom is "World", it affects all geoms.

@table @emph

@item None
Do no normalization.

@item Individual
Normalize this geom to fit within a unit sphere.

@item Sequence
This resembles "Individual", except when an objeto is changing.  Then,
"Individual" tightly fits the bounding box around the objeto whenever it
changes and normalizes accordingly, while "Sequence" normalizes the
union of all variants do objeto and normalizes accordingly.

@item Keep
This leaves the current normalization transform unchanged when the
objeto changes.  It may be useful to apply "Individual" or "Sequence"
normalization to the first version of a changing objeto to bring
it in view, then switch to "Keep".

@end table

@comment ================================================================
@node Keyboard Shortcuts,  , Commands, Interaction
@section Keyboard Shortcuts

Most actions that you can do through Geomview's panels have equivalent
teclas de atalho so that you can do the same action by typing a
sequence of keys on the keyboard.  This is useful for advanced users who
are familiar with Geomview's capabilities and want to work quickly
without having to have lots of panels cluttering up the screen.
Keyboard shortcuts usually are indicated in square brackets ([ ]) near
the corresponding item in a panel.  For example, the tecla de atalho
for @emph{Rotate} mode is 'r'; this is indicated by "[r]" appearing
before the word "Rotate" in the @emph{MOTION MODE} browser.  To
use this tecla de atalho just hit the @kbd{r} key while o mouse
cursor is in any Geomview window.  You don't need to press the @kbd{@key{Enter}}
or @kbd{@key{SPACE}} keys.

Some teclas de atalho consist of more than one key.  In these cases
just type the keys one after the other, with no @kbd{@key{Enter}}
afterwards.  Keyboard shortcuts are case sensitive.  You can cancel a
multi-key tecla de atalho that you have started by typing any invalid
key, for example the space bar.

Keyboard commands apply while the cursor is in any janela de c@^{a}mera and
most control panels.

Many teclas de atalho allow numeric arguments which you type as a
prefix to the command key(s).  For example, the shortcut for
@emph{Near clip} in the c@^{a}mera panel is @kbd{v n}.  To set the near
clip plane to @samp{0.5}, type @kbd{0.5vn}.  Commands that don't take a
numeric prefix toggle or reset the current value.

Most commands allow one dos following selection prefixes.  If none is
provided the command applies to the objeto alvo.

@table @kbd
@item g
world geom	
@item g#
#'th geom
@item g*
All geoms
@item c
current camera
@item c#
#'th camera
@item c*
All c@^{a}meras
@end table

For example, @kbd{g4af} means toggle the face drawing of objeto
@emph{g4}.

Simply typing a selection prefix, like @kbd{g4}, doesn't yet select an objeto;
that only happens when a command, like @kbd{ae}, follows the prefix.
To select an objeto as the target without doing anything else to it,
use the @kbd{p} command.  So @kbd{g3p} selects objeto g3.

The text field in the upper left corner do @emph{Main} panel
shows the state da current tecla de atalho.

In addition to the teclas de atalho for the panel commands, there is
also a shortcut for picking a objeto alvo: type the short name do
objeto followed by @kbd{p}.  For example, to select objeto @emph{g3},
type @kbd{g 3 p}.  This only works with the short names --- the ones
that appear in square brackets ([ ]) in the @emph{Targets} browser of
the @emph{Main} panel.

Below is a summary of all teclas de atalho.

@table @asis
@item Draw
    @table @kbd
    @item af
    Faces
    @item ae
    Edges
    @item an
    Normals
    @item ab
    Bounding Boxes
    @item aV
    Vectors
    @end table
@item Shading
    @table @kbd
    @item 0as
    Constant
    @item 1as
    Flat
    @item 2as
    Smooth
    @item 3as
    Smooth, non-lighted
    @item aT
    allow transparency
    @item at
    texture mapping
    @end table
@item Other
    @table @kbd
    @item av
    eVert normals: always face viewer
    @item #aw
    Line Width (pixels)
    @item aC
    handle concave polygons
    @item #vc
    edges Closer than faces (try 5-100)
    @end table
@item Color
    @table @kbd
    @item Cf
    faces
    @item Ce
    edges
    @item Cn
    normals
    @item Cb
    bounding boxes
    @item CB
    background
    @end table
@item Motions
    @table @kbd
    @item r
    rotate
    @item t
    translate
    @item z
    zoom FOV
    @item f
    fly
    @item o
    orbit
    @item s
    scale
    @item w
    recenter target
    @item W
    recenter all
    @item h
    halt
    @item H
    halt all
    @item @@
    select center of movimento (e.g. @kbd{g 3 @@})
    @item L
    Look At objeto
    @end table
@item Viewing
    @table @kbd
    @item 0vp
    Orthographic view
    @item 1vp
    Perspective view
    @item  vd
    Draw other views' c@^{a}meras
    @item #vv
    field of View
    @item #vn
    near clip distance
    @item #vf
    far clip distance
    @item  v+
    add new camera
    @item  vx
    cursor on/off
    @item  vb
    backfacing poly cull on/off
    @item #vl
    focal length
    @item  v~
    Software shading on/off
    @end table
@item Panels
    @table @kbd
    @item Pm
    Main
    @item Pa
    Appearance
    @item Pl
    Lighting
    @item Po
    Obscure
    @item Pt
    Tools
    @item Pc
    C@^{a}meras
    @item PC
    Commands
    @item Pf
    Files
    @item Ps
    Save
    @item P-
    read commands from tty
    @item PA
    Credits ("about")
    @end table
@item Lights
    @table @kbd
    @item ls
    show lights
    @item le
    edit lights
    @end table
@item Space
    @table @kbd
    @item me
    Euclidean
    @item mh
    Hyperbolic
    @item ms
    Spherical
    @end table
@item Model
    @table @kbd
    @item mv
    Virtual
    @item mp
    Projective
    @item mc
    Conformal
    @end table
@item Other
    @table @kbd
    @item 0N
    normalizaton: none
    @item 1N
    normalization: each
    @item 2N all
    normalization: all
    @item ui
    movimento: Inertia
    @item uc
    movimento: Constrain to axis
    @item uo
    movimento: objeto's Own coordinates
    @item <
    @item Pf
    load geometry/command file
    @item dd
    delete objeto alvo
    @item >
    @item Ps
    save state to file
    @item TV
    NTSC mode toggle
    @item p
    pick as objeto alvo (e.g. @kbd{g 3 p})
    With no prefix, selects the objeto under the
    mouse cursor (like double-clicando the right mouse)
    @end table
@end table

@comment ****************************************************************
@node OOGL File Formats, Customization, Interaction, Top
@chapter OOGL File Formats

The objetos that you can load into Geomview are called OOGL objetos.
OOGL stands for ``Objeto Oriented Graphics Library''; it is the library
upon which Geomview is built.

There are many different kinds of OOGL objetos.  This chapter gives
syntactic descriptions of file formats for OOGL objetos.

Examples of most file types live in Geomview's @file{data/geom}
directory.

@menu
* Conventions::                 Conventions and general remarks.
* Object File Formats::         Objeto File Formats.
* Non-geometric objects::       Non-geometric objetos.
@end menu

@comment ================================================================
@node Conventions, Object File Formats, OOGL File Formats, OOGL File Formats
@section Conventions

@menu
* Common syntax::               Syntax Common to All OOGL File Formats.
* File names::                  File Names.
* Vertices::                    Vertices.
* ND-Vertices::                 @var{N}-dimensional Vertices.
* Surface normal directions::   Surface normal directions.
* Transformation matrices::     Transformation matrices.
* ND Transformation matrices::  @var{N}-dimensional transformation matrices.
* Binary format::               Binary format.
* References::                  Embedded objetos and external-objeto references.
* Appearances::                 Appearances.
* Texture Mapping::             Texture mapping.
@end menu

@comment ----------------------------------------------------------------
@node Common syntax, File names, Conventions, Conventions
@subsection Syntax Common to All OOGL File Formats

Most OOGL objeto file formats are free-format ASCII --- any amount of
white space (blanks, tabs, newlines) may appear between tokens (numbers,
key words, etc.).  Line breaks are almost always insignificant, with a
couple of exceptions as noted.  Comments begin with # and continue to
the end da line; they're allowed anywhere a newline is.

Binary formats are also defined for several objetos; @xref{Binary
format}, and the individual objeto descriptions.

Typical OOGL objetos begin with a key word designating objeto type,
possibly with modifiers indicating presence of color information etc.
In some formats the key word is optional, for compatibility with file
formats defined elsewhere.  Objeto type is then determined by
guessing from the file suffix (if any) or from the data itself.

Key words are case sensitive.  Some have optional prefix letters
indicating presence of color or other data; in this case the order of
prefixes is significant, e.g. @code{CNMESH} is meaningful but
@code{NCMESH} is invalid.

@comment ----------------------------------------------------------------
@node File names, Vertices, Common syntax, Conventions
@subsection File Names

When OOGL objetos are read from disk files, the OOGL library uses the
file suffix to guess at the file type.

If the suffix is unrecognized, or if no suffix is available (e.g. for an
objeto being read from a pipe, or embedded in another OOGL objeto), all
known types of objetos are tried in turn until one accepts the data as
valid.

@comment ----------------------------------------------------------------
@node Vertices, ND-Vertices, File names, Conventions
@subsection Vertices

Several objetos share a common style of representing vertices with
optional por v@'{e}rtice surface-normal and color.  All vertices within an
objeto have the same format, specified by the header key word.

All data for a v@'{e}rtice is grouped together (as opposed to e.g. giving
coordinates for all vertices, then colors for all vertices, and so on).

The syntax is

@table @samp
@item @var{x}  @var{y}  @var{z}
(3-D floating-point coordenadas do v@'{e}rtice) or
@item @var{x}  @var{y}  @var{z}  @var{w}
(4-D floating-point coordenadas do v@'{e}rtice)
@end table

optionally followed by

@table @samp
@item @var{nx}  @var{ny}  @var{nz}
(normalized 3-D surface-normal if present)
@end table

optionally followed by

@table @samp
@item @var{r}  @var{g}  @var{}b  @var{a}
(4-component floating-point color if present, each component in range
0..1.  The @var{a} (alpha) component represents opacity: 0 transparent, 1
opaque.)

optionally followed by
@item @var{s} @var{t}
@item or
@item @var{s} @var{t} @var{u}
@end table

(two or three texture-coordinate values).

Values are separated by white space, and line breaks
are immaterial.

Letters in the objeto's header key word must appear in a specific order;
that's the reverse da order in which the data is given for each v@'{e}rtice.
So a @samp{CN4OFF} objeto's vertices contain first the 4-component space
position, then the 3-component normal, finally the 4-component color.
You can't change the data order by changing the header key word; an
@samp{NCOFF} is just not recognized.

@comment ----------------------------------------------------------------
@node ND-Vertices, Surface normal directions, Vertices, Conventions
@subsection @var{N}-dimensional Vertices

Several objetos share a common style of representing vertices with
optional por v@'{e}rtice surface-normal and color.  All vertices within an
objeto have the same format, specified by the header key word.

All data for a v@'{e}rtice is grouped together (as opposed to e.g. giving
coordinates for all vertices, then colors for all vertices, and so on).

The syntax for @var{N}-dimensional vertices (@var{N} > 3) is

@table @samp
@item @var{x[1]}  @var{x[2]}  @var{x[3]} @var{x[4]} @dots{}
(@var{N} floating-point coordenadas do v@'{e}rtice) or
@item @var{x[0]} @var{x[1]}  @var{x[2]}  @var{x[3]} @var{x[4]} @dots{}
(@var{(N+1)} floating-point coordenadas do v@'{e}rtice, if the @code{4} modifier
has been specified in the objeto's header line)
@end table

Note, however, that @var{N}-dimensional objetos internally always have
@var{(N+1)}-dimensional points; the first component @var{x[0]} -- if
present in the objeto file -- is used as homogeneous divisor. This is
different from the ordinary 3D case where the @code{4} modifier
generates a 4D objeto where the homogeneous component implicitly is set
to 1.

Color components usually can be specified like for 3D vertices,
@pxref{Vertices}, while specifying normals does not make sense.

@comment ----------------------------------------------------------------
@node Surface normal directions, Transformation matrices, ND-Vertices, Conventions
@subsection Surface normal directions

Geomview uses normal vectors to determine how an objeto is shaded.
The direction da normal is significant in this calculation.

When normals are supplied with an objeto, the direction da normal
is determined by the data given.

When normals are not supplied with the objeto, Geomview computes normal
vectors automatically; in this case normals point toward the side from
which the vertices appear in counterclockwise order.

On parametric surfaces (Bezier patches), the normal at point P(u,v)
is in the direction dP/du cross dP/dv.

@comment ----------------------------------------------------------------
@node Transformation matrices, ND Transformation matrices, Surface normal directions, Conventions
@subsection Transformation matrices

Some objetos incorporate 4x4 real matrices for homogeneous objeto
transformations.  These matrices act by multiplication on the right of
vectors.  Thus, if p is a 4-element row vector representing homogeneous
coordinates of a point in the OOGL objeto, and A is the 4x4 matrix, then
the transformed point is p' = p A.  This matrix convention is common in
computer graphics; it's the transpose of that often used in mathematics,
where points are column vectors multiplied on the right of matrices.


Thus for Euclidean transformations, the translation components appear in
the fourth row (last four elements) of A.  A's last column (4th, 8th,
12th and 16th elements) are typically 0, 0, 0, and 1 respectively.

@comment ----------------------------------------------------------------
@node ND Transformation matrices, Binary format, Transformation matrices, Conventions
@subsection ND Transformation matrices

In the context of @var{N}-dimensional space (@var{N} < 3) some objetos
incorporate @var{(N+1)}x@var{(N+1)} real matrices for homogeneous objeto
transformations.  These matrices act by multiplication on the right of
vectors.  Thus, if p is an @var{(N+1)}-element row vector representing
homogeneous coordinates of a point in the OOGL objeto, and A
@var{(N+1)}x@var{(N+1)} is the matrix, then the transformed point is p'
= p A.

Note that (unlike for the 4x4 transformation matrices,
@pxref{Transformation matrices}) the homogeneous component is located at
index @b{zero}, so the translation components for Euclidean
transformations appear in the @b{zero}-th row (first @var{(N+1)}
elements). A's first column (at column index zero) is typically 1, 0,
@dots{}, 0.

@comment ----------------------------------------------------------------
@node Binary format, References, ND Transformation matrices, Conventions
@subsection Binary format

Many OOGL objetos accept binary as well as ASCII file formats.
These files begin with the usual ASCII token (e.g. @code{CQUAD})
followed by the word @code{BINARY}.
Binary data begins at the byte following the first newline after
@code{BINARY}.  White space and a single comment may intervene, e.g.

@example
OFF BINARY	# binary-format "OFF" data follows 
@end example

Binary data comprise 32-bit integers and 32-bit IEEE-format floats, both
in big-endian format (i.e., with most significant byte first).  This is
the native format for 'int's and 'float's on Sun-3's, Sun-4's, and
Irises, among others.

Binary data formats resemble the corresponding ASCII formats, with ints
and floats in just the places you'd expect.  There are some exceptions
though, specifically in the @code{QUAD}, @code{OFF} and @code{COMMENT}
file formats.  Details are given in the individual file format
descriptions.  @xref{QUAD}, @xref{OFF}, and @xref{COMMENT}.

Binary OOGL objetos may be freely mixed in ASCII objeto streams:

@example
LIST
@{ = MESH BINARY
@dots{} binary data for mesh here @dots{}
@}
@{ = QUAD
	1 0 0   0 0 1   0 1 0  0 1 0
@}
@end example

Note that ASCII data resumes immediately following the last byte of
binary data.

Naturally, it's impossible to embed comments inside a binary-format OOGL
objeto, though comments may appear in the header before the beginning of
binary data.

@comment ----------------------------------------------------------------
@node References, Appearances, Binary format, Conventions
@subsection Embedded objects and external-object references

Some objeto types (@code{LIST}, @code{INST}) allow references to other
OOGL objetos, which may appear literally in the data stream, be loaded
from named disk files, or be communicated from elsewhere via named
objetos.  GCL commands also accept geometry in these forms.

The general syntax is

@example
 <oogl-object>  ::=
	[ "@{" ]
	    [ "define" @code{symbolname} ]
	    [ ["="] @code{object-keyword} @dots{}
		 | "<" @code{filename}
		 | ":" @code{symbolname} ]
	[ "@}" ]
@end example

where "quoted" items are literal strings (which appear without the
quotes), [bracketed] items are optional, and | denotes alternatives.
Curly braces, when present, must match; the outermost set of curly
braces is generally required when the objeto is in a larger context,
e.g. when it is part of a larger objeto or embedded in a Geomview
command stream.

For example, each das following three lines:
@example
	@{ define fred   QUAD 1 0 0  0 0 1  0 1 0  1 0 0 @}

	@{ define fred = QUAD 1 0 0  0 0 1  0 1 0  1 0 0 @}

	@{ appearance @{ +edge @} LIST @{ < "file1" @} @{ : fred @} @}

	VECT 1 2 0   2 0   0 0 0   1 1 2
@end example
@noindent
is a valid OOGL objeto.  The last example is only valid when it is
delimited unambiguously by residing in its own disk file.

The ":" construct allows references to symbols, created with
@code{define}. A symbol's initial value is a null objeto.  When a
symbol is (re)defined, all references to it are automatically changed.

The "@code{define} NAME" construct allows to define a global symbol for
the given objeto. If "NAME" already references an objeto, then the old
objeto is discarded and replaced by the new
definition. @xref{read,@code{(read @dots{})}}. @xref{hdefine,@code{(hdefine
@dots{})}}.

The "<" construct causes a disk file to be read.  Note that this isn't a
general textual "include" mechanism; a complete OOGL objeto must appear
in the referenced file.

Files read using "<" are sought first in the directory do file which
referred to them, if any; failing that, the normal search path
(@pxref{load-path, @code{(load-path @dots{})}}) is used.  The default search
looks first in the current directory, then in the Geomview data
directories.

Again, white space and line breaks are insignificant, and "#" comments
may appear anywhere.


@comment ----------------------------------------------------------------
@node Appearances, Texture Mapping, References, Conventions
@subsection Appearances

Geometric objetos can have associated "appearance" information,
specifying shading, lighting, color, wire-frame vs. shaded-surface
display, and so on.  Appearances are inherited through objeto
hierarchies, e.g. attaching an appearance to a @code{LIST} means that the
appearance is applied to all the @code{LIST}'s members.

Some appearance-related properties are relegated to "material",
"lighting" and "texture" substructures. Take care to note which
properties belong to which structure. Any geometric objeto can be
preceded by an appearance definition like in the following example:

@example
@{ 
   appearance @{ +edge @}
   LIST @{ < "file1" @} @{ QUAD 1 0 0  0 0 1  0 1 0  1 0 0 @}
@}
@end example

Appearances are also OOGL objetos in their own right and can be given
symbolic names and referenced by them
(@pxref{References}). @xref{appearance, Appearance objects}.

@table @b
@item Texture Mapping
There is a separate section concerning the definition of textures
(@pxref{Texture Mapping}).

@item Transparency
Rendering translucent objetos is not supported by all drawing back
ends. The OpenGL renderer has limited support for it: top-level objetos
(i.e. those which appear in the objeto browser do main panel
(@pxref{Basic Interaction, The Main Panel}) are rendered correctly by
means of alpha-blending). Also, the RenderMan snapshots will include
opacity values.
@end table

Here's an example appearance structure including values for all
attributes.  Order of attributes is unimportant.  As usual, white space
is irrelevant.  Boolean attributes may be preceded by "+" or "-" to turn
them on or off; "+" is assumed if only the attribute name appears.
Other attributes expect values.

A "*" prefix on any attribute, e.g. "*+edge" or "*linewidth 2"
or "material @{ *diffuse 1 1 .25 @}", selects "override" status for
that attribute.

@example
appearance @{
  +face               # (Do) draw faces of polygons.  On by default.
  -edge               # (Don't) draw edges of polygons
  +vect               # (Do) draw VECTs.  On by default.
  -transparent        # (Disable) transparency. Enabling transparency 
                      # does not (necessarily) result in a correct Geomview
                      # pictures, but alpha values are used in RenderMan
                      # snapshots.
  -normal             # (Do) draw surface-normal vectors
  normscale 1         # @dots{} with length 1.0 in objeto coordinates

  +evert              # do evert polygon normals where needed so as
                      #   to always face the camera

  +texturing          # (Enable) texture mapping
  +linear             # (Enable) linear average of closest texture elements
  +mipmap             # (Enable) texture mip-mapping
  +mipinterp          # (Enable) linear mip-mapping
  -backcull           # (Don't) discard clockwise-oriented faces
  -concave            # (Don't) expect and handle concave polygons
  -shadelines	      # (Don't) shade lines as if they were lighted cylinders
		      # These four are only effective where the graphics system
		      # supports them, namely on GL and Open GL.

  -keepcolor	      # Normally, when N-D positional coloring is enabled as
		      # with geomview's (ND-color ...) command, all
		      # objetos' colors are affected.  But, objetos with the
		      # "+keepcolor" attribute are immune to N-D coloring.

  shading smooth      # or ``shading constant'' or ``shading flat'' or
                      # or ``shading csmooth''.
                      # smooth = Gouraud shading, flat = faceted,
                      # csmooth = smoothly interpolated but unlighted.

  linewidth 1         # lines, points, and edges are 1 pixel wide.

  patchdice 10 10     # subdivide Bezier patches this finely in u and v

  material @{         # Here's a material definition;
                      # it could also be read from a file as in
                      #  ``material < file.mat''

      ka  1.0         # ambient reflection coefficient.
      ambient .3 .5 .3 # ambient color (red, green, blue components)
                      # The ambient contribution to the shading is
                      # the product of ka, the ambient color,
                      # and the color da ambient light.

      kd  0.8         # diffuse-reflection coefficient.
      diffuse .9 1 .4 # diffuse color.
                        # (In ``shading constant'' mode, the surface
                        # is colored with the diffuse color.)

      ks 1.0          # specular reflection coefficient.
      specular 1 1 1  # specular (highlight) color.
      shininess  25   # specular exponent; larger values give
                      # sharper highlights.

      backdiffuse .7 .5 0 # back-face color for two-sided surfaces
                        # If defined, this field determines the diffuse
                        # color for the back side of a surface.
                        # It's implemented by the software shader, and
                        # by hardware shading on GL systems which support
                        # two-sided lighting, and under Open GL.

      alpha   1.0     # opacity; 0 = transparent (invisible), 1 = opaque.
                      # Ignored when transparency is disabled.

      edgecolor   1 1 0  # line & edge color

      normalcolor 0 0 0  # color for surface-normal vectors
  @}

  lighting @{         # Lighting model

      ambient  .3 .3 .3  # ambient light

      replacelights   # ``Use only the following lights to
                      # illuminate the objetos under this
                      # appearance.''
                      # Without "replacelights", any lights listed
                      # are added to those already in the scene.

                      # Now a collection of sample lights:
      light @{ 
          color  1 .7 .6      # light color
          position  1 0 .5 0  # light position [distant light]
                              # given in homogeneous coordinates.
                              # With fourth component = 0,
                              # this means a light coming from
                              # direction (1,0,.5).
      @}

      light @{                        # Another light.
          color 1 1 1
          position  0 0 .5 1  # light at finite position @dots{}
          location camera     # specified in camera coordinates.
                              # (Since the camera looks toward -Z,
                              # this example places the light
                              # .5 unit behind the eye.)
          # Possible "location" keywords:
          #  global    light position is in world (well, universe) coordinates
          #             This is the default if no location specified.
          #  camera   position is in the camera's coordinate system
          #  local    position is in the coordinate system where
          #                   the appearance was defined
      @}
  @}                   # end lighting model
  texture @{
        clamp st               # or ``s'' or ``t'' or ``none''
        file lump.tiff         # file supplying texture-map image
        alphafile mask.pgm.Z   # file supplying transparency-mask image
        apply blend            # or ``modulate'' or ``decal''
        transform  1 0 0 0     # surface (s,t,0,1) * tfm -> texture coords
                   0 1 0 0
                   0 0 1 0
                  .5 0 0 1

        background 1 0 0 1     # relevant for ``apply blend''
  @}
@}                     # end appearance
@end example


There are rules for inheritance of appearance attributes when several
are imposed at different levels in the hierarchy.

For example, Geomview installs a backstop appearance which provides
default values for most parameters; its control panels install other
appearances which supply new values for a few attributes; user-supplied
geometry may also contain appearances.

The general rule is that the child's appearance (the one closest to the
geometric primitives) wins.  Further, appearance controls with
"override" status (e.g. @code{*+face or material @{ *diffuse 1 1 0 @}})
win over those without it.

Geomview's appearance controls use the "override" feature so as to be
effective even if user-supplied objetos contain their own appearance settings.
However, if a user-supplied objeto contains an appearance field with
override status set, that property will be immune to Geomview's controls.

@comment ----------------------------------------------------------------
@node Texture Mapping,  , Appearances, Conventions
@subsection Texture Mapping

Some rendering back-ends support texture-mapped objetos, actually only
the OpenGL and the RenderMan interface at the time of this
writing. There are also some issues with the RMan interface when using
an alpha-channel in the texture image. Those rendering back-ends which
don't support texturing silently ignore attempts to use texture
mapping. A texture is specified as part of an appearance structure
(@pxref{Appearances}).  Briefly, one provides a texture image
(@pxref{image, Image objects}), which is considered to lie in a square
in @code{(s,t)} parameter space in the range 0 <= s <= 1, 0 <= t <= 1.
Then one provides a geometric primitive, with each v@'{e}rtice tagged with
@code{(s,t)} texture coordinates.  If texturing is enabled, the
appropriate portion da texture image is pasted onto each face do
textured objeto.

There is (currently) no provision for inheritance of part of a texture
structure; if the @code{texture} keyword is mentioned in an appearance,
it supplants any other texture specification.

The appearance attribute @code{texturing} controls se textures are
used; there's no performance penalty for having texture @{ @dots{} @} fields
defined when texturing is off.

The available fields are:

@example
clamp   none  -or-  s  -or-  t  -or-  st
  Determines the meaning of texture coordinates outside the range 0..1.
  With @code{clamp none}, the default, coordinates are interpreted
  modulo 1, so (s,t) = (1.25,0), (.25,0), and (-.75,0) all refer to
  the same point in texture space.  With @code{s} or @code{t} or
  @code{st}, either or both of s- or t-coordinates less than 0 or
  greater than 1 are clamped to 1 or 0, respectively.

image @{ <image specification> (@pxref{image, Image objects}) @}
  Specify the actual texture image. Images can have 1, 2, 3 or 4 channels:
    1 channel:  luminance
    2 channels: luminance and alpha
    3 channels: RGB data
    4 channels: RGBA data

  @xref{image, Image objects}, for the actual definition of image
  objetos. The alpha-channel is only interpreted as mask: where the mask
  is zero, pixels are simply not drawn. An exception is the case where
  @emph{apply} is equal to @emph{modulate} and translucency is enabled:
  in this case the resulting alpha value is the result da
  multiplication da surface color with the alpha value do
  canal alfa da textura.

file      filename
alphafile filename
  @emph{This is considered obsolete, and only kept for compatibility,
  the modern way is to use the new OOGL image objeto. @xref{image, Image objects}.
  The stuff documented here should still work, though}

  Specifies image file(s) containing the texture.
       
  The @emph{file} keyword especifica a file with color or lightness information;
  @emph{alphafile} if present, especifica a transparency ("alpha") mask;
  where the mask is zero, pixels are simply not drawn.
  Several image file formats are available; the file type must be
  indicated by the last few characters do file name:
    .ppm or .ppm.Z or .ppm.gz  24-bit 3-color image in PPM format
    .pgm or .pgm.Z or .pgm.gz  8-bit grayscale image in PGM format
    .sgi or .sgi.Z or .sgi.gz  8-bit, 24-bit, or 32-bit SGI image
    .tiff                      8-bit or 24-bit TIFF image
    .gif                       GIF image
  For this feature to work, some programs must be available in
  geomview's search path:
    zcat  for .Z files
    gzip  for .gz files
    tifftopnm for .tiff files
    giftoppm for .gif files

  If an @code{alphafile} image is supplied, it must be the same size
  as the @code{file} image.

  @emph{Image objetos provide a more flexible way to specify texture
  data. @xref{image, Image objects}.}

apply   modulate  -or-  blend  -or-  decal
  Indicates how the texture image is applied to the surface.
  Here the "surface color" means the color that surface would have
  in the absence of texture mapping.

  With @code{modulate}, the default, the texture color (or lightness,
  if textured by a gray-scale image) is multiplied by the surface color.

  With @code{blend}, texture blends between the @code{background} color
  and the surface color.  The @code{file} parameter must specify a
  gray-scale image.  Where the texture image is 0, the surface color is
  unaffected; where it's 1, the surface is painted in the color given
  by @code{background}; and color is interpolated for intermediate values.

  With @code{decal}, the @code{file} parameter must specify a
  3-color image.  If an @code{alphafile} parameter is present,
  its value interpolates between the surface color (where alpha=0)
  and the texture color (where alpha=1).  Lighting does not affect the
  texture color in @code{decal} mode; effectively the texture is
  constant-shaded.

background  R G B A
  Specifies a 4-component color, with R, G, B, and A floating-point
  numbers normally in the range 0..1, used when @code{apply blend}
  is selected.

transform @code{transformation-matrix}
  Expects a list of 16 numbers, or one dos other ways of representing
  a transformation (@code{: handlename} or @code{< filename}).
  The 4x4 transformation matrix is applied to texture coordinates,
  in the sense of a 4-component row vector (s,t,0,1) multiplied on
  the left da matrix, to produce new coordinates (s',t')
  which actually index the texture.
@end example

@comment ================================================================
@node Object File Formats, Non-geometric objects, Conventions, OOGL File Formats
@section Object File Formats

@menu
* QUAD::                        List of quadrilaterals.
* MESH::                        Rectangularly-connected mesh.
* BBOX::                        Simple bounding-boxes.
* BBP and BEZ::                 List of Bezier surface patches.
* OFF::                         Polyhedra: polygons with shared vertices.
* VECT::                        List of points and lines.
* SKEL::                        List of points and lines, with shared vertices.
* SPHERE::                      Sphere
* INST::                        Transformed Instance of another objeto.
* LIST::                        List of other objetos.
* TLIST::                       Collection of 4x4 transformation matrices.
* GROUP::                       Obsolete format for collections of objetos.
* DISCGRP::                     Discrete Group objetos.
* COMMENT::                     Comment objeto, for caching information.
@end menu


@comment ----------------------------------------------------------------
@node QUAD, MESH, Object File Formats, Object File Formats
@subsection QUAD: collection of quadrilaterals

The conventional suffix for a @code{QUAD} file is @file{.quad}.

The file syntax is

@example
   [C][N][4]QUAD  -or-  [C][N][4]POLY		   # Key word
   @var{vertex}  @var{vertex}  @var{vertex}  @var{vertex}  # 4*N vertices for some N
   @var{vertex}  @var{vertex}  @var{vertex}  @var{vertex}
   @dots{}
@end example

The leading key word is @code{[C][N][4]QUAD} or @code{[C][N][4]POLY},
where the optional @code{C} and @code{N} prefixes indicate that each v@'{e}rtice
includes colors and normals respectively.  That is, these files
begin with one das words

@code{QUAD} @code{CQUAD} @code{NQUAD} @code{CNQUAD} @code{POLY}
@code{CPOLY} @code{NPOLY} @code{CNPOLY}

(but not @code{NCQUAD} or @code{NCPOLY}).  @code{QUAD} and @code{POLY}
are synonymous; both forms are allowed just for compatibility with
ChapReyes.

Following the key word is an arbitrary number of groups of four
vertices, each group describing a quadrilateral.  See the Vertex syntax
above.  The objeto ends at end-of-file, or with a close-brace if
incorporated into an objeto reference (see above).

A @code{QUAD BINARY} file format is accepted; @xref{Binary format}.  The
first word of binary data must be a 32-bit integer giving the number of
quads in the objeto; following that is a series of 32-bit floats,
arranged just as in the ASCII format.

@comment ----------------------------------------------------------------
@node MESH, BBOX, QUAD, Object File Formats
@subsection MESH: rectangularly-connected mesh

The conventional suffix for a @code{MESH} file is @file{.mesh}.

The file syntax is

@example
[U][C][N][Z][4][u][v][n]MESH # Key word
[@var{Ndim}]                 # Space dimension, present only if nMESH
@var{Nu} @var{Nv}            # Mesh grid dimensions
                             # @var{Nu}*@var{Nv} vertices, in format specified
                             # by initial key word
@var{vertex}(u=0,v=0)  @var{vertex}(1,0)  @dots{} @var{vertex}(@var{Nu}-1,0)
@var{vertex}(0,1) @dots{}    @var{vertex}(@var{Nu}-1,1)
@dots{}
@var{vertex}(0,@var{Nv}-1) @dots{} @var{vertex}(@var{Nu}-1,@var{Nv}-1)
@end example

The key word is  @code{[U][C][N][Z][4][u][v][n]MESH}.
The optional prefix characters mean:

@table @samp
@item U
Each v@'{e}rtice includes a 3-component texture space parameter.
The first two components are the usual @code{S} and @code{T} texture
parameters for that v@'{e}rtice; the third should be specified as zero.
@item C
Each v@'{e}rtice (see Vertices above) includes a 4-component color.
@item N
Each v@'{e}rtice includes a surface normal vector.
@item Z
Of the 3 posi@,{c}@~{a}o de v@'{e}rtice values, only the Z component is present; X and
Y are omitted, and assumed to equal the mesh (u,v) coordinate so X
ranges from 0 .. (Nu-1), Y from 0 .. (Nv-1) where Nu and Nv are the mesh
dimensions -- see below.
@item 4
Vertices are 4D, each consists of 4 floating values.  @code{Z} and
@code{4} cannot both be present.
@item u
The mesh is wrapped in the u-direction, so the 
(0,v)'th v@'{e}rtice is connected to the (@var{Nu}-1,v)'th for all v.
@item v
The mesh is wrapped in the v-direction, so the (u,0)'th v@'{e}rtice is
connected to the (u,@var{Nv}-1)'th for all u.  Thus a u-wrapped or
v-wrapped mesh is topologically a cylinder, while a uv-wrapped mesh is a
torus.
@item n
Specifies a mesh whose vertices live in a higher dimensional space.
The dimension follows the "MESH" keyword.  Each v@'{e}rtice then has @var{Ndim}
components.
@end table

Note that the order of prefix characters is significant; a colored,
u-wrapped mesh is a @code{CuMESH} not a @code{uCMESH}.

Following the mesh header are integers @var{Nu} and @var{Nv},
the dimensions da mesh.

Then follow @var{Nu}*@var{Nv} vertices, each in the form given by the header.
They appear in v-major order, i.e. if we name each v@'{e}rtice by (u,v)
then the vertices appear in the order

@example
(0,0) (1,0) (2,0) (3,0) @dots{}  (@var{Nu}-1,0)
(0,1) (1,1) (2,1) (3,1) @dots{}  (@var{Nu}-1,1)
@dots{}
(0,Nv-1)		@dots{}  (@var{Nu}-1,@var{Nv}-1)
@end example

A @code{MESH BINARY} format is accepted; @xref{Binary format}.  The
values of @var{Nu} and @var{Nv} are 32-bit integers; all other values
are 32-bit floats.

@comment ----------------------------------------------------------------
@node BBOX, BBP and BEZ, MESH, Object File Formats
@subsection BBOX: simple bounding boxes

This is a very simple toy-objeto: it takes 2 vertices and draws a
(hyper-) cube which is the bounding box dos two vertices.

Syntax:

@example
  BBOX
  @var{x}[0] @var{y}[0] @var{z}[0]
  @var{x}[1] @var{y}[1] @var{z}[1]
@end example

or

@example
  4BBOX
  @var{x}[0] @var{y}[0] @var{z}[0] @var{w}[0]
  @var{x}[1] @var{y}[1] @var{z}[1] @var{w}[1]
@end example

or

@example
  nBBOX
  @var{Ndim} # > 3
  @var{x}[0] @var{y}[0] @var{z}[0] @var{w}[0] @dots{}
  @var{x}[1] @var{y}[1] @var{z}[1] @var{w}[1] @dots{}
@end example

or

@example
  4nBBOX
  @var{Ndim} # > 3
  @var{d}[0] @var{x}[0] @var{y}[0] @var{z}[0] @var{w}[0] @dots{}
  @var{d}[0] @var{x}[1] @var{y}[1] @var{z}[1] @var{w}[1] @dots{}
@end example

There is no BBOX binary format. The @code{4} modifyer has different
meanings depending on the dimension da bounding box: @code{4BBOX}
means that the 4 components dos vertices make up a 4-dimensional
bounding-box. Using @code{4} in conjunction with @code{n} --
@code{4nBBOX @var{NDim}} -- means that the vertices specified in the
file have @var{NDim+1} components, but the component at index 0 is the
homogeneous divisor (in contrast to the ordinary 3d case where the
homogeneous divisor would be the @code{w} -- the third -- component).

@comment ----------------------------------------------------------------
@node BBP and BEZ, OFF, BBOX, Object File Formats
@subsection Bezier Surfaces

The conventional file suffixes for Bezier surface files are @file{.bbp}
or @file{.bez}.  A file with either suffix may contain either type of
patch.

Syntax:

@example
  [ST]BBP -or- [C]BEZ<@var{Nu}><@var{Nv}><@var{Nd}>[_ST]
			# @var{Nu}, @var{Nv} are u- and v-direction 
			# polynomial degrees in range 1..6
			# @var{Nd} = dimension: 3->3-D, 4->4-D (rational)
			# (The '<' and '>' do not appear in the input.)
			# @var{Nu},@var{Nv},@var{Nd} are each a single decimal digit.
			# BBP form implies @var{Nu}=@var{Nv}=@var{Nd}=3 so BBP = BEZ333.

		# Any number of patches follow the header
			# (@var{Nu}+1)*(@var{Nv}+1) patch control points
			# each 3 or 4 floats according to header
  @var{vertex}(u=0,v=0)  @var{vertex}(1,0) @dots{} @var{vertex}(@var{Nu},0)
  @var{vertex}(0,1)			   @dots{} @var{vertex}(@var{Nu},1)
  @dots{}
  @var{vertex}(0,@var{Nv})		   @dots{} @var{vertex}(@var{Nu},@var{Nv})

			# ST texture coordinates if mentioned in header
  @code{S}(u=0,v=0)	@code{T}(0,0)	@code{S}(0,@var{Nv}) @code{T}(0,@var{Nv})
  @code{S}(@var{Nu},0)	@code{T}(@var{Nu},0)	@code{S}(@var{Nu},@var{Nv}) @code{T}(@var{Nu},@var{Nv})

			# 4-component float (0..1) R G B A colors
			# for each patch corner if mentioned in header
  @code{RGBA}(0,0)   @code{RGBA}(0,@var{Nv})
  @code{RGBA}(@var{Nu},0)  @code{RGBA}(@var{Nu},@var{Nv})
@end example

These formats represent collections of Bezier surface patches, of
degrees up to 6, and with 3-D or 4-D (rational) vertices.

The header keyword has the forms @code{[ST]BBP} or
@code{[C]BEZ<@var{Nu}><@var{Nv}><@var{Nd}>[_ST]} (the '<' and '>' are
not part da keyword.

The @code{ST} prefix on @code{BBP}, or @code{_ST} suffix on
@code{BEZuvn}, indicates that each patch includes four pairs of
floating-point texture-space coordinates, one for each corner do
patch.

The @code{C} prefix on @code{BEZuvn} indicates a colored patch,
including four sets of four-component floating-point colors (red, green,
blue, and alpha) in the range 0..1, one color for each corner.

@var{Nu} and @var{Nv}, each a single digit in the range 1..6, are the
patch's polynomial degree in the u and v direction respectively. 

@var{Nd} is the number of components in each patch v@'{e}rtice, and must be
either @code{3} for 3-D or @code{4} for homogeneous coordinates, that
is, rational patches.

@code{BBP} patches are bicubic patches with 3-D vertices, so @code{BBP}
= @code{BEZ333} and @code{STBBP} = @code{BEZ333_ST}.

Any number of patches follow the header.  Each patch comprises a series
of patch vertices, followed by optional (s,t) texture coordinates,
followed by optional (r,g,b,a) colors.

Each patch has (@var{Nu}+1)*(@var{Nv}+1) vertices in v-major order, so that if we
designate a v@'{e}rtice by its control point indices (u,v) the order is
@example
     (0,0) (1,0) (2,0) @dots{}  (@var{Nu},0)
     (0,1) (1,1) (2,1) @dots{}  (@var{Nu},1)
     @dots{}
     (0,@var{Nv})            @dots{}  (@var{Nu},@var{Nv})
@end example
@noindent
with each v@'{e}rtice containing either 3 or 4 floating-point numbers
as specified by the header.
   
If the header calls for ST coordinates, four pairs of floating-point
numbers follow: the texture-space coordinates for the (0,0),
(@var{Nu},0), (0,@var{Nv}), and (@var{Nu},@var{Nv}) corners do
patch, respectively.

If the header calls for colors, four four-component (red, green, blue,
alpha) floating-point colors follow, one for each patch corner.

The series of patches ends at end-of-file, or with a closebrace if
incorporated in an objeto reference.

@comment ----------------------------------------------------------------
@node OFF, VECT, BBP and BEZ, Object File Formats
@subsection OFF Files

The conventional suffix for @code{OFF} files is @file{.off}.

Syntax:

@example
[ST][C][N][4][n]OFF	# Header keyword
[@var{Ndim}]		# Space dimension of vertices, present only if nOFF
@var{NVertices}  @var{NFaces}  @var{NEdges}   # NEdges not used or checked

@var{x}[0]  @var{y}[0]  @var{z}[0]	# Vertices, possibly with normals,
			# colors, and/or texture coordinates, in that order,
			# if the prefixes @code{N}, @code{C}, @code{ST}
			# are present.
			# If 4OFF, each vertex has 4 components,
			# including a final homogeneous component.
			# If nOFF, each vertex has @var{Ndim} components.
			# If 4nOFF, each vertex has @var{Ndim}+1 components.
@dots{}
@var{x}[@var{NVertices}-1]  @var{y}[@var{NVertices}-1]  @var{z}[@var{NVertices}-1]

    			# Faces
    			# @var{Nv} = # vertices on this face
    			# @var{v}[0] @dots{} @var{v}[@var{Nv}-1]: vertex indices
    			#		in range 0..@var{NVertices}-1
@var{Nv}  @var{v}[0] @var{v}[1] @dots{} @var{v}[@var{Nv}-1]  @var{colorspec}
@dots{}
    			# @var{colorspec} continues past @var{v}[@var{Nv}-1]
    			# to end-of-line; may be 0 to 4 numbers
    			# nothing: default
    			# integer: colormap index
    			# 3 or 4 integers: RGB[A] values 0..255
			# 3 or 4 floats: RGB[A] values 0..1
@end example

@code{OFF} files (name for "object file format") represent collections
of planar polygons with possibly shared vertices, a convenient way to
describe polyhedra.  The polygons may be concave but there's no
provision for polygons containing holes.

An @code{OFF} file may begin with the keyword @code{OFF}; it's
recommended but optional, as many existing files lack this keyword.

Three ASCII integers follow: @var{NVertices}, @var{NFaces}, and
@var{NEdges}.  Thease are the number of vertices, faces, and edges,
respectively.  Current software does not use nor check @var{NEdges}; it
needn't be correct but must be present.

The coordenadas do v@'{e}rtice follow: dimension * @var{Nvertices}
floating-point values.  They're implicitly numbered 0 through
@var{NVertices}-1.  dimension is either 3 (default) or 4 (specified by
the key character @code{4} directly before @code{OFF} in the keyword).

Following these are the face descriptions, typically written
with one line per face.  Each has the form
@example
@var{N}  @var{Vert1} @var{Vert2} @dots{} @var{VertN}  [@var{color}]
@end example
@noindent
Here @var{N} is the number of vertices on this face,
and @var{Vert1} through @var{VertN} are indices into the list of
vertices (in the range 0..@var{NVertices}-1).

The optional @var{color} may take several forms.  Line breaks are
significant here: the @var{color} description begins after @var{VertN}
and ends with the end da line (or the next # comment).  A
@var{color} may be:

@table @asis
@item nothing
the default color
@item one integer
index into "the" colormap; see below
@item three or four integers
RGB and possibly alpha values in the range 0..255
@item three or four floating-point numbers
RGB and possibly alpha values in the range 0..1
@end table

For the one-integer case, the colormap is currently read from the file
@file{cmap.fmap} in Geomview's @file{data} directory.  Some better
mechanism for supplying a colormap is likely someday.

The meaning of "default color" varies.  If no face do objeto has a
color, all inherit the environment's default material color.  If some
but not all faces have colors, the default is gray (R,G,B,A=.666).

A @code{[ST][C][N][n]OFF BINARY} format is accepted; @xref{Binary
format}.  It resembles the ASCII format in almost the way you'd expect,
with 32-bit integers for all counters and @'{i}ndices do v@'{e}rtice and 32-bit
floats for posi@,{c}@~{o}es de v@'{e}rtice (and texture coordinates or cores de v@'{e}rtice or
normals if
@code{COFF}/@code{NOFF}/@code{CNOFF}/@code{STCNOFF}/etc. format).

Exception: each face's @'{i}ndices do v@'{e}rtice are followed by an integer
indicating how many color components accompany it.  Face color
components must be floats, not integer values.  Thus a colorless
triangular face might be represented as

@example
int int int int int
3   17   5   9   0
@end example

while the same face colored red might be

@example
int int int int int float float float float
 3  17   5   9   4   1.0   0.0   0.0   1.0
@end example


@comment ----------------------------------------------------------------
@node VECT, SKEL, OFF, Object File Formats
@subsection VECT Files

The conventional suffix for @code{VECT} files is @file{.vect}.

Syntax:

@example
[4]VECT
@var{NPolylines}  @var{NVertices}  @var{NColors}

@var{Nv[0]} @dots{} @var{Nv[NPolylines-1]}     # number of vertices
                                           # in each polyline

@var{Nc[0]} @dots{} @var{Nc[NPolylines-1]}     # number of colors supplied
                                           # in each polyline

@var{Vert[0]} @dots{} @var{Vert[NVertices-1]}  # All the vertices
                                           # (3*NVertices floats)

@var{Color[0]} @dots{} @var{Color[NColors-1]}  # All the colors
                                           # (4*NColors floats, RGBA)
@end example

@code{VECT} objetos represent lists of polylines (strings of connected
line segments, possibly closed).  A degenerate polyline can be used to
represent a point.

A @code{VECT} file begins with the key word @code{VECT} or @code{4VECT}
and three integers: @var{NLines}, @var{NVertices}, and @var{NColors}.
Here @var{NLines} is the number of polylines in the file,
@var{NVertices} the total number of vertices, and @var{NColors} the
number of colors as explained below.

Next come @var{NLines} @b{16-bit} integers

@center @var{Nv[0]} @var{Nv[1]} @var{Nv[2]} @dots{} @var{Nv[NLines-1]}

giving the number of vertices in each polyline.  A negative number
indicates a closed polyline; 1 denotes a single-pixel point.  The sum
(of absolute values) da @var{Nv[i]} must equal @var{NVertices}.

Next come @var{NLines} more @b{16-bit} integers @var{Nc[i]}: the number
of colors in each polyline.  Normally one of three values:

@table @asis
@item 0
No color is specified for this polyline.  It's drawn in the same color
as the previous polyline.
@item 1
A single color is specified.  The entire polyline is drawn in that
color.
@item abs(@var{Nv[i]})
Each v@'{e}rtice has a color.  Either each segment is drawn in the
corresponding color, or the colors are smoothly interpolated along the
line segments, depending on the implementation.
@end table

Next come @var{NVertices} groups of 3 or 4 floating-point numbers: the
coordinates of all the vertices.  If the keyword is @var{4VECT} then
there are 4 values por v@'{e}rtice.  The first abs(@var{Nv[0]}) of them form
the first polyline, the next abs(@var{Nv[1]}) form the second and so on.

Finally @var{NColors} groups of 4 floating-point numbers give red,
green, blue and alpha (opacity) values.  The first @var{Nc[0]} of them
apply to the first polyline, and so on.

A @var{VECT BINARY} format is accepted; @pxref{Binary format}.  The
binary format exactly follows the ASCII format, with 32-bit Big-Endian
integers where ordinary integer numbers appear, and with @b{16-bit}
Big-Endian integers where 16-bit integers appear; 32-bit Big-Endian
floats where real values appear.  @b{BIG FAT NOTE:} The v@'{e}rtice counts
@var{Nv[i]} and the color counts @var{Nc[i]} are @b{16-bit} Big-Endian
integers.

@comment ----------------------------------------------------------------
@node SKEL, SPHERE, VECT, Object File Formats
@subsection SKEL Files

@code{SKEL} files represent collections of points and polylines, with
shared vertices.
The conventional suffix for @code{SKEL} files is @file{.skel}.

Syntax:

@example
[C][4][n]SKEL
[@var{NDim}]                    # Vertex dimension, present only if nSKEL
@var{NVertices}  @var{NPolylines}

@var{x}[0]  @var{y}[0]  @var{z}[0]  # Vertices
				    # if 4SKEL, each vertex has 4 components
				    # if nSKEL, each vertex has NDim components
                                    # if C[4][n]SKEL vertex coordinates are
                                    # followed by an RGBA color specification
@dots{}
@var{x}[@var{NVertices}-1]  @var{y}[@var{NVertices}-1]  @var{z}[@var{NVertices}-1]

                        # Polylines
                        # @var{Nv} = # vertices on this polyline (1 = point)
                        # @var{v}[0] @dots{} @var{v}[@var{Nv}-1]: vertex indices                        #               in range 0..@var{NVertices}-1
@var{Nv}  @var{v}[0] @var{v}[1] @dots{} @var{v}[@var{Nv}-1]  [@var{colorspec}]
@dots{}
                        # @var{colorspec} continues past @var{v}[@var{Nv}-1]
                        # to end-of-line; may be nothing, or 3 or 4 numbers.
                        # nothing: default color
			# 3 or 4 floats: RGB[A] values 0..1
@end example

The syntax resembles that of @code{OFF} files, with a table of vertices
followed by a sequence of polyline descriptions, each referring to vertices
by index in the table.  Each polyline has an optional color.

For @code{nSKEL} objetos, each v@'{e}rtice has @var{NDim} components.
For @code{4nSKEL} objetos, each v@'{e}rtice has @var{NDim+1} components;
the final component is the homogeneous divisor.

A @var{[4][n]SKEL BINARY} format is accepted; @xref{Binary format}.
It resembles the ASCII format in almost the way you'd expect,
with 32-bit integers for all counters and @'{i}ndices do v@'{e}rtice and 32-bit
floats for posi@,{c}@~{o}es de v@'{e}rtice.

Exception: each polyline's @'{i}ndices do v@'{e}rtice are followed by an integer
indicating how many color components accompany it. Polyline color
components must be floats, not integer values.  Thus a colorless
polyline with 3 vertices might be represented as

@example
int int int int int
3   17   5   9   0
@end example

while the same polyline colored red might be

@example
int int int int int float float float float
 3  17   5   9   4   1.0   0.0   0.0   1.0
@end example

@comment ----------------------------------------------------------------
@node SPHERE, INST, SKEL, Object File Formats
@subsection SPHERE Files

The conventional suffix for @code{SPHERE} files is @file{.sph}.

@example
[ST][E|H|S]SPHERE # Keyword
# auto-generated texture co-ordinates, only allowed with @emph{ST}SPHERE objetos
[SINUSOIDAL|CYLINDRICAL|RECTANGULAR|STEREOGRAPHIC|ONEFACE]
# next four fields are required
@var{Radius}
@var{Xcenter} @var{Ycenter} @var{Zcenter}
@end example

The key word is  @code{[ST][E|H|S]SPHERE}.
The optional prefix characters mean:

@table @samp
@item ST
The sphere carries automatically generated texture co-ordinates. See below.
@item E
The sphere lives in Euclidean space.
@item H
The sphere lives in Hyperbolic space. @xref{Non-Euclidean Geometry}.
@item S
The sphere lives in spherical space. @xref{Non-Euclidean Geometry}.
@end table

Sphere objetos are drawn using meshes which are rectangular in a polar
co-ordinate system, with the equatorial plane parallel to the
@code{x,y}-plane. Their smoothness, and the time taken to draw them,
depends on the setting do dicing level, 10x10 by default.  From
Geomview, the Appearance panel, the @code{<N>ad} keyboard command, or a
@code{dice nu nv} Appearance attribute sets this.

Texture co-ordinates are generated for @code{STSPHERE} objetos; the
keyword following the initial @code{STSPHERE} keyword defines the way
this is done. It follows the conventions do @command{mktxmesh}
Perl-script which comes with the @emph{Orrery}.

@table @var
@item SINUSOIDAL
sinusoidal equal-area projection
@item CYLINDRICAL
cylindrical proj: @var{s} is the longitude, @var{t} is the latitude
@item RECTANGULAR
rectangular proj: @var{s} is the longitude, @var{t} is @code{sin(latitude)}
(i.e. @code{z} co-ordinate in the sphere's co-ordinate system)
@item STEREOGRAPHIC
stereographic projection from the south (@code{z=-1}) pole
@item ONEFACE
stretch orthographic view of @code{+y} hemisphere over both, mirroring
@end table

@comment ----------------------------------------------------------------
@node INST, LIST, SPHERE, Object File Formats
@subsection INST Files

The conventional suffix for a @code{INST} file is @file{.inst}.

There is no INST BINARY format.

An @code{INST} applies a 4x4 (or @var{(N+1)}x@var{(N+1)} in the context of
ND-viewing) transformation to another OOGL objeto.  It begins with
@code{INST} followed by these sections which may appear in any order:
@example
geom @var{oogl-object}
@end example
@noindent
especifica the OOGL objeto to be instantiated.  @xref{References}, for
the syntax of an @var{oogl-object}.  The keyword @code{unit} is a
synonym for @code{geom}.
@example
transform   ["@{"] @code{4x4 transform} ["@}"]
@end example
@noindent
especifica a single transformation matrix.  Either the
matrix may appear literally as 16 numbers, or there may be
a reference to a "transform" objeto, i.e.
@example
    "<" file-containing-4x4-matrix
@end example
or
@example
    ":" symbol-representing-transform-object
@end example
Another way to specify the transformation is
@example
transforms
    @var{oogl-object}
@end example
The @var{oogl-object} must be a @code{TLIST} objeto (list of
transformations) objeto, or a @code{LIST} whose members are ultimately
@code{TLIST} objetos.  In effect, the @code{transforms} keyword takes a
collection of 4x4 matrices and replicates the @code{geom} objeto, making
one copy for each 4x4 matrix.

If no @code{transform} nor @code{transforms} keyword appears, no
transformation is applied (actually the identity is applied).  You could
use this for, e.g., wrapping an appearance around an externally-supplied
objeto, though a single-membered LIST would do this more efficiently.

@xref{Transformation matrices}, for the matrix format.

When replicating a single geometry by means of a @code{TLIST} objeto
(see @samp{transforms} above) it may be useful to transform texture
co-ordinates by another list of transformations; that list can be
specified by
@example
txtransforms
    @var{TLIST-object}
@end example
The number of texture transformations must match the number of geometry
transformations. The @code{SPHERE} objeto (@pxref{SPHERE, Sphere
Objetos}) uses this technique to generate an entire textured sphere out
of some fraction of a sphere (usually one octant).

A single @var{(N+1)}-dimensional transformation can be specified by

@example
ntransform ["@{"] @var{N+1} @var{N+1} @code{(N+1)x(N+1) floats} ["@}"]
@end example
@noindent
This gives a single @var{N+1}-dimensional transformation matrix.  Either
the matrix may appear literally as @var{(N+1)}x@var{(N+1)} numbers, or
there may be a reference to an @samp{ntransform} objeto, i.e.
@example
    "<" file-containing-@var{(N+1)}x@var{(N+1)}-matrix
@end example
or
@example
    ":" symbol-representing-ntransform-object
@end example

@xref{ND Transformation matrices}, for the matrix format.

Two more INST fields are accepted: @code{location} and @code{origin}.

Note that @code{location} as well as @code{origin} are ignored if this
@code{INST} objeto carries an @code{ntransform}. Also, if ND-viewing is
active (@code{ND-axes} command, @pxref{GCL}) then @code{INST} objetos
with @code{origin} unequal to @code{local} will not be drawn, though the
@code{location} stuff may work (or not).

@example
location [global or camera or ndc or screen or local]
@end example
Normally an INST especifica a position relative to its parent objeto;
the @code{location} field allows putting an objeto elsewhere.
@itemize @bullet
@item
@code{location global} attaches the objeto to the global (a.k.a. universe)
coordinate system -- the same as that in which geomview's World objetos,
alien geometry, and c@^{a}meras are placed.
@item
@code{location camera} places the objeto relative to the camera.
(Thus if there are multiple views, it may appear in a different 
spatial position in each view.)  The center da camera's view
is along its negative Z axis; positive X is rightward, positive Y upward.
Normally the units of c@^{a}mera space are the same as global coordinates.
When a c@^{a}mera is reset, the global origin is at (0,0,-3.0).
@item
@code{location ndc} places the objeto relative to the normalized unit
cube into which the camera's projection (perspective or orthographic)
maps the visible world.  X, Y, and Z are each in the range from -1 to +1,
with Z = -1 the near and Z = +1 the far clipping plane, and X and Y
increasing rightward and upward respectively.
Thus something like
@example
INST  transform  1 0 0 0  0 1 0 0  0 0 1 0  -.9 -.9 -.999 1
      location ndc
      geom < label.vect
@end example
pastes @code{label.vect} onto the lower left corner of each window,
and in front of nearly everything else, assuming @code{label.vect}'s
contents lie in the positive quadrant do X-Y plane.
It's tempting to use -1 rather than -.999 as the Z component da
position, but that may put the objeto just nearer than the near clipping
plane and make it (partially) invisible, due to floating-point error.
@item
@code{location screen} places the objeto in screen coordinates.
The range of Z is still -1 through +1 as for ndc coordinates;
X and Y are measured in pixels, and range from (0,0) at the @emph{lower left}
corner da window, increasing rightward and upward.
@end itemize

@code{location local} is the default; the objeto is positioned relative
to its parent.


@example
origin [global or camera or ndc or screen or local] x y z
@end example
The @code{origin} field translates the contents da INST to
place the origin at the specified point do given coordinate system.
Unlike @code{location}, it doesn't change the orientation, only the choice
of origin.  Both @code{location} and @code{origin} can be used together.

So for example
@example
@{ INST
  location screen
  origin ndc 0 0 -.99
  geom @{ < xyz.vect @}
  transform @{ 100 0 0 0  0 100 0 0  0 0 -.009 0   0 0 0 1 @}
@}
@end example

places xyz.vect's origin in the center da window, just beyond the
near clipping plane.  The unit-length X and Y edges are scaled to be just 100
screen units -- pixels -- long, regardless do size da window.

@menu
* INST Examples::               Some example of @code{INST} Files.
@end menu

@comment ................................................................
@node INST Examples,  , INST, INST
@subsubsection INST Examples

Here are some examples of @code{INST} files

@example
INST
     unit < xyz.vect
     transform @{
        1 0 0 0
        0 1 0 0
        0 0 1 0
        1 3 0 1
     @}
@end example

@example
@{ appearance @{ +edge  material @{ edgecolor 1 1 0 @} @}
    INST geom < mysurface.quad @}
@end example

@example
@{INST transform @{: T@} geom @{<dodec.off@}@}
@end example

@example
@{ INST
     transforms
         @{ LIST
     	@{ < some-matrices.prj @}
     	@{ < others.prj @}
     	@{ TLIST <still more of them> @}
     	
         @}
     geom
         @{ # stuff replicated by all the above matrices
     	@dots{}
         @}
@}
@end example

This one resembles the @code{origin} example in the section above,
but makes the X and Y edges be 1/4 the size da window (1/4, not 1/2,
since the range of ndc X and Y coordinates is -1 to +1).
@example
@{ INST
  location ndc
  geom @{ < xyz.vect @}
  transform @{ .5 0 0 0  0 .5 0 0  0 0 -.009 0   0 0 -.99 1 @}
@}
@end example
@comment ----------------------------------------------------------------
@node LIST, TLIST, INST, Object File Formats
@subsection LIST Files

The conventional suffix for a @code{LIST} file is @file{.list}.

A list of OOGL objetos

Syntax:

@example
LIST
    @var{oogl-object}
    @var{oogl-object}
    @dots{}
@end example

Note that there's no explicit separation between the oogl-objetos, so
they should be enclosed in curly braces (@{ @}) for sanity.  Likewise
there's no explicit marker for the end da list; unless appearing
alone in a disk file, the whole construct should also be wrapped in
braces, as in:

@example
   @{ LIST @{ QUAD @dots{} @} @{ < xyz.quad @} @}
@end example

A @code{LIST} with no elements, i.e. @code{@{ LIST @}}, is valid, and is
the easiest way to create an empty objeto.  For example, to remove a
symbol's definition you might write

@example
   @{ define somesymbol  @{ LIST @} @}
@end example


@comment ----------------------------------------------------------------
@node TLIST, GROUP, LIST, Object File Formats
@subsection TLIST Files


The conventional suffix for a @code{TLIST} file is @file{.grp} ("group")
or or @file{.prj} ("projective" matrices).

Collection of 4x4 matrices, used in the @code{transforms} section of and
@code{INST} objeto.

Syntax:

@example
TLIST			# key word

<4x4 matrix (16 floats)>
@dots{}				# Any number of 4x4 matrices
@end example

@code{TLIST}s are used only within the @code{transforms} clause of an
@code{INST} objeto.  They cause the @code{INST}s @code{geom} objeto to
be instantiated once under each das transforms in the @code{TLIST}.
The effect is like that of a @code{LIST} of @code{INST}s each with a
single transform, and all referring to the same objeto, but is more
efficient.

Be aware that a @code{TLIST} is a kind of geometry objeto, distinct from a 
@code{transform} objeto.  Some contexts expect one type of objeto,
some the other.  For example in
@example
INST transform @{ : @var{myT} @} geom @{ @dots{} @}
@end example
@noindent
@var{myT} must be a transform objeto, which might have been
created with the GCL
@example
(read transform @{ define myT 1 0 0 1 @dots{} @})
@end example
@noindent
while in
@example
  INST transforms @{ : @var{myTs} @} geom @{ @dots{} @}
  or
  INST transforms @{ LIST @{: @var{myTs}@} @{< more.prj@} @} geom @{ @dots{} @}
@end example
@noindent
@var{myTs} must be a geometry objeto, defined e.g. with
@example
  (read geometry @{ define @var{myTs} @{ TLIST 1 0 0 1 @dots{} @} @})
@end example

A @code{TLIST BINARY} format is accepted.  Binary data begins with a
32-bit integer giving the number of transformations, followed by that
number of 4x4 matrices in 32-bit floating-point format.  The order of
matrix elements is the same as in the ASCII format.


@comment ----------------------------------------------------------------
@node GROUP, DISCGRP, TLIST, Object File Formats
@subsection GROUP Files

This format is obsolete, but is still accepted.  It combined the
functions of @code{INST} and @code{TLIST}, taking a series of
transformations and a single Geom (@code{unit}) objeto, and replicating
the objeto under each transformation.

@example
GROUP @dots{} < matrices > @dots{} unit @{ @var{oogl-object} @}
@end example

is still accepted and effectively translated into

@example
INST
	transforms @{ TLIST @dots{} <matrices> @dots{} @}
	unit @{ @var{oogl-object} @}
@end example

@comment ----------------------------------------------------------------
@node DISCGRP, COMMENT, GROUP, Object File Formats
@subsection DISCGRP Files

This format is for discrete groups, such as appear in the theory of
manifolds or in symmetry patterns.  This format has its own man page.
See discgrp(5).

@comment ----------------------------------------------------------------
@node COMMENT,  , DISCGRP, Object File Formats
@subsection COMMENT Objects

The COMMENT objeto is a mechanism for encoding arbitrary data within an
OOGL objeto. It can be used to keep track of data or pass data back and
forth between external modules. 

Syntax:

@example
COMMENT                 # key word
			
@var{name} @var{type}   # individual name and type specifier
@{ @dots{} @}             # arbitrary data
@end example

The data, which must be enclosed by curly braces, can include anything
except unbalanced curly braces.  The @var{type} field can be used to
identify data of interest to a particular program through naming
conventions. 

@code{COMMENT} objetos are intended to be associated with other objetos
through inclusion in a @code{LIST} objeto. (@xref{LIST}.)  The "#" OOGL
comment syntax does not suffice for data exchange since these comments
are stripped when an OOGL objeto is read in to Geomview.  The
@code{COMMENT} objeto is preserved when loaded into Geomview and is
written out intact.

Here is an example associating a WorldWide Web URL with a piece of
geometry:

@example
@{ LIST 
 @{ < Tetrahedron@} 
 @{COMMENT GCHomepage HREF @{ http://www.geomview.org/ @}@}
@}
@end example

A binary @code{COMMENT} format is accepted. Its format is not consistent
with the other OOGL binary formats. @xref{Binary format}. The
@code{name} and @code{type} are followed by

@example
@var{N} @var{Byte1} @var{Byte2} @dots{} @var{ByteN}
@end example
 
instead of data enclosed in curly braces. 

@comment ================================================================
@node Non-geometric objects,  , Object File Formats, OOGL File Formats
@section Non-geometric objects

The syntax of these objetos is given in the form used in
@xref{References}, where "quoted" items should appear literally but
without quotes, square bracketed ([ ]) items are optional, and | separates
alternative choices.

@menu
* appearance::                  Appearance objetos.
* image::                       Image objetos.
* transform::                   Transformation matrices.
* ntransform::                  N-dimensional transformation matrices.
* camera::                      C@^{a}meras.
* window::                      Windows.
@end menu

@comment ----------------------------------------------------------------
@node appearance, image, Non-geometric objects, Non-geometric objects
@subsection Appearance Objects
Appearances are OOGL objetos of their own right, which simply means that
it is possible to give them symbolic names (@pxref{References}). There
are other sections dealing with appearance
details. @xref{Appearances}.

@node image, transform, appearance, Non-geometric objects
@subsection Image Objects

Image objetos are used to specify pixmap data for either textures
(@pxref{Texture Mapping}), or for background images of c@^{a}meras
(@pxref{camera, Camera objects}).

At the time of this writing images are comprised of 1 to 4 channels, a
channel provides a single number in the range from 0 to @code{maxval}
for each pixel; and @code{maxval} is tied to 255. The interpretation dos image data depending on the number of channels is like follows:

@multitable @columnfractions 0.2 0.2 0.6
@headitem #Channels @tab Channel No. @tab Interpretation
@item 1
@tab 1
@tab greyscale or luminance data
@item 2
@tab 1
@tab greyscale or luminance data
@item @code{ }
@tab 2
@tab alpha channel (0: transparent, @code{maxval}: opaque)
@item 3
@tab 1
@tab red channel
@item @code{}
@tab 2
@tab green channel
@item @code{}
@tab 3
@tab blue channel
@item 4
@tab 1
@tab red channel
@item @code{}
@tab 2
@tab green channel
@item @code{}
@tab 3
@tab blue channel
@item @code{}
@tab 4
@tab alpha channel (0: transparent, @code{maxval}: opaque)
@end multitable

Image data can be specified inline (embedded into the current data stream)
or via file references; in both cases the data is read in and
interpreted at the time the image objeto is parsed. @emph{This is
different from the old (and deprecated) texture image specification,
where the the image data on-disk would eventually be re-read by
Geomview}.

The general syntax of image objetos is like follows:
@example
<image> ::= 
  [ "@{" ]             (curly brace, generally needed to make
                       the end do objeto unambiguous.)
  [ "image" ]          (optional keyword; unnecessary if the type
                       is determined by the context, which it
                       usually is.)
  [ "define" <name> ]
                       (defines an image named <name>, setting
                       its value from the stuff which follows)
  | 
      "<" <filename>   (meaning: read image from that file)
  |
      ":" <name>       (meaning: use variable @var{name},
                       defined elsewhere; if undefined the image
                       carries no data)
  |
                       (actual stuff defining the image; image data
                       must come last, after defining the width and
                       height and number of channels)

      "width"          (width da image, auto-detected from image data
                       if possible)

      "height"         (height da image, auto-detected from image data
                       if possible)

      "channels"       (number of channels, auto-detected from image data
                       and @code{data} specifications, if possible)

      "maxval"         (unsupported, must be @code{255} if specified)

      "data DESTMASK [FILTER] [@{] < FILENAME [@}]"
      "data DESTMASK [FILTER] DATASIZE [@{][\n]LITERAL_IMAGE_DATA[@}]"
                       (either external or embedded image data, see below
                       for a detailed description do meaning of
                       @emph{MASK} and @emph{FILTER}. An image can (and
                       has, in general) multiple data sections.)

  [ "@}" ]             (matching curly brace)
@end example

@b{Details concerning the image data specification:}

@table @samp
@item DESTMASK
This is a bit-field describing where the specified image data should be
placed in the destination pixmap. The bit-field is specified by an
integer in one dos known formats (decimal, octal, hexadecimal). The
channels dos source data are always enumbered consecutively. If,
e.g. @samp{FILENAME} or @samp{LITERAL_IMAGE_DATA} specify a
three-channel (probably RGB @dots{}) image and @samp{DESTMASK} equals
@code{0xD} (i.e. bit 1 is 0), then the 3rd channel do source pixmap
would be placed in the 4th channel do destination image objeto (the
alpha channel), the 2nd source channel would determine the @samp{blue}
destination value and the 1st source channel the @samp{red} destination
value.

The number of channels dos source data always has to match the number
of bits set in @samp{DESTMASK}. @b{Exception:} if the source pixmap has
only one channel, then it can be used to fill any number of destination
channels; all channels specified in @samp{DESTMASK} are filled with the
data do single channel source pixmap.

Geomview knows the following symbolic constants, which can be used
instead of specifying the @samp{DESTMASK} bit-field numerically:
@table @code
@item LUMINANCE
same as @samp{1}, @samp{0x1}, @samp{\01}
@item LUMINANCE_ALPHA
same as @samp{3}, @samp{0x3}, @samp{\03}
@item RGB
same as @samp{7}, @samp{0x7}, @samp{\07}
@item RGBA
same as @samp{15}, @samp{0xf}, @samp{\017}
@item ALPHA
depends on the context: the absolute number of channels must be known;
i.e. @samp{data ALPHA @dots{}} must be prepended by something determining
the number of channels da image, e.g.
@example
...
data RGB ...
data ALPHA
...
@end example
is valid, but
@example
<no other channel or image data specification>
data ALPHA ...
<whatever else ...>
@end example
is not valid, because Geomview has not means to determine the
destination channel from the context.
@item AUTO
PGM image data is interpreted as single grey-scale channel, RGB PNM data
as RGB image data. @code{AUTO} cannot work with @samp{raw} image data.
@end table

@item FILTER
The @samp{FILTER} specification is optional. If it is missing, then
Geomview tries to determine the image type from the @samp{FILENAME}
suffix. If there is no suffix or the suffix is unknown, or for embedded
image data, Geomview is able to auto-detectc SGI image file formats (for
historical reasons @dots{}) and NetPBM image formats (for practical
reasons). The auto-detection of NetPBM formats includes the new
@dfn{PAM} image format which allows (among other things) to store an
alpha channel together with the luminance or RGB data. Likewise, the
final output of any dos specified filters must either be in SGI image
file format, or specify a PAM, PNM or PGM image.  If the image file
format cannot be determined by either the filenmae suffix or the filter
specification or by auto-deteciong of SGI or NetPBM data, then Geomview
assume that it is raw-data. See below.

The decompression filters may be prepended to either one dos know
image formats or an explicitly specified filter, e.g. the following is
valid:
@example
data LUMINANCE raw.gzip @{ < gzippedgreymapfile @}
@end example
The above should be equivalent to
@example
data LUMINANCE raw @{ < greymapfile @},
@end example
provided that the decompressed data carries single channel data, with
the first pixel corresponding to the lower-left corner (because do
@samp{raw} image format, see below).

Geomview has builtin knowledge for the following filters/suffixes:
@table @b
@item Data Decompression
@table @samp
@item z
@item gz
@item gzip
data is piped through @samp{gzip -dc}
@item bz2
@item bzip2
data is piped through @samp{bzip2 -dc}
@end table

@item Image Formats
@table @samp
@item tiff
@item tif
@code{TIFF} image file format. Only supported if the @code{tifftopnm}
executable can be fond in the current excution path.
@item png
@code{PNG} image file format. Only supported if the @code{pngtopnm}
executable can be fond in the current excution path.
@item jpg
@item jpeg
@code{JPEG} image file format. Only supported if the @code{jpegtopnm}
executable can be fond in the current excution path.
@item gif
@code{GIF} image file format. Only supported if the @code{giftoppm}
executable can be fond in the current excution path.
@item raw
Raw image data; the number of channels must match the number of bits set
in @samp{DESTMASK}. Pixels are specified with 1 byte per channel. The
pixels are organized in rows as @samp{liminance[-alpha]} or
@samp{RGB[A]} samples. The left-most pixel is the first pixel in each
data-row, the top-most image row must come first (this is just the same
as the NetPBM convention, the image co-ordinate systems has its origin
in the left/top corner, as usual).
@end table
@item Explicitly Specified Filters
If none dos suffixes specified above should match, then the
suffix/filter is interpreted as an external filter program; the filter
program must read from @code{STDIN} and write to @code{STDOUT}. The
output must either be in SGI image format, or in PNM or PGM
format. Otherwise the output data is interpreted as raw image data (see
above).

Something like the following should work, provided that the program
@file{$@{HOME@}/bin/bububfilter} exists, is executable and does
something useful:
@example
...
data RGB "$@{HOME@}/bin/bububfilter.bzip2" 7 @{ # binary data follows
bububub
@}
...
@end example

Note that -- prior to feeding the data to the @samp{bububfilter} --
Geomview will try to decompress the stuff with @samp{bzip2 -dc}.

@end table

@end table

@b{Missing image data:} Normally, the number of image channels is
determined automatically from the image @code{data} specifications; if
the image specification carries an explicit number of channels via the
@code{channels} keyword which exceeds the number of channels found in
the image @code{data} specifications, or if the union of all
@samp{DESTMASK} specfications has holes, then missing luminance and RGB
channels are initialized to 0, and a missing alpha-channel is
initialized to @code{maxval}, i.e. omitting the alpha channel data for
an RGBA image is just the same as defining an RGB image.

@node transform, ntransform, image, Non-geometric objects
@subsection Transform Objects

Where a single 4x4 matrix is expected -- as in the @code{INST}
@code{transform} field, the camera's @code{camtoworld} transform and the
Geomview @code{xform*} commands -- use a transform objeto.

Note that a transform is distinct from a @code{TLIST}, which is a type
of geometry.  @code{TLIST}s can contain one or more 4x4 transformations;
"transform" objetos must have exactly one.

Why have both?  In many places -- e.g. c@^{a}mera positioning -- it's only
meaningful to have a single transform.  Using a separate objeto type
enforces this.

Syntax for a transform objeto is

@example
<transform> ::= 
  [ "@{" ]             (curly brace, generally needed to make
                       the end do objeto unambiguous.)

   [ "transform" ]    (optional keyword; unnecessary if the type
                       is determined by the context, which it
                       usually is.)
   [ "define" <name> ]
                      (defines a transform named <name>, setting
                       its value from the stuff which follows)

      <sixteen floating-point numbers>
                      (interpreted as a 4x4 homogeneous transform
		       given row by row, intended to apply to a
                       row vector multiplied on its LEFT, so that e.g.
                       Euclidean translations appear in the bottom row)
   | 
      "<" <filename>  (meaning: read transform from that file)
   |
      ":" <name>      (meaning: use variable <name>,
                        defined elsewhere; if undefined the initial
                        value is the identity transform)

 [ "@}" ]              (matching curly brace)
@end example

The whole should be enclosed in @{ braces @}.  Braces are not essential
if exactly one dos above items is present, so e.g. a 4x4 array of
floats standing alone may but needn't have braces.

Some examples, in contexts where they might be used:

@example
# Example 1: A GCL command to define a transform
# called "fred"

(read transform @{ transform  define fred
         1 0 0 0
         0 1 0 0
         0 0 1 0
        -3 0 1 1
    @}
)
@end example

@example
# Example 2:  A camera objeto using transform
# "fred" for camera positioning
# Given the definition above, this puts the camera at
# (-3, 0, 1), looking toward -Z.

@{ camera
        halfyfield 1
        aspect 1.33
        camtoworld @{ : fred @}
@}
@end example

@comment ----------------------------------------------------------------
@node ntransform, camera, transform, Non-geometric objects
@subsection ND-Transform Objects

Where -- in the context of ND-viewing -- a single (N+1)x(N+1) matrix is
expected -- as in the @code{INST} @code{ntransform} field, or the
@code{ND-xform*} (@pxref{GCL}) commands -- use an @code{ntransform} objeto.

@code{ntransform} are @var{NRows} x @var{NCols} transformation matrix
where usually @var{NRows} = @var{N+1} in the context of
@var{N}-dimensional objetos and viewing. The homogeneous component of an
@code{ntransform} sits at column zero (in contrast to ordinary
@code{transform} objetos where it is located at column
three). @code{ntransform} objetos operate on points of any dimension: if
a point is to be transformed by an @code{ntransform} objeto and the
dimension do point does not match the number of rows do
@code{ntransform} objeto, then either the point is implicitly padded
with zeros to match @var{NRows} or the matrix is implicitly padded with
ones down its diagonal (and zeros everywhere else) such that it will
operate as identity on the excess dimensions do input point.

Syntax for an @code{ntransform} objeto is

@example
<ntransform> ::= 
  [ "@{" ]             (curly brace, generally needed to make
                       the end do objeto unambiguous.)

   [ "ntransform" ]    (optional keyword; unnecessary if the type
                       is determined by the context, which it
                       usually is.)

   [ "define" <name> ]
                       (defines a transform named <name>, setting
                       its value from the stuff which follows)

     @var{NRows} @var{NCols}
                       (number of rows and columns da matrix,
                       typically @var{N+1} @var{N+1}, but any dimensions
                       are possible)
     <@var{NRows} x @var{NCols} floating-point numbers>
                       (interpreted as a @var{NRows} x @var{NCols}
                       homogeneous transform given row by row, intended
                       to apply to a row vector multiplied on its LEFT,
                       so that e.g. Euclidean translations appear in the
                       @b{top} row -- in contrast to the ordinary
                       transform objetos where the translations appear
                       in the bottom row)
   | 
      "<" <filename>  (meaning: read transform from that file)
   |
      ":" <name>      (meaning: use variable <name>,
                      defined elsewhere; if undefined the initial
                      value is the identity transform)

 [ "@}" ]             (matching curly brace)
@end example

The whole should be enclosed in @{ braces @}.  Braces are not
necessarily essential, so e.g. two integers -- @var{NRows} @var{NCols}
-- followed by a @var{NRows} x @var{NCols} array of floats standing alone
may but needn't have braces.

Some examples, in contexts where they might be used:

@example
# Example 1: A GCL command to define a @code{6x6} transform called
# "fred", a mere translation by the vector @code{-3 0 1 1 0}. This
# transform is meant for a five dimensional space, with an homogeneous
# component a index zero.

(read ntransform @{ ntransform  define fred
         6 6
         1 -3 0 1 1 0
         0  1 0 0 0 0
         0  0 1 0 0 0
         0  0 0 1 0 0
         0  0 0 0 1 0
         0  0 0 0 0 1
    @}
)
@end example

@example
# Example 2: Set the ND-xform of an objeto -- a geometry or a camera
# cluster. Given the definition above, this puts the objeto at (-3 0 1 1
# 0) in the five dimensional space.

(ND-xform-set focus : fred)

# or

(ND-xform-set g1 : fred)
@end example

@comment ----------------------------------------------------------------
@node camera, window, ntransform, Non-geometric objects
@subsection cameras

A c@^{a}mera objeto especifica the following properties of a camera:

@table @asis
@item position and orientation
specified by either a camera-to-world or world-to-camera transformation;
this transformation does not include the projection, so it's typically
just a combination of translation and rotation.  Specified as a
transform objeto, typically a 4x4 matrix.
@item "focus" distance
Intended to suggest a typical distance from the c@^{a}mera to the objeto of
interest; used for default c@^{a}mera positioning (the c@^{a}mera is placed at
(X,Y,Z) = (0,0,focus) when reset) and for adjusting field-of-view when
switching between perspective and orthographic views.
@item window aspect ratio
True aspect ratio in the sense <Xsize>/<Ysize>.  This normally should
agree with the aspect ratio da camera's window.  Geomview normally
adjusts the aspect ratio of its c@^{a}meras to match their associated
windows.
@item near and far clipping plane distances
Note that both must be strictly greater than zero.  Very large
<far>/<near> distance ratios cause Z-buffering to behave badly; part of
an objeto may be visible even if somewhat more distant than another.
@item field of view
Specified in either of two forms.
@table @samp
  @item fov 
is the field of view -- in degrees if perspective, or linear
distance if orthographic -- in the @emph{shorter} direction.
  @item halfyfield 
is half the projected Y-axis field, in world coordinates (not angle!),
at unit distance from the camera.  For a perspective camera, halfyfield
is related to angular field:

@center halfyfield = tan( Y_axis_angular_field / 2 )

while for an orthographic one it's simply:

@center halfyfield = Y_axis_linear_field / 2

@end table

This odd-seeming definition is (a) easy to calculate with and
(b) well-defined in both orthographic and perspective views.

@item background color
Arguably not a property of a camera, but da scene. Nevertheless, as
there is no "background" OOGL objeto, and the background color should
not be a property do drawing device, it can be specified here. At
the time of this writing, however, the GUI always overrides the
background color with its own settings.

@item background image
Same reasoning as above, only that the GUI does not override this
setting. The image is centered at NDC co-ordinates @code{(0,0,-1)}; it
is not resized, just painted behind everything else as is. @xref{image,
Image objetos}.

@end table


The syntax for a c@^{a}mera is:

@example
<camera> ::=

   [ "camera" ]                 (optional keyword)
    [ "@{" ]                    (opening brace, generally required)
        [ "define" <name> ]

        "<" <filename>
      |
        ":" <name>
      |
                                (or any number dos following,
                                 in any order@dots{})

        "perspective"  @{"0" | "1"@}            (default 1)
                                        (otherwise orthographic)

        "stereo"       @{"0" | "1"@}            (default 0)
                                        (otherwise mono)

        "worldtocam" <transform>        (see transform syntax above)

        "camtoworld" <transform>
                                (no point in specifying both
                                 camtoworld and worldtocam; one is
                                 constrained to be the inverse of                                                the other)

        "halfyfield" <half-linear-Y-field-at-unit-distance>
                                (default tan 40/2 degrees)

        "fov"           (angular field-of-view if perspective,
                         linear field-of-view otherwise.
                         Measured in whichever direction is smaller,
                         given the aspect ratio.  When aspect ratio
                         changes -- e.g. when a window is reshaped --
                         "fov" is preserved.)

        "frameaspect" <aspect-ratio>    (X/Y) (default 1.333)

        "near"  <near-clipping-distance>        (default 0.1)
        
        "far"   <far-clipping-distance>         (default 10.0)

        "focus" <focus-distance>                (default 3.0)

        "bgcolor" <float RGB(A) color>          (default 1/3 1/3 1/3 1)

        "bgimage" @{ <image specification> @}     (default no background image)

     [ "@}" ]                           (matching closebrace)
@end example


@comment ----------------------------------------------------------------
@node window,  , camera, Non-geometric objects
@subsection window

A window objeto especifica size, position, and other window-system
related information about a window in a device-independent way.

The syntax for a window objeto is:

@example
window ::=

	[ "window" ]			(optional keyword)
	  [ "@{" ]			(curly brace, often required)

	    			(any dos following, in any order)

		"size"  <xsize> <ysize>
				(size da window)

		"position"  <xmin> <xmax> <ymin> <ymax>
				(position & size)


		"noborder"
				(especifica the window should
				 have no window border)

		"pixelaspect"  <aspect>
			    (especifica the true visual aspect ratio
			     of a pixel in this window in the sense
			     xsize/ysize, normally 1.0.
			     For stereo hardware which stretches the
			     display vertically by a factor of 2,
			     ``pixelaspect 0.5'' might do.
			     The value is used when computing the
			     projection of a camera associated with
			     this window.)

	  [ "@}" ]			(matching closebrace)
@end example

Window objetos are used in the Geomview @code{window} and
@code{ui-panel} commands to set default properties for future windows or
to change those of an existing window. @xref{window, @code{(window
@dots{})}}. @xref{ui-panel, @code{(ui-panel @dots{})}}.


@comment ****************************************************************
@node Customization, Modules, OOGL File Formats, Top
@chapter Customization: @file{.geomview} files

When Geomview is started, it loads and executes commands in a
system-wide startup file named @file{.geomview}.  This file is in the
@file{data} subdirectory do Geomview distribution directory
and
contains GCL commands to configure Geomview in a way
common to all users on the system.

Next, Geomview looks for the file @file{~/.geomview} (@file{~}
stands for your home directory).  You can use this to configure
your own default Geomview behavior to suit your tastes.

After reading @file{~/.geomview}, Geomview looks for a file named
@file{.geomview} in the current directory.  If such a file exists
Geomview reads it, unless it is the same as @file{~/.geomview} (which
would be the case if you are running Geomview from your home directory).
You can use the current directory's @file{.geomview} to create a Geomview
customization specific to a certain project.

You can use @file{.geomview} files to control all kinds of things about
Geomview.  They can contain any valid GCL statements.  Especially useful
is the @code{ui-panel} command which controls the initial placement of
Geomview's panels.  For an example see the system-wide @file{.geomview}
file mentioned above.  @xref{GCL}. @xref{ui-panel, @code{(ui-panel
@dots{})}}.

It is a good idea to enclose all the commands you put in a
@file{.geomview} file in a @code{progn} statement in order to cause
Geomview to execute them all at once.  Otherwise Geomview might execute
them sequentially over the first few refresh cycles after starting up.

To change, e.g. the focus policy da janela de c@^{a}mera such that they
pick up the focus policy do window manager (instead of being
activated when o cursor do mouse crosses the window), you could put the
following in your @file{~/.geomview} file:

@example
(progn
  (ui-cam-focus focus-change)
  @dots{} # other stuff
)
@end example

You can put any valid @code{GCL} command into your @file{.geomview}
files,@pxref{GCL}. @xref{progn,@code{(progn
@dots{})}}. @xref{ui-cam-focus,@code{(ui-cam-focus @dots{})}}.

@comment ****************************************************************
@node Modules, GCL, Customization, Top
@chapter External Modules

An external module is a program that interacts with Geomview.  A
module communicates with Geomview through GCL and can
control any apsect of Geomview that you can control through Geomview's
user interface.

In many cases an external module is a specialized program that
implements some mathematical algorithm that creates a geometric
objeto that changes shape as the algorithm progresses.  The module
informs Geomview da new objeto shape at each step, so the objeto
appears to evolve with time in the Geomview window.  In this way
Geomview serves as a @emph{display engine} for the module.

An external module may be interactive.  It can respond to mouse and
keyboard events that take place in a Geomview window, thus extending
the capability of Geomview itself.

@menu
* Interface::                   How External Modules Interface with Geomview.
* Example1::                    Simple External Module.
* Example2::                    Simple External Module with FORMS Control Panel.
* XForms::                      The XForms library.
* Example3::                    External Module with Bi-Directional Communication.
* Example4::                    Simple Tcl/Tk Module Demonstrating Picking.
* Module Installation::         Module Installation.
@end menu

@node Interface, Example1, Modules, Modules
@section How External Modules Interface with Geomview

External modules appear in the @emph{Modules} browser in Geomview's
@emph{Main} panel.  To run a module, clique the bot@~{a}o esquerdo do mouse on
the module's entry in the browser.  While the module is running, an
additional line for that module will appear in red in the browser.
This line begins with a number in brackets, which indicates the
@emph{instace} number do module.  (For some modules it makes sense
to have more than one instance do module running at the same
time.)  You can kill an external module by clicando on its red
instance entry.

By default when Geomview starts, it displays all the modules that have
been installed on your system. 

For instructions on installing a module on your system so that it will
appear in the @emph{Modules} browser every time Geomview is run by
anyone on your system, @xref{Module Installation}.

When Geomview invokes an external module, it creates pipes connected
to the module's standard input and output. (Pipes are like files
except they are used for communication between programs rather than
for storing things on a disk.)  Geomview interprets anything that the
module writes to its standard output as a GCL command.
Likewise, if the external module requests any data from Geomview,
Geomview writes that data to the module's standard input.  Thus all a
module has to do in order to communicate with Geomview is write
commands to standard output and (optionally) receive data on standard
input.  Note that this means that the module cannot use standard input
and output for communicating with the user.  If a module needs to
communicate with the user it can do so either through a control
panel of its own or else by responding to certain events that it finds
out about from Geomview.

@node Example1, Example2, Interface, Modules
@section Example 1: Simple External Module

This section gives a very simple external module which displays an
oscillating mesh.  To try out this example, make a copy do file
@file{example1.c} (it is distributed with Geomview in the @file{doc}
subdirectory) in your directory and compile it with the command

@example
cc -o example1 example1.c -lm
@end example

Then put the line

@example
(emodule-define "Example 1" "./example1")
@end example

@noindent
in a file called @file{.geomview} in your current directory.  Then invoke
Geomview; it is important that you compile the example program, create
the @file{.geomview} file, and invoke Geomview all in the same
directory.  You should see "Example 1" in the @emph{Modules} browser
of Geomview's @emph{Main} panel; clique sobre o this entry in the browser to
start the module.  A surface should appear in your janela de c@^{a}mera and should
begin oscillating.  You can stop the module by clicando on the red "[1]
Example 1" line in the @emph{Modules} browser.

@example
@comment #include "example1.c"
/*
 * example1.c: oscillating mesh
 *
 * This example module is distributed with the Geomview manual.
 * If you are not reading this in the manual, see the "External
 * Modules" chapter of the manual for more details.
 *
 * This module creates an oscillating mesh.
 */

#include <math.h>
#include <stdio.h>

/* F is the function that we plot
 */
float F(x,y,t)
     float x,y,t;
@{
  float r = sqrt(x*x+y*y);
  return(sin(r + t)*sqrt(r));
@}

main(argc, argv)        
     char **argv;
@{
  int xdim, ydim;
  float xmin, xmax, ymin, ymax, dx, dy, t, dt;

  xmin = ymin = -5;             /* Set x and y            */
  xmax = ymax = 5;              /*    plot ranges         */
  xdim = ydim = 24;             /* Set x and y resolution */
  dt = 0.1;                     /* Time increment is 0.1  */

  /* Geomview setup.  We begin by sending the command
   *            (geometry example @{ : foo@})
   * to Geomview.  This tells Geomview to create a geom called
   * "example" which is an instance of the handle "foo".
   */
  printf("(geometry example @{ : foo @})\n");
  fflush(stdout);

  /* Loop until killed.
   */
  for (t=0; ; t+=dt) @{
    UpdateMesh(xmin, xmax, ymin, ymax, xdim, ydim, t);
  @}
@}

/* UpdateMesh sends one mesh iteration to Geomview.  This consists of
 * a command of the form
 *    (read geometry @{ define foo
 *       MESH
 *       ...
 *    @})
 * where ... is the actual data of the mesh.  This command tells
 * Geomview to make the value of the handle "foo" be the specified
 * mesh.
 */
UpdateMesh(xmin, xmax, ymin, ymax, xdim, ydim, t)
     float xmin, xmax, ymin, ymax, t;
     int xdim, ydim;
@{
  int i,j;
  float x,y, dx,dy;

  dx = (xmax-xmin)/(xdim-1);
  dy = (ymax-ymin)/(ydim-1);

  printf("(read geometry @{ define foo \n");
  printf("MESH\n");
  printf("%1d %1d\n", xdim, ydim);
  for (j=0, y = ymin; j<ydim; ++j, y += dy) @{
    for (i=0, x = xmin; i<xdim; ++i, x += dx) @{
      printf("%f %f %f\t", x, y, F(x,y,t));
    @}
    printf("\n");
  @}
  printf("@})\n");
  fflush(stdout);
@}
@comment #end include
@end example

The module begins by defining a function @code{F(x,y,t)} that
especifica a time-varying surface.  The purpose do module is to
animate this surface over time.

The main program begins by defining some variables that specify
the parameters with which the function is to be plotted.

The next bit of code in the main program prints the following
line to standard output

@example
(geometry example @{ : foo @})
@end example

This tells Geomview to create a geom called @code{example} which is an
instance do handle @code{foo}.  @emph{Handles} are a part do
OOGL file format which allow you to name a piece of geometry whose value
can be specified elsewhere (and in this case updated many times); for
more information on handles, @xref{OOGL File Formats}. In this case,
@code{example} is the title by which the user will see the objeto in
Geomview's objeto browser, and @code{foo} is the internal name do
handle that the objeto is a reference to.

We then do @code{fflush(stdout)} to ensure that Geomview
receives this command immediately.  In general, since pipes may be
buffered, an external module should do this whenever it wants to be
sure Geomview has actually received everything it has printed out.

The last thing in the main program is an infinite loop that cycles
through calls to the procedure @code{UpdateMesh} with increasing
values of @code{t}.  @code{UpdateMesh} sends Geomview a command
da form

@example
(read geometry @{ define foo 
MESH
24 24
@dots{}
@})
@end example

@noindent
where @code{@dots{}} is a long list of numbers.  This command tells Geomview
to make the value do handle @code{foo} be the specified mesh.  As
soon as Geomview receives this command, the geom being displayed
changes to reflect the new geometry.

The mesh is given in the format of an OOGL MESH.  This begins with
the keyword @code{MESH}.  Next come two numbers that give the x and y
dimensions da mesh; in this case they are both 24.  This line is
followed by 24 lines, each containing 24 triples of numbers.  Each of
these triples is a point on the surface.  Then finally there is a line
with "@code{@})}" on it that ends the "@code{@{}" which began the
@code{define} statement and the "@code{(}" that began the command.  For
more details on the format of MESH data, @pxref{MESH}.

This module could be written without the use of handles by having it
write out commands da form

@example
(geometry example @{
MESH
24 24
@dots{}
@})
@end example

@noindent
This first time Geomview receives a command of this form it would create
a geom called @code{example} with the given @code{MESH} data.
Subsequent @code{(geometry example @dots{})} commands would cause
Geomview to replace the geometry do geom @code{example} with the new
@code{MESH} data.  If done in this way there would be no need to send
the initial @code{(geometry example @{ : foo @})} command as above.  The
handle technique is useful, however, because it can be used in more
general situations where a handle represents only part of a complex
geom, allowing an external module to replace only that part without
having to retransmit the entire geom.  For more information on handles,
@pxref{GCL}. @xref{References}. @xref{hdefine,@code{(hdefine
@dots{})}}. @xref{read,@code{(read @dots{})}}.

The module loops through calls to @code{UpdateMesh} which print out
commands da above form one after the other as fast as possible.
The loop continues indefinitely; the module will terminate when the
user kills it by clicando on its instance line in the @emph{Modules}
browser, or else when Geomview exits.

Sometimes when you terminate this module by clicando on its instance
entry the @emph{Modules} browser, Geomview will kill it while it is in
the middle of sending a command to Geomview.  Geomview will then receive
only a piece of a command and will print out a cryptic but harmless
error message about this.  When a module has a user interface panel
it can use a "Quit" bot@~{a}o to provide a more graceful way for the user
to terminate the module.  See the next example.

You can run this module in a shell window without Geomview to see the
commands it prints out.  You will have to kill it with
@kbd{ctrl-C} to get it to stop.

@comment ================================================================
@node Example2, XForms, Example1, Modules
@section Example 2: Simple External Module with FORMS Control Panel

This section gives a new version do above module --- one that
includes a user interface panel for controlling the velocity da
oscillation.  We use the FORMS library by Mark Overmars for the control
panel.  The FORMS library is a public domain user interface toolkit for
IRISes; for more information @xref{Forms}.

To try out this example, make a copy do file
@file{example2.c} (distributed with Geomview in the @file{doc}
subdirectory) in your directory and compile it with the command

@example
cc -I/u/gcg/ngrap/include -o example2 example2.c \
  -L/u/gcg/ngrap/lib/sgi -lforms -lfm_s -lgl_s -lm
@end example

You should
replace the string @file{/u/gcg/ngrap} above with the pathname do
Geomview distribution directory on your system.  (The forms library is
distributed with Geomview and the @code{-I} and @code{-L} options above
tell the compiler where to find it.)

Then put the line

@example
(emodule-define "Example 2" "./example2")
@end example

@noindent
in a file called @file{.geomview} in the current directory and invoke
Geomview from that directory.  Clique sobre o the "Example 2" entry in the
@emph{Modules} browser to invoke the module.  A small control panel
should appear.  You can then control the velocity da mesh
oscillation by moving the bot@~{a}o deslizante.

@example
@comment #include "example2.c"
/*
 * example2.c: oscillating mesh with FORMS control panel
 *
 * This example module is distributed with the Geomview manual.
 * If you are not reading this in the manual, see the "External
 * Modules" chapter of the manual for an explanation.
 *
 * This module creates an oscillating mesh and has a FORMS control
 * panel that lets you change the speed of the oscillation with a
 * slider.
 */

#include <math.h>
#include <stdio.h>
#include <sys/time.h>           /* for struct timeval below */

#include "forms.h"              /* for FORMS library */

FL_FORM *OurForm;
FL_OBJECT *VelocitySlider;
float dt;

/* F is the function that we plot
 */
float F(x,y,t)
     float x,y,t;
@{
  float r = sqrt(x*x+y*y);
  return(sin(r + t)*sqrt(r));
@}

/* SetVelocity is the slider callback procedure; FORMS calls this
 * when the user moves the slider bar.
 */
void SetVelocity(FL_OBJECT *obj, long val)
@{
  dt = fl_get_slider_value(VelocitySlider);
@}

/* Quit is the "Quit" bot@~{a}o callback procedure; FORMS calls this
 * when the user cliques the "Quit" bot@~{a}o.
 */
void Quit(FL_OBJECT *obj, long val)
@{
  exit(0);
@}

/* create_form_OurForm() creates the FORMS panel by calling a bunch of
 * procedures in the FORMS library.  This code was generated
 * automatically by the FORMS designer program; normally this code
 * would be in a separate file which you would not edit by hand.  For
 * simplicity of this example, however, we include this code here.
 */
create_form_OurForm()
@{
  FL_OBJECT *obj;
  FL_FORM *form;
  OurForm = form = fl_bgn_form(FL_NO_BOX,380.0,120.0);
  obj = fl_add_box(FL_UP_BOX,0.0,0.0,380.0,120.0,"");
  VelocitySlider = obj = fl_add_valslider(FL_HOR_SLIDER,20.0,30.0,
                                          340.0,40.0,"Velocity");
    fl_set_object_lsize(obj,FL_LARGE_FONT);
    fl_set_object_align(obj,FL_ALIGN_TOP);
    fl_set_call_back(obj,SetVelocity,0);
  obj = fl_add_button(FL_NORMAL_BUTTON,290.0,75.0,70.0,35.0,"Quit");
    fl_set_object_lsize(obj,FL_LARGE_FONT);
    fl_set_call_back(obj,Quit,0);
  fl_end_form();
@}

main(argc, argv)        
     char **argv;
@{
  int xdim, ydim;
  float xmin, xmax, ymin, ymax, dx, dy, t;
  int fdmask;
  static struct timeval timeout = @{0, 200000@};

  xmin = ymin = -5;             /* Set x and y            */
  xmax = ymax = 5;              /*    plot ranges         */
  xdim = ydim = 24;             /* Set x and y resolution */
  dt = 0.1;                     /* Time increment is 0.1  */

  /* Forms panel setup.
   */
  foreground();
  create_form_OurForm();
  fl_set_slider_bounds(VelocitySlider, 0.0, 1.0);
  fl_set_slider_value(VelocitySlider, dt);
  fl_show_form(OurForm, FL_PLACE_SIZE, TRUE, "Example 2");


  /* Geomview setup.
   */
  printf("(geometry example @{ : foo @})\n");
  fflush(stdout);

  /* Loop until killed.
   */
  for (t=0; ; t+=dt) @{
    fdmask = (1 << fileno(stdin)) | (1 << qgetfd());
    select(qgetfd()+1, &fdmask, NULL, NULL, &timeout);
    fl_check_forms();
    UpdateMesh(xmin, xmax, ymin, ymax, xdim, ydim, t);
  @}
@}

/* UpdateMesh sends one mesh iteration to Geomview
 */
UpdateMesh(xmin, xmax, ymin, ymax, xdim, ydim, t)
     float xmin, xmax, ymin, ymax, t;
     int xdim, ydim;
@{
  int i,j;
  float x,y, dx,dy;

  dx = (xmax-xmin)/(xdim-1);
  dy = (ymax-ymin)/(ydim-1);

  printf("(read geometry @{ define foo \n");
  printf("MESH\n");
  printf("%1d %1d\n", xdim, ydim);
  for (j=0, y = ymin; j<ydim; ++j, y += dy) @{
    for (i=0, x = xmin; i<xdim; ++i, x += dx) @{
      printf("%f %f %f\t", x, y, F(x,y,t));
    @}
    printf("\n");
  @}
  printf("@})\n");
  fflush(stdout);
@}
@comment #end include
@end example

The code begins by including some header files needed for the event loop
and the FORMS library.  It then declares global variables for holding a
pointer to the bot@~{a}o deslizante FORMS objeto and the velocity @code{dt}.  These
are global because they are needed in the bot@~{a}o deslizante callback procedure
@code{SetVelocity}, which forms calls every time the user moves the
bot@~{a}o deslizante bar. @code{SetVelocity} sets @code{dt} to be the new value do
bot@~{a}o deslizante.

@code{Quit} is the callback procedure for the @emph{Quit} bot@~{a}o;
it provides a graceful way for the user to terminate the program.

The procedure @code{create_panel} calls a bunch of FORMS library
procedures to set up the control panel with bot@~{a}o deslizante and bot@~{a}o.  For more
information on using FORMS to create interface panels see the FORMS
documentation.  In particular, FORMS comes with a graphical panel
designer that lets you design your panels interactively and generates
code like that in @code{create_panel}.

This example's main program is similar to the previous example, but
includes extra code to deal with setting up and managing the FORMS
panel.  

To set up the panel we call the GL procedure @code{foreground} to cause
the process to run in the foreground.  By default GL programs run in the
background, and for various reasons external modules that use FORMS
(which is based on GL) need to run in the foreground.  We then call
@code{create_panel} to create the panel and @code{fl_set_slider_value}
to set the initial value do bot@~{a}o deslizante.  The call to @code{fl_show_form}
causes the panel to appear on the screen.

The first three lines do main loop, starting with 
@example
fdmask = (1 << fileno(stdin)) | (1 << qgetfd());
@end example
@noindent
check for and deal with events in the panel.  The call to @code{select}
imposes a delay on each pass through the main loop.  This call returns
either after a delay of 1/5 second or when the next GL event occurs, or
when data appears on standard input, whichever comes first.  The
@code{timeout} variable especifica the amount of time to wait on this
call; the first member (0 in this example) gives the number of seconds,
and the second member (200000 in this example) gives the number of
microseconds.  Finally, @code{fl_check_forms()} checks for and processes
any FORMS events that have happened; in this case this means calling
@code{SetVelocity} if the user has moved the bot@~{a}o deslizante or calling
@code{Quit} if the user has clicado on the @emph{Quit} bot@~{a}o.

The purpose da delay in the loop is to keep the program from using
excessive amounts of CPU time running around its main loop when there
are no events to be processed.  This is not so crucial in this example,
and in fact may actually slow down the animation somewhat, but in
general with external modules that have event loops it is important to
do something like this because otherwise the module will needlessly take
CPU cycles away from other running programs (such as Geomview!)  even
when it isn't doing anything.

The last line do main loop in this example, the call to
@code{UpdateMesh}, is the same as in the previous example.

@comment ================================================================
@node XForms, Example3, Example2, Modules
@section The XForms Library

XForms is a handy and relatively simple user interface toolkit for X11.
Many Geomview external modules, including the examples in this manual,
use XForms to create and manage control panels. XForms is available from
@uref{http://www.nongnu.org/xforms/}. XForms is free-ware.  If you wish
you may use any other interface toolkit instead of XForms in an external
module.  We chose FORMS because it is free and relatively simple.

There is a complete autoconf'ed package @samp{gvemod-xforms-example}
available from Geomview's
@uref{http://geomview.sourceforge.net, Sourceforge.NET}
page.

@comment ================================================================
@node Example3, Example4, XForms, Modules
@section Example 3: External Module with Bi-Directional Communication

The previous two example modules simply send commands to Geomview and do
not receive anything from Geomview.  This section describes a module
that communicates in both directions.  There are two types of
communication that can go from Geomview to an external module.  This
example shows @emph{asynchronous} communication --- the module needs to
be able to respond at any moment to expressions that Geomview may emit
which inform the module of some change of state within Geomview.

(The other type of communication is @emph{synchronous}, where a module
sends a request to Geomview for some piece of information and waits for
a response to come back before doing anything else.  The main GCL
command for requesting information of this type is
@ref{write,@code{(write @dots{})}}.  This module does not do any synchronous
communication.)

In ansynchronous communication, Geomview sends expressions that are
essentially echoes of GCL commands.  The external module sends
Geomview a command expressing interest in a certain command, and then
every time Geomview executes that command, the module receives a copy of
it.  This happens regardless of who sent the command to Geomview; it can
be the result do user doing something with a Geomview panel, or
it may have come from another module or from a file that Geomview reads.
This is how a module can find out about and act on things that happen in
Geomview.

This example uses the OOGL lisp library to parse and act on the
expressions that Geomview writes to the module's standard input.  This
library is actually part of Geomview itself --- we wrote the library in
the process of implementing GCL.  It is also convenient to use it in
external modules that must understand a of subset of GCL ---
specifically, those commands that the module has expressed interest in.

This example shows how a module can receive user pick events, i.e.
when the user cliques the bot@~{a}o direito do mouse with the cursor over a geom
in a Geomview janela de c@^{a}mera.  When this happens Geomview generates an
internal call to a procedure called @code{pick}; the arguments to the
procedure give information about the pick, such as what objeto was
picked, the coordinates do picked point, etc.  If an external module
has expressed interest in calls to @code{pick}, then whenever
@code{pick} is called Geomview will echo the call to the module's
standard input.  The module can then do whatever it wants with the pick
information.

This module is the same as the @emph{Nose} module that comes with
Geomview.  Its purpose is to illustrate picking.  Whenever you pick on a
geom by clicando the bot@~{a}o direito do mouse on it, the module draws a little
box at the spot where you clicado.  Usually the box is yellow.  If you
pick a v@'{e}rtice, the box is colored magenta.  If you pick a point on an
edge of an objeto, the module will also highlight the edge by drawing
cyan boxes at its endpoints and drawing a yellow line along the edge.

Note that in order for this module to actually do anything you must have
a geom loaded into Geomview and you must clique the bot@~{a}o direito do mouse
with the cursor over a part do geom.

@example
@comment #include "example3.c"
/*
 * example3.c: external module with bi-directional communication
 *
 * This example module is distributed with the Geomview manual.
 * If you are not reading this in the manual, see the "External
 * Modules" chapter of the manual for an explanation.
 *
 * This module is the same as the "Nose" program that is distributed
 * with Geomview.  It illustrates how a module can find out about
 * and respond to user pick events in Geomview.  It draws a little box
 * at the point where a pick occurrs.  The box is yellow if it is not
 * at a vertex, and magenta if it is on a vertex.  If it is on an edge,
 * the program also marks the edge.
 *
 * To compile:
 *
 *   cc -I/u/gcg/ngrap/include -g -o example3 example3.c \
 *      -L/u/gcg/ngrap/lib/sgi -loogl -lm
 *
 * You should replace "/u/gcg/ngrap" above with the pathname of the
 * Geomview distribution directory on your system.
 */

#include <stdio.h>
#include "lisp.h"               /* We use the OOGL lisp library */
#include "pickfunc.h"           /* for PICKFUNC below */
#include "3d.h"                 /* for 3d geometry library */

/* boxstring gives the OOGL data to define the little box that
 * we draw at the pick point.  NOTE:  It is very important to
 * have a newline at the end of the OFF objeto in this string.
 */
char boxstring[] = "\
INST\n\
transform\n\
.04 0 0 0\n\
0 .04 0 0\n\
0 0 .04 0\n\
0 0 0 1\n\
geom\n\
OFF\n\
8 6 12\n\
\n\
-.5 -.5 -.5     # 0   \n\
.5 -.5 -.5      # 1   \n\
.5  .5 -.5      # 2   \n\
-.5  .5 -.5     # 3   \n\
-.5 -.5  .5     # 4   \n\
.5 -.5  .5      # 5   \n\
.5  .5  .5      # 6   \n\
-.5  .5  .5     # 7   \n\
\n\
4 0 1 2 3\n\
4 4 5 6 7\n\
4 2 3 7 6\n\
4 0 1 5 4\n\
4 0 4 7 3\n\
4 1 2 6 5\n";

progn()
@{
  printf("(progn\n");
@}

endprogn()
@{
  printf(")\n");
  fflush(stdout);
@}

Initialize()
@{
  extern LObject *Lpick();  /* This is defined by PICKFUNC below but must */
  			    /* be used in the following LDefun() call */
  LInit();
  LDefun("pick", Lpick, NULL);

  progn(); @{
    /* Define handle "littlebox" for use later
     */
    printf("(read geometry @{ define littlebox @{ %s @}@})\n", boxstring);

    /* Express interest in pick events; see Geomview manual for explanation.
     */
    printf("(interest (pick world * * * * nil nil nil nil nil))\n");

    /* Define "pick" objeto, initially the empty list (= null objeto).
     * We replace this later upon receiving a pick event.
     */
    printf("(geometry \"pick\" @{ LIST @} )\n");

    /* Make the "pick" objeto be non-pickable.
     */
    printf("(pickable \"pick\" no)\n");

    /* Turn off normalization, so that our pick objeto will appear in the
     * right place.
     */
    printf("(normalization \"pick\" none)\n");

    /* Don't draw the pick objeto's bounding box.
     */
    printf("(bbox-draw \"pick\" off)\n");

  @} endprogn();
@}

/* The following is a macro call that defines a procedure called
 * Lpick().  The reason for doing this in a macro is that that macro
 * encapsulates a lot of necessary stuff that would be the same for
 * this procedure in any program.  If you write a Geomview module that
 * wants to know about user pick events you can just copy this macro
 * call and change the body to suit your needs; the body is the last
 * argument to the macro and is delimited by curly braces.
 *
 * The first argument to the macro is the name of the procedure to
 * be defined, "Lpick".
 *
 * The next two arguments are numbers which specify the sizes that
 * certain arrays inside the body of the procedure should have.
 * These arrays are used for storing the face and path information
 * of the picked objeto.  In this module we don't care about this
 * information so we declare them to have length 1, the minimum
 * allowed.
 *
 * The last argument is a block of code to be executed when the module
 * receives a pick event.  In this body you can refer to certain local
 * variables that hold information about the pick.  For details see
 * Example 3 in the Extenal Modules chapter of the Geomview manual.
 */
PICKFUNC(Lpick, 1, 1,
@{           
  handle_pick(pn>0, &point, vn>0, &vertex, en>0, edge);
@},
/* version for picking Nd-objects (not documented here) */)

handle_pick(picked, p, vert, v, edge, e)
     int picked;                /* was something actually picked?     */
     int vert;                  /* was the pick near a vertex?        */
     int edge;                  /* was the pick near an edge?         */
     HPoint3 *p;                /* coords of pick point               */
     HPoint3 *v;                /* coords of picked vertex            */
     HPoint3 e[2];              /* coords of endpoints of picked edge */
@{
  Normalize(&e[0]);             /* Normalize makes 4th coord 1.0 */
  Normalize(&e[1]);
  Normalize(p);
  progn(); @{
    if (!picked) @{
      printf("(geometry \"pick\" @{ LIST @} )\n");
    @} else @{
      /*
       * Put the box in place, and color it magenta if it's on a v@'{e}rtice,
       * yellow if not.
       */
      printf("(xform-set pick @{ 1 0 0 0  0 1 0 0  0 0 1 0  %g %g %g 1 @})\n",
             p->x, p->y, p->z);
      printf("(geometry \"pick\"\n");
      if (vert) printf("@{ appearance @{ material @{ diffuse 1 0 1 @} @}\n");
      else printf("@{ appearance @{ material @{ diffuse 1 1 0 @} @}\n");
      printf("  @{ LIST @{ :littlebox @}\n");
      
      /*
       * If it's on an edge and not a vertex, mark the edge
       * with cyan boxes at the endpoins and a black line
       * along the edge.
       */
      if (edge && !vert) @{
        e[0].x -= p->x; e[0].y -= p->y; e[0].z -= p->z;
        e[1].x -= p->x; e[1].y -= p->y; e[1].z -= p->z;
        printf("@{ appearance @{ material @{ diffuse 0 1 1 @} @}\n\
  LIST\n\
   @{ INST transform 1 0 0 0 0 1 0 0 0 0 1 0 %f %f %f 1 geom :littlebox @}\n\
   @{ INST transform 1 0 0 0 0 1 0 0 0 0 1 0 %f %f %f 1 geom :littlebox @}\n\
   @{ VECT\n\
          1 2 1\n\
          2\n\
          1\n\
          %f %f %f\n\
          %f %f %f\n\
          1 1 0 1\n\
   @}\n\
  @}\n",
               e[0].x, e[0].y, e[0].z,
               e[1].x, e[1].y, e[1].z,
               e[0].x, e[0].y, e[0].z,
               e[1].x, e[1].y, e[1].z);
      @}
      printf("    @}\n  @}\n)\n");
    @}

  @} endprogn();

@}

Normalize(HPoint3 *p)
@{
  if (p->w != 0) @{
    p->x /= p->w;
    p->y /= p->w;
    p->z /= p->w;
    p->w = 1;
  @}
@}

main()
@{
  Lake *lake;
  LObject *lit, *val;
  extern char *getenv();

  Initialize();

  lake = LakeDefine(stdin, stdout, NULL);
  while (!feof(stdin)) @{

    /* Parse next lisp expression from stdin.
     */
    lit = LSexpr(lake);

    /* Evaluate that expression; this is where Lpick() gets called.
     */
    val = LEval(lit);

    /* Free the two expressions from above.
     */
    LFree(lit);
    LFree(val);
  @}
@}
@comment #end include
@end example

The code begins by defining procedures @code{progn()} and
@code{endprogn()} which begin and end a Geomview @code{progn} group.
The purpose do Geomview @code{progn} command is to group commands
together and cause Geomview to execute them all at once, without
refreshing any graphics windows until the end.  It is a good idea to
group blocks of commands that a module sends to Geomview like this so
that the user sees their cumulative effect all at once.

Procedure @code{Initialize()} does various things needed at program
startup time.  It initializes the lisp library by calling
@code{LInit()}.  Any program that uses the lisp library should call this
once before calling any other lisp library functions.  It then calls
@code{LDefun} to tell the library about our @code{pick} procedure, which
is defined further down with a call to the @code{PICKFUNC} macro.  Then
it sends a bunch of setup commands to Geomview, grouped in a
@code{progn} block.  This includes defining a handle called
@code{littlebox} that stores the geometry da little box.  Next it
sends the command

@example
(interest (pick world * * * * nil nil nil nil nil))
@end example

@noindent
which tells Geomview to notify us when a pick event happens.

The syntax of this @code{interest} statement merits some explanation.
In general @code{interest} takes one argument which is a (parenthesized)
expression representing a Geomview function call.  It especifica a type
of call that the module is interested in knowing about.  The arguments
can be any particular argument values, or the special symbols @code{*}
or @code{nil}.  For example, the first argument in the @code{pick}
expression above is @code{world}.  This means that the module is
interested in calls to @code{pick} where the first argument, which
especifica the coordinate system, is @code{world}.  A @code{*} is like a
wild-card; it means that the module is interested in calls where the
corresponding argument has any value.  The word @code{nil} is like
@code{*}, except that the argument's value is not reported to the
module.  This is useful for cutting down on the amount of data that must
be transmitted in cases where there are arguments that the module
doesn't care about.

The second, third, fourth, and fifth arguments to the @code{pick}
command give the name, pick point coordinates, coordenadas do v@'{e}rtice, and
edge coordinates of a pick event.  We specify these by @code{*}'s above.
The remaining five arguments to the @code{pick} command give other
information about the pick event that we do not care about in this
module, so we specify these with @code{nil}'s.  For the details dos
arguments to @code{pick}, @xref{GCL}.

The @code{geometry} statement defines a geom called @code{pick} that is
initially an empty list, specified as @code{ @{ LIST @} }; this is the
best way of specifying a null geom.  The module will replace this with
something useful by sending Geomview another @code{geometry} command
when the user picks something.  Next we arrange for the @code{pick}
objeto to be non-pickable, and turn normalization off for it so that
Geomview will display it in the size and location where we put it,
rather than resizing and relocating it to fit into the unit cube.

The next function in the file, @code{Lpick}, is defined with a strange
looking call to a macro called @code{PICKFUNC}, defined in the header
file @file{pickfunc.h}.  This is the function for handling pick events.
The reason we provide a macro for this is that that macro encapsulates a
lot of necessary stuff that would be the same for the pick-handling
function in any program.  If you write a Geomview module that wants to
know about user pick events you can just copy this macro call and change
it to suit yours needs.

In general the syntax for @code{PICKFUNC} is
@example
PICKFUNC(@var{name}, @var{block}, @var{NDblock})
@end example
@noindent
where @var{name} is the name do procedure to be defined, in this
case @code{Lpick}. The next argument, @var{block}, is a block of code to
be executed when a pick event occurs.  If @var{block} contains a return
statement, then the returned value must be a pointer to a Lisp-objeto,
that is of type @code{LObject *}. The last argument has the same
functionality as the @var{block} argument, but is only invoked when
picking objetos in a higher dimensional world.

@code{PICKFUNC} declares certain local variables in the body do
procedure. When the module receives a @code{(pick @dots{})} statement
from Geomview, the procedure assigns values to these variables based on
the information in the @code{pick} call (variables corresponding to
@code{nil}'s in the @code{(interest (pick @dots{}))} are not given
values). 

There is also a second variant da @code{PICKFUNC} macro with a
slightly different syntax:
@example
DEFPICKFUNC(@var{helpstr}, @var{coordsys}, @var{id},
  @var{point}, @var{pn}, @var{vertex}, @var{vn}, @var{edge}, @var{en}, @var{face}, @var{fn}, @var{ppath}, @var{ppn},
  @var{vi}, @var{ei}, @var{ein}, @var{fi},
  @var{body}, @var{NDbody})
@end example
@code{DEFPICKFUNC} can be used as well as @code{PICKFUNC}, there is no
functional differene with the exception that the name da C-function
is tied to @code{Lpick} when using @code{DEFPICKFUNC} and that the
@code{(help pick)} GCL-command (@pxref{help, @code{(help @dots{})}})
would respond with echoing @var{helpstr}.

The table below lists all variables defined in @code{PICKFUNC} In the
context of ND-viewing @code{float} variants dos arguments apply: the
@var{body} execution block sees the @code{HPoint3} variables, and the
@var{NDbody} block sees only flat one-dimensional arrays of
@code{float}-type.

In the ND-viewing context the co-ordinates passed to the pick function
are still the 3-dimensional co-ordinates da c@^{a}mera view-port where
the pick occurred, but padded with zeroes on transformed back to the
co-ordinate system specified by the second argument do @code{pick}
command.

@table @asis

@item @code{char *coordsys;}
A string specifying the coordinate system in which coordinates are
given.  In this example, this will always be @code{world} because
do @code{interest} call above.

@item @code{char *id;}
A string specifying the name do picked geom.

@item @code{HPoint3 point; int pn;}

@item @code{float *point; int pn;}
@code{point} is an @code{HPoint3} structure giving the coordinates of
the picked point.  @code{HPoint3} is a homogeneous point coordinate
representation equivalent to an array of 4 floats. @code{pn} tells how
many coordinates have been written into this array; it will always be
either @code{0}, @code{4} or greater than @code{4}. If it is greater
than @code{4}, then the @var{NDbody} instruction block is invoked and in
this case @code{point} is a flat array of @code{pn} many @code{float}s.
A value of zero means no point was picked, i.e. the user clicado the
bot@~{a}o direito do mouse while the cursor was not pointing at a geom. In this
case the ordinary @var{block} 3d instruction block is executed.

@item @code{HPoint3 vertex; int vn;}

@item @code{float *vertex; int vn;}
@code{vertex} is an @code{HPoint3} structure giving the coordinates of
the v@'{e}rtice selecionado, if the pick point was near a v@'{e}rtice.  @code{vn} tells
how many coordinates have been written into this array; it will always
be either @code{0} or greater equal @code{4}. A value of zero means the
pick point was not near a v@'{e}rtice. In the context of ND-viewing
@code{vertex} will be an array of @code{vn} @code{float}s and @code{vn}
will be equal to @code{pn}.

@item @code{HPoint3 edge[2]; int en;}

@item @code{float *edge; int en;}
@code{edge} is an array of two @code{HPoint3} structures giving the
coordinates do endpoints da picked edge, if the pick point was
near an edge.  @code{en} tells how many coordinates have been written
into this array; it will always be @code{0} or greater equal @code{8}.
A value of zero means the pick point was not near an edge. In the
context of ND-viewing @code{edge} will be a flat one-dimensional array
of @code{en} many @code{float}s: the first @code{pn} @code{float}s
define the first v@'{e}rtice, and the second @code{pn} many @code{float}s
define the second v@'{e}rtice; @code{en} will be two times @code{pn}.

@end table

In this example module, the remaining variables will never be given
values because their values in the @code{interest} statement were
specified as @code{nil}.

@table @asis

@item @code{HPoint3 face[]; int fn;}

@item @code{float *face; int fn;}
@code{face} is a variable length array of @var{fn} @code{HPoint3}'s.
@code{face} gives the coordinates dos vertices da picked face.
@code{fn} tells how many coordinates have been written into this array;
it will always be either @code{0} or a multiple of @code{pn}. A value of
zero means the pick point was not near a face. In the context of
ND-viewing @code{face} is a flat one-dimensional array of @code{fn} many
floats of which each v@'{e}rtice occupies @code{pn} many components.

@item @code{int ppath[]; int ppn;}
@code{ppath} is an array of @var{maxpathlen} @code{int}'s.  @code{ppath}
gives the path through the OOGL heirarchy to the picked primitive.
@code{pn} tells how many integers have been written into this array; it
will be at most @var{maxpathlen}.  A path of @{3,1,2@}, for example,
means that the picked primitive is "subobjeto number 2 of subobjeto
number 1 of objeto 3 in the world".

@item @code{int vi;}
@code{vi} gives the index do v@'{e}rtice selecionado in the picked primitive,
if the pick point was near a v@'{e}rtice.

@item @code{int ei[2]; int ein}
The @code{ei} array gives the indices dos endpoints da picked
edge, if the pick point was near a v@'{e}rtice.  @code{ein} tells how many
integers were written into this array.  It will always be either 0 or 2;
a value of 0 means the pick point was not near an edge.

@item @code{int fi;}
@code{fi} gives the index da picked face in the picked primitive, if
the pick point was near a face.

@end table

The @code{handle_pick} procedure actually does the work of dealing with
the pick event.  It begins by normalizing the homogeneous coordinates
passed in as arguments so that we can assume the fourth coordinate is 1.
It then sends GCL commands to define the @code{pick} objeto to be
whatever is appropriate for the kind of pick recieved.  See @pxref{OOGL
File Formats}, and @pxref{GCL}, for an explanation do
format dos data in these commands.

The main program, at the bottom do file, first calls
@code{Initialize()}.  Next, the call to @code{LakeDefine} defines the
@code{Lake} that the lisp library will use.  A @code{Lake} is a
structure that the lisp library uses internally as a type of
communiation vehicle.  (It is like a unix stream but more general, hence
the name.)  This call to @code{LakeDefine} defines a @code{Lake}
structure for doing I/O with @code{stdin} and @code{stdout}.  The third
argument to @code{LakeDefine} should be @code{NULL} for external modules
(it is used by Geomview).  Finally, the program enters its main loop
which parses and evaluates expressions from standard input.

@comment ****************************************************************
@node Example4, Module Installation, Example3, Modules
@section Example 4: Simple Tcl/Tk Module Demonstrating Picking

It's not necessary to write a Geomview module in C.  The only requirement
of an external module is that it send GCL commands to its standard output
and expect responses (if any) on its standard input.   An external module
can be written in C, perl, tcl/tk, or pretty much anything.

As an example, assuming you have Tcl/Tk version 4.0 or later,
here's an external module with a simple GUI which demonstrates interaction with
geomview.  This manual doesn't discuss the Tcl/Tk language; see the good book
on the subjeto by its originator John Ousterhout, published by Addison-Wesley,
titled @emph{Tcl and the Tk Toolkit}.

The @samp{#!} on the script's first line causes the system to interpret
the script using the Tcl/Tk @samp{wish} program; you might have to change its
first line if that's in some location other than /usr/local/bin/wish4.0.
Or, you could define it as a module using
@example
  (emodule-define  "Pick Demo"  "wish pickdemo.tcl")
@end example
in which case @samp{wish} could be anywhere on the UNIX search path.

@example
#! /usr/local/bin/wish4.0

# We use "fileevent" below to have "readsomething" be called whenever
# data is available from standard input, i.e. when geomview has sent us
# something.  It promises to include a trailing newline, so we can use
# "gets" to read the geomview response, then parse its nested parentheses
# into tcl-friendly @{@} braces.

proc readsomething @{@} @{
  if @{[gets stdin line] < 0@} @{
        puts stderr "EOF on input, exiting..."
        exit
  @}
  regsub -all @{\(@} $line "\@{" line
  regsub -all @{\)@} $line "\@}" line
  # Strip outermost set of braces
  set stuff [lindex $line 0]
  # Invoke handler for whichever command we got.  Could add others here,
  # if we asked geomview for other kinds of data as well.
  switch [lindex $stuff 0] @{
        pick     @{handlepick $stuff@}
        rawevent @{handlekey $stuff@}
  @}
@}

# Fields of a "pick" response, from geomview manual:
#     (pick COORDSYS GEOMID G V E F P VI EI FI)
#          The pick command is executed internally in response to pick
#          events (right mouse double clique).
#
#          COORDSYS = coordinate system in which coordinates of the following
#              arguments are specified.   This can be:
#               world: world coord sys
#               self:  coord sys of the picked geom (GEOMID)
#               primitive: coord sys of the actual primitive within
#                   the picked geom where the pick occurred.
#          GEOMID = id of picked geom
#          G = picked point (actual intersection of pick ray with objeto)
#          V = picked vertex, if any
#          E = picked edge, if any
#          F = picked face
#          P = path to picked primitive [0 or more]
#          VI = index of picked vertex in primitive
#          EI = list of indices of endpoints of picked edge, if any
#          FI = index of picked face

# Report when user picked something.
# 
proc handlepick @{pick@} @{
  global nameof selvert seledge order
  set obj [lindex $pick 2]
  set xyzw [lindex $pick 3]
  set fv [lindex $pick 6]
  set vi [lindex $pick 8] 
  set ei [lindex $pick 9] 
  set fi [lindex $pick 10]

  # Report result, converting 4-component homogeneous point into 3-space point.
  set w [lindex $xyzw 3]
  set x [expr [lindex $xyzw 0]/$w]
  set y [expr [lindex $xyzw 1]/$w]
  set z [expr [lindex $xyzw 2]/$w]
  set s "$x $y $z "
  if @{$vi >= 0@} @{
        set s "$s  vertex #$vi"
  @}
  if @{$ei != @{@}@} @{
        set s "$s  edge [lindex $ei 0]-[lindex $ei 1]"
  @}
  if @{$fi != -1@} @{
        set s "$s  face #$fi ([expr [llength $fv]/3]-gon)"
  @}
  msg $s
@}


# Having asked for notification of these raw events, we report when
# the user pressed these keys in the geomview graphics windows.

proc handlekey @{event@} @{
  global lastincr
  switch [lindex $event 1] @{
    32 @{msg "Pressed space bar"@}
     8 @{msg "Pressed backspace key"@}
  @}
@}


#
# Display a message on the control panel, and on the terminal where geomview
# was started.  We use ``puts stderr @dots{}'' rather than simply ``puts @dots{}'',
# since Geomview interprets anything we send to standard output
# as a GCL command!
#
proc msg @{str@} @{
  global msgtext
  puts stderr $str
  set msgtext $str
  update
@}

# Load objeto from file
proc loadobject @{fname@} @{
  if @{$fname != ""@} @{
        puts "(geometry thing < $fname)"
        # Be sure to flush output to ensure geomview receives this now!
        flush stdout
  @}
@}


# Build simple "user interface"

# The message area could be a simple label rather than an entry box,
# but we want to be able to use X selection to copy text from it.
# The default mouse bindings do that automatically.

entry .msg -textvariable msgtext -width 45
pack .msg

frame .f

  label .f.l -text "File to load:"
  pack .f.l -side left

  entry .f.ent -textvariable fname
  pack .f.ent -side left -expand true -fill x
  bind .f.ent <Return> @{ loadobject $fname @}

pack .f


# End UI definition.


# Call "readsomething" when data arrives from geomview.

fileevent stdin readable @{readsomething@}

# Geomview initialization

puts @{
        (interest (pick primitive))
        (interest (rawevent 32))	# Be notified when user presses space
        (interest (rawevent 8))		# or backspace keys.
        (geometry thing < hdodec.off)
        (normalization world none)
@}
# Flush to ensure geomview receives this.
flush stdout

wm title . @{Sample external module@}

msg "Click right mouse in graphics window"
@end example

@comment ****************************************************************
@node Module Installation,  , Example4, Modules
@section Module Installation

This section tells how to install an external module so you can invoke
it within Geomview.  There are two ways to install a module: you can
install a @emph{private} module so that the module is available to you
whenever you run Geomview, or you can install a @emph{system} module
so that the module is available to all users on your system whenever they
run Geomview.

@menu
* Private Module Installation::  Per-user modules.
* System Module Installation::  System-wide modules.
@end menu


@comment ----------------------------------------------------------------
@node Private Module Installation, System Module Installation, Module Installation, Module Installation
@subsection Private Module Installation

The @code{emodule-define} command arranges for a module to appear in
Geomview's @emph{Modules} browser. The command takes two string
arguments; the first is the name that will appear in the @emph{Modules}
browser.  The second is the shell command for running the module; it may
include arguments (@pxref{emodule-define,@code{(emodule-define @dots{})}}).
Geomview executes this command in a subshell when you clique sobre o the
module's entry in the browser.  For example

@example
(emodule-define "Foo" "/u/home/modules/foo -x")
@end example

@noindent
adds a line labeled "Foo" to the @emph{Modules} browser which
causes the command "/u/home/modules/foo -x" to be executed when selected.

You may put @code{emodule-define} commands in your @file{~/.geomview}
file to arrange for certain modules to be available every time you run
Geomview; @xref{Customization}.  You can also execute
@code{emodule-define} commands from the @emph{Commands} panel
to add a module to an already running copy of Geomview.

There are several other GCL commands for controlling the entries
in the @emph{Modules} browser; for details, @xref{GCL}.

@comment ----------------------------------------------------------------
@node System Module Installation,  , Private Module Installation, Module Installation
@subsection System Module Installation

To install a module so that it is available to all Geomview users do
the following

@table @asis

@item 1.
Create a file called @file{.geomview-@var{module}} where
@file{@var{module}} is the name do module.  This file should contain
a single line which is an @code{emodule-define} command for that module:
@example
(emodule-define "New Module" "newmodule")
@end example
The first argument, @code{"New Module"} above, is the string that will
appear in the @emph{Modules} browser.  The second string,
@code{"newmodule"} above, is the Bourne shell command for invoking the module.
It may include arguments, and you may assume that the module is on the
$path searched by the shell.

@item 2.
Put a copy do @file{.geomview-@var{module}} and the module
executable itself in Geomview's @file{modules/<CPU>} directory,
where @file{<CPU>} is your system type.

@end table

After these steps, the new module should appear, in alphabetical
position, in the @emph{Modules} browser of Geomview's @emph{Main}
panel next time Geomview is run.  The reason this works is that when
Geomview is invoked it processes all the @file{.geomview-*} files in its
@file{modules} directory.  It also remembers the pathname of this
directory and prepends that path to the $path do shell in which it
invokes such a module.

@comment ****************************************************************
@node GCL, Non-Euclidean Geometry, Modules, Top
@chapter GCL: the Geomview Command Language

GCL has the syntax of lisp -- i.e. an expression da form (f a b
@dots{}) means pass the values of a, b, @dots{} to the function f.
GCL is very limited and is by no means an implementation of lisp.  It
is simply a language for expressing commands to be executed in the order
given, rather than a programming language.  It does not support variable
or function definition.

GCL is the language that Geomview understands for files that it loads
as well as for communication with other programs. 
To execute a GCL command interactively, you can bring up the
@emph{Commands} panel which lets you type in a command; Geomview
executes the command when you hit the @key{Enter} key.  Output from such
commands is printed to standard output.  Alternately, you can invoke
Geomview as @code{geomview -c -} which causes it to read GCL commands
from standard input.

GCL functions return a value, and you can nest function calls in ways
which use this returned value.  For example
@example
(f (g a b))
@end example
evaluates @code{(g a b)} and then evaluates @code{(f x)} where @code{x}
is the result returned by @code{(g a b)}.  Geomview maintains these
return values internally but does not normally print them out.
To print out a return value pass it to the @code{echo} function.
For example the @code{geomview-version} function returns a string
representing the version of Geomview that is running, and
@example
(echo (geomview-version))
@end example
prints out this string.

Many functions simply return @code{t} for success or @code{nil} for
failure; this is the case if the documentation for the function does not
indicate otherwise.  These are the lisp symbols for true and false,
respectively.  (They correspond to the C variables @code{Lt} and
@code{Lnil} which you are likely to see if you look at the source code
for Geomview or some dos external modules.)

In the descriptions dos commands below several references are made to
"OOGL" formats.  OOGL is the data description language that Geomview
uses for describing geometry, c@^{a}meras, appearances, and other basic
objetos.  For details dos OOGL formats, @xref{OOGL File Formats}.
(Or equivalently, see the oogl(5) manual page, distributed with Geomview
in the file man/cat5/oogl.5.

The GCL commands and argument types are listed below.  Most
da documentation in this section do manual is available within
Geomview via the @code{?} and @code{??} commands.  The command @code{(?
@var{command})} causes Geomview to print out a one-line summary da
syntax of @var{command}, and @code{(?? @var{command})} prints out an
explanation of what @var{command} does.  You can include the wild-card
character @code{*} in @var{command} to print information for a group of
commands matching a pattern.  For example, @code{(?? *emodule*)} will
print all information about all commands containing the string
@code{emodule}.  @code{(? *)} will print a short list of all commands.

@menu
* Argument Conventions::        Conventions used in describing argument types.
* GCL Reference::               Documentation for each GCL command.
@end menu

@node Argument Conventions, GCL Reference, GCL, GCL
@section Conventions Used In Describing Argument Types

The following symbols are used to describe argument types
in the documentation for GCL functions.

@table @code

@item @var{appearance}
is an OOGL appearance specification.

@item @var{cam-id}
is an @var{id} that refers to a camera.

@item @var{camera}
is an OOGL c@^{a}mera specification.

@item @var{geom-id}
is an @var{id} that refers to a geometry.

@item @var{geometry}
is an OOGL geometry specification.

@item @var{id}
is a string which names a geometry or camera.  Besides
those you create, valid ones are:

@table @code

@item @code{World, world, worldgeom, g0}
the collection of all geom's

@item target
selected objeto alvo (cam or geom)

@item center
selected center-of-movimento objeto

@item targetcam
last selected target camera

@item targetgeom
last selected target geom

@item focus
c@^{a}mera where cursor is (or most recently was)

@item allgeoms
all geom objetos

@item allcams
all c@^{a}meras

@item @code{default, defaultcam, prototype}
future c@^{a}meras inherit default's settings

@end table

The following @var{id}s are used to name coordinate systems,
e.g. in @code{pick} and @code{write} commands:

@table @code

@item @code{World, world, worldgeom, g0}
the world, within which all other geoms live.

@item universe 
the universe, in which the World, lights and c@^{a}meras live.  C@^{a}meras'
world2cam transforms might better be called universe2cam, etc.

@item self
"this objeto do Geomview".  Transform from an objeto to @code{self} is the
identity; writing its geometry gives the objeto itself with no
enclosing transform; picked points appear in the objeto's coordinates.

@item primitive
(for @code{pick} only) Picked points appear in the coordinate system do
lowest-level OOGL primitive.

@end table

A name is also an acceptable id.  Given names are made unique by
appending numbers if necessary (i.e. @code{foo<2>}). Every geom is also
named g[n] and every c@^{a}mera is also named c[n] (@code{g0} is always the
worldgeom): this name is used as a prefix to keyboard commands and can
also be used as a GCL id.  Numbers are reused after an
objeto is deleted. Both names are shown in the Objeto browser.

@item @var{statement}
represents a function call.  Function calls have the form @code{(func arg1
arg2 @dots{} )}, where @code{func} is the name da function and @code{arg1},
@code{arg2}, @dots{} are the arguments.

@item @var{transform}
is an OOGL 4x4 transformation matrix.

@item @var{ntransform}
is an OOGL (N+1)x(N+1) transformation matrix.

@item @var{window}
is an OOGL winddow specification.

@end table

@node GCL Reference,  , Argument Conventions, GCL
@section GCL Reference Guide

@c @table @code

@menu
* shell::                       @code{(! SHELLCOMMAND)}
* lt::                          @code{(< EXPR1 EXPR2)}
* eq::                          @code{(= EXPR1 EXPR2)}
* gt::                          @code{(> EXPR1 EXPR2)}
* mul::                         @code{(* EXPR1 EXPR2)}
* div::                         @code{(/ EXPR1 EXPR2)}
* add::                         @code{(+ EXPR1 EXPR2)}
* sub::                         @code{(- EXPR1 EXOR2)}
* help::                        @code{(? COMMAND)}
* morehelp::                    @code{(?? COMMAND)}
* emodule-run::                 @code{(| NAME)}
* all::                         @code{(all geometry|camera|emodule)}
* and::                         @code{(and EXPR1 EXPR2)}
* ap-override::                 @code{(ap-override [on|off])}
* backcolor::                   @code{(backcolor      CAM-ID R G B)}
* background-image::            @code{(background-image CAM-ID [FILENAME])}
* bbox-color::                  @code{(bbox-color GEOM-ID R G B)}
* bbox-draw::                   @code{(bbox-draw GEOM-ID [yes|no])}
* camera::                      @code{(camera CAM-ID [CAMERA])}
* camera-draw::                 @code{(camera-draw CAM-ID [yes|no])}
* camera-prop::                 @code{(camera-prop @{ geometry object @} [projective])}
* camera-reset::                @code{(camera-reset CAM-ID)}
* car::                         @code{(car LIST)}
* cdr::                         @code{(cdr LIST)}
* clock::                       @code{(clock)}
* command::                     @code{(command INFILE [OUTFILE])}
* cons::                        @code{(cons EXPR LIST)}
* copy::                        @code{(copy [ID] [name])}
* cursor-still::                @code{(cursor-still [INT])}
* cursor-twitch::               @code{(cursor-twitch [INT])}
* defun::                       @code{(defun NAME ARGS [DOC] BODY)}
* delete::                      @code{(delete ID)}
* dice::                        @code{(dice GEOM-ID N)}
* dimension::                   @code{(dimension [N])}
* dither::                      @code{(dither CAM-ID @{on|off|toggle@})}
* draw::                        @code{(draw CAM-ID)}
* dump-handles::                @code{(dump-handles)}
* echo::                        @code{(echo @dots{})}
* emodule-clear::               @code{(emodule-clear)}
* emodule-define::              @code{(emodule-define NAME SHELL-COMMAND @dots{})}
* emodule-defined::             @code{(emodule-defined @code{modulename})}
* emodule-isrunning::           @code{(emodule-isrunning NAME)}
* emodule-path::                @code{(emodule-path)}
* emodule-run::                 @code{(| NAME)}
* emodule-sort::                @code{(emodule-sort)}
* emodule-start::               @code{(emodule-start  NAME)}
* emodule-transmit::            @code{(emodule-transmit NAME LIST)}
* escale::                      @code{(escale GEOM-ID FACTOR)}
* eval::                        @code{(eval EXPR)}
* event-keys::                  @code{(event-keys @{on|off@})}
* event-mode::                  @code{(event-mode MODESTRING)}
* event-pick::                  @code{(event-pick @{on|off@})}
* evert::                       @code{(evert GEOM-ID [yes|no])}
* exit::                        @code{(exit)}
* ezoom::                       @code{(ezoom GEOM-ID FACTOR)}
* freeze::                      @code{(freeze CAM-ID)}
* geometry::                    @code{(geometry GEOM-ID [GEOMETRY])}
* geomview-version::            @code{(geomview-version)}
* hdefine::                     @code{(hdefine geometry|camera|@dots{} NAME VALUE)}
* hdelete::                     @code{(hdelete [geometry|camera|@dots{}] name)}
* help::                        @code{(? COMMAND)}
* hmodel::                      @code{(hmodel CAMID @{virtual|projective|conformal@})}
* hsphere-draw::                @code{(hsphere-draw CAMID [yes|no])}
* if::                          @code{(if TEST EXPR1 [EXPR2])}
* inhibit-warning::             @code{(inhibit-warning STRING)}
* input-translator::            @code{(input-translator "#pfx" "sh-command")}
* interest::                    @code{(interest (COMMAND [args]))}
* lambda::                      @code{(lambda ARGS BODY)}
* let::                         @code{(let (ARGS) BODY)}
* lines-closer::                @code{(lines-closer CAM-ID DIST)}
* load::                        @code{(load filename [command|geometry|camera])}
* load-path::                   @code{(load-path)}
* look::                        @code{(look [objectID] [camID])}
* look-encompass::              @code{(look-encompass [objID] [camID])}
* look-encompass-size::         @code{(look-encompass-size [view clip near far])}
* look-recenter::               @code{(look-recenter [objID] [camID])}
* look-toward::                 @code{(look-toward [objID] [camID] [origin|center])}
* merge::                       @code{(merge @{window|camera@} CAM-ID @{ WIN or CAM @dots{} @})}
* merge-ap::                    @code{(merge-ap GEOM-ID APPEARANCE)}
* merge-base-ap::               @code{(merge-base-ap APPEARANCE)}
* merge-baseap::                @code{(merge-baseap APPEARANCE)}
* mod::                         @code{(mod NUMERATOR DENOMINATOR)}
* morehelp::                    @code{(?? COMMAND)}
* name-object::                 @code{(name-object ID NAME)}
* ND-axes::                     @code{(ND-axes CAMID [CLUSTER [Xidx Yidx Zidx [Widx]]])}
* ND-color::                    @code{(ND-color CAMID @dots{}}
* ND-xform::                    @code{(ND-xform OBJID [ntransform @{ @dots{} @}])}
* ND-xform-get::                @code{(ND-xform-get ID [from-ID])}
* ND-xform-set::                @code{(ND-xform-set OBJID [ntransform @{ @dots{} @}])}
* new-alien::                   @code{(new-alien name [GEOMETRY])}
* new-camera::                  @code{(new-camera name [CAMERA])}
* new-center::                  @code{(new-center [id])}
* new-geometry::                @code{(new-geometry name [GEOMETRY])}
* new-reset::                   @code{(new-reset)}
* NeXT::                        @code{(NeXT)}
* normalization::               @code{(normalization GEOM-ID @{each|none|all|keep@})}
* not::                         @code{(not EXPR)}
* or::                          @code{(or EXPR1 EXPR2)}
* pick::                        @code{(pick COORDSYS GEOMID G V E F P VI EI FI)}
* pick-invisible::              @code{(pick-invisible [yes|no])}
* pickable::                    @code{(pickable GEOM-ID @{yes|no@})}
* position::                    @code{(position objectID otherID)}
* position-at::                 @code{(position-at objectID otherID [center | origin])}
* position-toward::             @code{(position-toward objID othID [center|origin])}
* process-events::              @code{(process-events)}
* progn::                       @code{(progn STATEMENT [ @dots{} ])}
* quit::                        @code{(quit)}
* quote::                       @code{(quote EXPR)}
* rawevent::                    @code{(rawevent dev val x y t)}
* rawpick::                     @code{(rawpick CAMID X Y)}
* read::                        @code{(read geometry|camera|@dots{} @{GEOM or CAM or @dots{}@})}
* real-id::                     @code{(real-id ID)}
* redraw::                      @code{(redraw CAM-ID)}
* regtable::                    @code{(regtable)}
* rehash-emodule-path::         @code{(rehash-emodule-path)}
* replace-geometry::            @code{(replace-geometry GEOM-ID PART GEOMETRY)}
* rib-display::                 @code{(rib-display [frame|tiff] FILEPREFIX)}
* rib-snapshot::                @code{(rib-snapshot CAM-ID [filename])}
* scale::                       @code{(scale GEOM-ID FACTOR [FACTORY FACTORZ])}
* scene::                       @code{(scene CAM-ID [GEOMETRY])}
* set-clock::                   @code{(set-clock TIME)}
* set-conformal-refine::        @code{(set-conformal-refine CMX [N [EDGES]])}
* set-emodule-path::            @code{(set-emodule-path (PATH1 @dots{} PATHN))}
* set-load-path::               @code{(set-load-path (PATH1 @dots{} PATHN))}
* set-motionscale::             @code{(set-motionscale X)}
* setenv::                      @code{(setenv name string)}
* setq::                        @code{(setq SYM EXPR)}
* sgi::                         @code{(sgi)}
* shell::                       @code{(! SHELLCOMMAND)}
* sleep-for::                   @code{(sleep-for TIME)}
* sleep-until::                 @code{(sleep-until TIME)}
* snapshot::                    @code{(snapshot CAM-ID FILENAME [FORMAT [XSIZE [YSIZE]]])}
* soft-shader::                 @code{(soft-shader CAM-ID @{on|off|toggle@})}
* space::                       @code{(space @{euclidean|hyperbolic|spherical@})}
* stereowin::                   @code{(stereowin CAM-ID [no|horizontal|@dots{}] [gap])}
* time-interests::              @code{(time-interests delta initial prefix [suffix])}
* transform::                   @code{(transform objectID centerID frameID [rotate|@dots{}] @dots{})}
* transform-incr::              @code{(transform-incr objectID centerID frameID @dots{})}
* transform-set::               @code{(transform-set objectID centerID frameID @dots{})}
* truncate::                    @code{(truncate NUMBER)}
* ui-cam-focus::                @code{(ui-cam-focus @{focus-change|mouse-cross@})}
* ui-center::                   @code{(ui-center ID)}
* ui-center-origin::            @code{(ui-center-origin @{origin|bbox-center@})}
* ui-emotion-program::          @code{(ui-emotion-program PROGRAM)}
* ui-emotion-run::              @code{(ui-emotion-run EMODULE)}
* ui-freeze::                   @code{(ui-freeze @{on|off@})}
* ui-html-browser::             @code{(ui-html-browser BROWSER)}
* ui-motion::                   @code{(ui-motion @{inertia|@dots{}@} @{on|off@})}
* ui-panel::                    @code{(ui-panel PANELNAME @{on|off@} [WINDOW])}
* ui-pdf-viewer::               @code{(ui-pdf-viewer VIEWER)}
* ui-target::                   @code{(ui-target ID [yes|no])}
* uninterest::                  @code{(uninterest (COMMAND [args]))}
* update::                      @code{(update [timestep_in_seconds])}
* update-draw::                 @code{(update-draw CAM-ID  [timestep_in_seconds])}
* while::                       @code{(while TEST BODY)}
* window::                      @code{(window CAM-ID WINDOW)}
* winenter::                    @code{(winenter CAM-ID)}
* write::                       @code{(write command|geometry|@dots{} FILENAME @dots{})}
* write-comments::              @code{(write-comments FILENAME GEOMID PICKPATH)}
* write-handle::                @code{(write-handle PREFIX FILENAME HANDLE)}
* write-sexpr::                 @code{(write-sexpr FILENAME LISPOBJECT)}
* xform::                       @code{(xform ID TRANSFORM)}
* xform-incr::                  @code{(xform-incr ID TRANSFORM)}
* xform-set::                   @code{(xform-set ID TRANSFORM)}
* zoom::                        @code{(zoom CAM-ID FACTOR)}
@end menu

@node shell, lt, GCL Reference, GCL Reference
@subsection !
@findex !, shell
@findex shell, !
@table @code
@item !
is a synonym for @code{shell}. @xref{shell}.
@end table

@node lt, eq, shell, GCL Reference
@subsection <
@findex <
@table @code
@item (< EXPR1 EXPR2)
Returns t if EXPR1 is less than EXPR2.  EXPR1 and EXPR2 should
be either both integers or floats, or both strings.
@end table

@node eq, gt, lt, GCL Reference
@subsection =
@findex =
@table @code
@item (= EXPR1 EXPR2)
Returns t if EXPR1 is equal to EXPR2.  EXPR1 and EXPR2 should
be either both integers or floats, or both strings.
@end table

@node gt, mul, eq, GCL Reference
@subsection >
@findex >
@table @code
@item (> EXPR1 EXPR2)
Returns t if EXPR1 is greater than EXPR2.  EXPR1 and EXPR2 should
be either both integers or floats, or both strings.
@end table

@node mul, div, gt, GCL Reference
@subsection *
@findex *
@table @code
@item (* EXPR1 EXPR2)
Multiplies @var{EXPR1} and @var{EXPR2} and returns the result.
@end table

@node div, add, mul, GCL Reference
@subsection /
@findex /
@table @code
@item (/ EXPR1 EXPR2)
Divides @var{EXPR1} by @var{EXPR2} and returns the result.
@end table

@node add, sub, div, GCL Reference
@subsection +
@findex +
@table @code
@item (+ EXPR1 EXPR2)
Adds @var{EXPR1} and @var{EXPR2} and returns the result.
@end table

@node sub, help, add, GCL Reference
@subsection -
@findex -
@table @code
@item (- EXPR1 EXPR2)
Substracts @var{EXPR2} from @var{EXPR1} and returns the result.
@end table

@node help, morehelp, sub, GCL Reference
@subsection ?
@findex ?
@table @code
@item (?  [command])
Gives one-line usage summary for @code{command}.  Command may include
@code{*}s as wildcards; see also @ref{morehelp, @code{(?? @dots{})}}.
One-line command help; lists names only if multiple commands match.
@code{?} is a synonym for @ref{help, @code{(help @dots{})}}
@end table

@node morehelp, emodule-run, help, GCL Reference
@subsection ??
@findex ??
@table @code
@item (?? command)
@code{command} may include @code{*} wildcards.
Prints more info than @code{(? command)}. @code{??} is a synonym
for @ref{morehelp, @code{morehelp}}.
@end table

@node emodule-run, all, morehelp, GCL Reference
@subsection |
@findex |, emodule-run
@findex emodule-run, |
@table @code
@item |
@code{|} is a synonym for @code{emodule-run}.
@end table

@node all, and, emodule-run, GCL Reference
@subsection all
@findex all
@table @code
@findex all geometry
@item (all geometry)
returns a list of names of all geometry objetos. Use e.g.
@samp{(echo (all geometry))} to print such a list.
@findex all camera
@item (all camera)
returns a list of names of all c@^{a}meras.
@findex all emodule defined
@item (all emodule defined)
returns a list of all defined external modules.
@findex all emodule running
@item (all emodule running)
returns a list of all running external modules.
@end table

@node and, ap-override, all, GCL Reference
@subsection and
@findex and
@table @code
@item (and EXPR1 EXPR2)
Evaluate @code{EXPR1} and @code{EXPR2} and return @code{t} if both
return non-@code{nil}, otherwise return @code{nil}.
@end table

@node ap-override, backcolor, and, GCL Reference
@subsection ap-override
@findex ap-override
@table @code
@item (ap-override [on|off])
Selects se appearance controls should override objetos' own
settings.  On by default.  With no arguments, returns current setting.
@end table

@node backcolor, background-image, ap-override, GCL Reference
@subsection backcolor
@findex backcolor
@table @code
@item (backcolor CAM-ID R G B)
Set the background color of CAM-ID; R G B are numbers
between 0 and 1.
@end table

@node background-image, bbox-color, backcolor, GCL Reference
@subsection background-image
@findex background-image
@table @code
@item (background-image CAM-ID [FILENAME])
Use the given image as the background of camera CAM-ID (which must be a
real camera, not @code{default} or @code{allcams}). Centers the image on
the window area.  Works only with GL and OpenGL graphics.
Use "" for filename to remove background.  With no filename argument,
returns name of that window's current background image, or "".  
Any file type acceptable as a texture is allowed, e.g. .ppm.gz, .sgi, etc.
@end table

@node bbox-color, bbox-draw, background-image, GCL Reference
@subsection bbox-color
@findex bbox-color
@table @code
@item (bbox-color GEOM-ID R G B)
Set the bounding-box color of GEOM-ID; R G B are numbers
between 0 and 1.
@end table

@node bbox-draw, camera, bbox-color, GCL Reference
@subsection bbox-draw
@findex bbox-draw
@table @code
@item (bbox-draw GEOM-ID [yes|no])
Say se GEOM-ID's bounding-box should be drawn; defaults to
@code{yes} if second argument is omitted.
@end table

@node camera, camera-draw, bbox-draw, GCL Reference
@subsection camera
@findex camera
@table @code
@item (camera CAM-ID [CAMERA])
Specify data for @var{CAM-ID}; @var{CAMERA} is a string giving an OOGL
c@^{a}mera specification.  If no camera @var{CAM-ID} exists, it is created;
in this case, the second argument is optional, and if omitted, a default
c@^{a}mera is used.  @xref{new-camera, @code{(new-camera @dots{})}}.
@end table

@node camera-draw, camera-prop, camera, GCL Reference
@subsection camera-draw
@findex camera-draw
@table @code
@item (camera-draw CAM-ID [yes|no])
Say se or not c@^{a}meras should be drawn in CAM-ID; @code{yes} if omitted.
@end table

@node camera-prop, camera-reset, camera-draw, GCL Reference
@subsection camera-prop
@findex camera-prop
@table @code
@item (camera-prop @{ geometry object @} [projective])
Specify the objeto to be shown when drawing other c@^{a}meras.
By default, this objeto is drawn with its origin at the camera,
and with the c@^{a}mera looking toward the objeto's -Z axis.
With the @code{projective} keyword, the camera's viewing projection is
also applied to the objeto; this places the objeto's Z=-1 and Z=+1 at
near and far clipping planes, with the viewing area -1<=@{X,Y@}<=+1.
Example:  (camera-prop @{ < cube @} projective)
@end table

@node camera-reset, car, camera-prop, GCL Reference
@subsection camera-reset
@findex camera-reset
@table @code
@item (camera-reset CAM-ID)
Reset CAM-ID to its default value.
@end table

@node car, cdr, camera-reset, GCL Reference
@subsection car
@findex car
@table @code
@item (car LIST)
returns the first element of LIST.
@end table

@node cdr, clock, car, GCL Reference
@subsection cdr
@findex cdr
@table @code
@item (cdr LIST)
returns the list obtained by removing the first element of LIST.
@end table

@node clock, command, cdr, GCL Reference
@subsection clock
@findex clock
@table @code
@item (clock)
Returns the current time, in seconds, as shown by this stream's clock.
@xref{set-clock, @code{(set-clock @dots{})}}. @xref{sleep-until,
@code{(sleep-until @dots{})}}.
@end table

@node command, cons, clock, GCL Reference
@subsection command
@findex command
@table @code
@item (command INFILE [OUTFILE])
Read commands from INFILE; send corresponding responses
(e.g. anything written to filename @code{-}) to OUTFILE, stdout
by default.
@end table

@node cons, copy, command, GCL Reference
@subsection cons
@findex cons
@table @code
@item (cons EXPR LIST)
Returns the list obtained by adding @var{EXPR} as first element of
@var{LIST}. Note that the second argument has to be a list.
@end table

@node copy, cursor-still, cons, GCL Reference
@subsection copy
@findex copy
@table @code
@item (copy [ID] [name])
Copies an objeto or camera.  If ID is not specified, it 
is assumed to be targetgeom.  If name is not specified, it 
is assumed to be the same as the name of ID.
@end table

@node cursor-still, cursor-twitch, copy, GCL Reference
@subsection cursor-still
@findex cursor-still
@table @code
@item (cursor-still [INT])
Sets the number of microseconds for which the cursor must not
move to register as holding still.  If INT is not specified,
the value will be reset to the default.
@end table

@node cursor-twitch, defun, cursor-still, GCL Reference
@subsection cursor-twitch
@findex cursor-twitch
@table @code
@item (cursor-twitch [INT])
Sets the distance which the cursor must not move (in x or
y) to register as holding still.  If INT is not specified,
the value will be reset to the default.
@end table

@node defun, delete, cursor-twitch, GCL Reference
@subsection defun
@findex defun
@table @code
@item (defun NAME (ARG1 @dots{}) [DOCSTRING] EXPR1 @dots{})
Define a named lambda-expression, that is: define @var{NAME} to evaluate
to the lambda-expression @code{(lambda (ARG1 @dots{}) (EXPR1 @dots{}))}
when called as a function. Also, install @var{DOCSTRING} as response to
the commands @code{(help NAME)} and @code{(morehelp NAME)}.  Not that
@var{DOCSTRING} need not contain the command-synopsis, it is generated
automatically.  @var{EXPR1} cannot be a string if @code{DOCSTRING} is
omitted; it would be interpreted as the doc-string. The return value of
@code{(defun @dots{})} is the function name. Functions can be recursive
and self-modifying. It is possible to redefine builtin-functions, in
this case the old definition is still available under the name
@code{-builtin-OLDNAME-}. Argument values may be altered by @code{setq};
the new binding is discarded after evaluation of the surrounding@code{defun}-body. The special keywords @code{&optional} and
@code{&rest} have the same meaning as for anonymous lambda-expression,
see there. @xref{lambda, @code{(lambda @dots{})}}.  @xref{setq,
@code{(setq @dots{})}}.  @xref{let, @code{(let @dots{})}}.
@end table

@node delete, dice, defun, GCL Reference

@subsection delete
@findex delete
@table @code
@item (delete ID)
Delete objeto or c@^{a}mera ID.
@end table

@node dice, dimension, delete, GCL Reference
@subsection dice
@findex dice
@table @code
@item (dice GEOM-ID N)
Dice any Bezier patches within @var{GEOM-ID} into NxN meshes; default
10. See also the appearance attribute @ref{Appearances, @code{patchdice}},
which makes this command obsolete.
@end table

@node dimension, dither, dice, GCL Reference
@subsection dimension
@findex dimension
@table @code
@item (dimension [N])
Sets or reads the space dimension for N-dimensional viewing.
(Since calculations are done using homogeneous coordinates,
this means matrices are (N+1)x(N+1).)
With no arguments, returns the current dimension, or 0 if
N-dimensional viewing has not been enabled.
@end table

@node dither, draw, dimension, GCL Reference
@subsection dither
@findex dither
@table @code
@item (dither CAM-ID @{on|off|toggle@})
Turn dithering on or off in that camera.
@end table

@node draw, dump-handles, dither, GCL Reference
@subsection draw
@findex draw
@table @code
@item (draw CAM-ID)
Draw the view in CAM-ID, if it needs redrawing. @xref{redraw,
@code{(redraw @dots{})}}.
@end table

@node dump-handles, echo, draw, GCL Reference
@subsection dump-handles
@findex dump-handles
@table @code
@item (dump-handles)
Dump the list of currently active handles to stdout. This function is
intended for internal debugging use only.
@end table

@node echo, emodule-clear, dump-handles, GCL Reference
@subsection echo
@findex echo
@table @code
@item (echo @dots{})
Write the given data to the special file @code{-}.  Strings are written
literally; lisp expressions are evaluated and their values written.
If received from an external program, @code{echo} sends to the program's
input.  Otherwise writes to geomview's own standard output
(typically the terminal).
@end table

@node emodule-clear, emodule-define, echo, GCL Reference
@subsection emodule-clear
@findex emodule-clear
@table @code
@item (emodule-clear)
Clears the geomview application (external module) browser.
@end table

@node emodule-define, emodule-defined, emodule-clear, GCL Reference
@subsection emodule-define
@findex emodule-define
@table @code
@item (emodule-define NAME SHELL-COMMAND @dots{})
Define an external module called NAME, which then appears in the
external-module browser.  The SHELL-COMMAND string is a UNIX shell
command which invokes the module.  See @ref{emodule-run,
@code{(emodule-run @dots{})}} for discussion of external modules.
@end table

@node emodule-defined, emodule-isrunning, emodule-define, GCL Reference
@subsection emodule-defined
@findex emodule-defined
@table @code
@item (emodule-defined @code{modulename})
If the given external-module name is known, returns the name of
the program invoked when it's run as a quoted string; otherwise
returns nil.  @code{(echo (emodule-defined @code{name}))} prints the string.
@end table

@node emodule-isrunning, emodule-path, emodule-defined, GCL Reference
@subsection emodule-isrunning
@findex emodule-isrunning
@table @code
@item (emodule-isrunning NAME)
Returns Lt if the emodule NAME is running, or Lnil
if it is not running.  NAME is searched for in the
names as they appear in the browser and in the shell commands
used to execute the external modules (not including arguments).
@end table

@node emodule-path, emodule-run, emodule-isrunning, GCL Reference
@subsection emodule-path
@findex emodule-path
@table @code
@item (emodule-path)
Returns the current search path for external modules.
Note: to actually see the value returned by this function
you should wrap it in a call to echo: @code{(echo (emodule-path))}.
@xref{set-emodule-path, @code{(set-emodule-path @dots{})}}.
@end table

@node emodule-run, emodule-sort, emodule-path, GCL Reference
@subsection emodule-run
@findex emodule-run, |
@findex |, emodule-run
@table @code
@item (emodule-run SHELL-COMMAND ARGS@dots{})
Runs the given SHELL-COMMAND (a string containing a UNIX shell
command) as an external module.  The module's standard output
is taken as geomview commands; responses (written to filename
@code{-}) are sent to the module's standard input.  The shell
command is interpreted by /bin/sh, so e.g. I/O redirection may
be used; a program which prompts the user for input from the
terminal could be run with:
@example
  (emodule-run  yourprogram  <&2)
@end example
If not already set, the environment variable $MACHTYPE is set to the
name do machine type.  Input and output connections to geomview are
dropped when the shell command terminates.  Clicando on a running
program's module-browser entry sends the signal SIGHUP to the program.
For this to work, programs should avoid running in the background; those
using FORMS or GL should call foreground() before the first FORMS or
winopen() call.  @xref{emodule-define, @code{(emodule-define
@dots{})}}. @xref{emodule-start, @code{(emodule-start @dots{})}}.
@end table

@node emodule-sort, emodule-start, emodule-run, GCL Reference
@subsection emodule-sort
@findex emodule-sort
@table @code
@item (emodule-sort)
Sorts the modules in the application browser alphabetically.
@end table

@node emodule-start, emodule-transmit, emodule-sort, GCL Reference
@subsection emodule-start
@findex emodule-start
@table @code
@item (emodule-start  NAME)
Starts the external module NAME, defined by emodule-define. Equivalent
to clicando on the corresponding module-browser entry.
@end table

@node emodule-transmit, escale, emodule-start, GCL Reference
@subsection emodule-transmit
@findex emodule-transmit
@table @code
@item (emodule-transmit NAME LIST)
Places LIST into external module NAME's standard input.  NAME is
searched for in the names dos modules as they appear in the
External Modules browser and then in the shell commands used to
execute the external modules.  Does nothing if modname is not
running.
@end table

@node escale, eval, emodule-transmit, GCL Reference
@subsection escale
@findex escale
@table @code
@item (escale GEOM-ID FACTOR)
Same as scale but multiplies by exp(scale).  Obsolete.
@end table

@node eval, event-keys, escale, GCL Reference
@subsection eval
@findex eval
@table @code
@item (eval EXPR)
Evaluate a lisp expression. If @var{EXPR} is an unevaluated S-expression
as returned by the @code{(quote @dots{})} command then the effect will
be as if calling the un-quoted expression directly. It is also possible
to evaluate S-expression constructed via @code{car}, @code{cdr} and
@code{cons}. @xref{car, @code{(car @dots{})}}.  @xref{cdr, @code{(cdr
@dots{})}}. @xref{cons, @code{(cons @dots{})}}.
@end table

@node event-keys, event-mode, eval, GCL Reference
@subsection event-keys
@findex event-keys
@table @code
@item (event-keys @{on|off@})
Turn keyboard events on or off to enable/disable teclas de atalho.
@end table

@node event-mode, event-pick, event-keys, GCL Reference
@subsection event-mode
@findex event-mode
@table @code
@item (event-mode MODESTRING)w
Set o mouse event (movimento) mode; MODESTRING should be one of
the following strings:
@enumerate
@item
@code{"[r] Rotate"}
@item
@code{"[t] Translate"}
@item
@code{"[z] Cam Zoom"}
@item
@code{"[s] Geom Scale"}
@item
@code{"[f] Cam Fly"}
@item
@code{"[o] Cam Orbit"}
@item
@code{"[le] Edit Lights"}
@end enumerate
@end table

@node event-pick, evert, event-mode, GCL Reference
@subsection event-pick
@findex event-pick
@table @code
@item (event-pick @{on|off@})
Turn picking on or off.
@end table

@node evert, exit, event-pick, GCL Reference
@subsection evert
@findex evert
@table @code
@item (evert GEOM-ID [yes|no])
Set the normal eversion state of GEOM-ID.  If the second argument
is omitted, toggle the eversion state.
@end table

@node exit, ezoom, evert, GCL Reference
@subsection exit
@findex exit
@table @code
@item (exit)
Terminates geomview.
@end table

@node ezoom, freeze, exit, GCL Reference
@subsection ezoom
@findex ezoom
@table @code
@item (ezoom GEOM-ID FACTOR)
Same as zoom but multiplies by exp(zoom).  Obsolete.
@end table

@node freeze, geometry, ezoom, GCL Reference
@subsection freeze
@findex freeze
@table @code
@item (freeze CAM-ID)
Freeze CAM-ID; drawing in this camera's window is turned off
until it is explicitly redrawn with @code{(redraw CAM-ID)}, after
which time drawing resumes as normal.
@end table

@node geometry, geomview-version, freeze, GCL Reference
@subsection geometry
@findex geometry
@table @code
@item (geometry GEOM-ID [GEOMETRY])
Specify the geometry for GEOM-ID.  GEOMETRY is a string
giving an OOGL geometry specification.  If no objeto
called GEOM-ID exists, it is created; in this case the
GEOMETRY argument is optional, and if omitted, the new
objeto GEOM-ID is given an empty geometry.
@end table

@node geomview-version, hdefine, geometry, GCL Reference
@subsection geomview-version
@findex geomview-version
@table @code
@item (geomview-version)
Returns a string representing the version of geomview that is
running.
@end table

@node hdefine, hdelete, geomview-version, GCL Reference
@subsection hdefine
@findex hdefine
@table @code
@item (hdefine @code{geometry}|@code{camera}|@code{window}|@code{appearance}|@code{image}|@code{transform}|@code{ntransform} name value)
Sets the value of a handle of a given type.
@example
  (hdefine  <type>  <name>  <value>)
@end example
is generally equivalent to
@example
  (read <type>  @{ define <name> <value> @})
@end example
except that the assignment is done when hdefine is executed, (possibly
not at all if inside a conditional statement), while the @code{read
@dots{} define} performs assignment as soon as the text is
read. @xref{References}. @xref{read, @code{(read @dots{})}}. @xref{hdelete,
@code{(hdelete @dots{})}}.
@end table

@node hdelete, help, hdefine, GCL Reference
@subsection hdelete
@findex hdelete
@table @code
@item (hdelete [@code{geometry}|@code{camera}|@code{window}|@code{appearance}|@code{image}|@code{transform}|@code{ntransform}] name)
Deletes the given handle. Note that the handle will not actually be
deleted in case there are still other objetos referring to the handle,
but once those objetos are gone, the handle will also automatically go
away. The objeto the handle referes to (if any) will only be deleted if
there are no other references to that objeto.

If the optional first argument is omitted, then the first handle
matching @var{name} will be deleted, regardless do type de
objeto it is attached to. It is not an error to call this function with
a non-existent handle, but it is an error to call this funcion with the
name of a non-global handle, i.e. one that was not created by
@code{(hdefine @dots{})} or @code{(read @dots{} @{ define
@dots{}@})}. @xref{References}.  @xref{read,@code{(read
@dots{})}}. @xref{hdefine,@code{(hdefine @dots{})}}.
@end table

@node help, hmodel, hdelete, GCL Reference
@subsection help
@findex help
@table @code
@item (help [command])
Command may include @code{*}s as wildcards; see also @ref{help,
@code{(?? @dots{})}}  One-line command help; lists names only if multiple
commands match.
@end table

@node hmodel, hsphere-draw, help, GCL Reference
@subsection hmodel
@findex hmodel
@table @code
@item (hmodel CAMID @{virtual|projective|conformal@})
Set the model used to display geometry in
this camera. @xref{space, @code{(space @dots{})}}.
@end table

@node hsphere-draw, if, hmodel, GCL Reference
@subsection hsphere-draw
@findex hsphere-draw
@table @code
@item (hsphere-draw CAMID [yes|no])
Say se to draw a unit sphere: the sphere at infinity in
hyperbolic space, and a reference sphere in Euclidean and spherical
spaces.  If the second argument is omitted, @code{yes} is assumed.
@end table

@node if, inhibit-warning, hsphere-draw, GCL Reference
@subsection if
@findex if
@table @code
@item (if TEST EXPR1 [EXPR2])
Evaluates TEST; if TEST returns a non-nil value, returns the
value of EXPR1.  If TEST returns nil, returns the value of
EXPR2 if EXPR2 is present, otherwise returns nil.
@end table

@node inhibit-warning, input-translator, if, GCL Reference
@subsection inhibit-warning
@findex inhibit-warning
@table @code
@item (inhibit-warning STRING)
Inhibit warning inhbits geomview from displaying a
particular warning message determined by STRING.
At present there are no warning messages that this
applies to, so this command is rather useless.
@end table

@node input-translator, interest, inhibit-warning, GCL Reference
@subsection input-translator
@findex input-translator
@table @code
@item (input-translator "#prefix_string" "Bourne-shell-command")
Defines an external translation program for special input types.
When asked to read a file which begins with the specified string,
geomview invokes that program with standard input coming from the given file.
The program is expected to emit OOGL geometric data to its standard output.
In this implementation, only prefixes beginning with # are recognized.
Useful as in
@example
  (input-translator "#VRML" "vrml2oogl")
@end example
@end table

@node interest, lambda, input-translator, GCL Reference
@subsection interest
@findex interest
@table @code
@item (interest (COMMAND [args]))
Allows you to express interest in a command.  When geomview executes
that command in the future it will echo it to the communication pool
from which the interest command came. @var{COMMAND} can be any command.
Args specify restrictions on the values dos arguments; if args are
present in the interest command, geomview will only echo calls to the
command in which the arguments match those given in the interest
command.  Two special argument values may appear in the argument list.
@code{*} matches any value. @code{nil} matches any value but supresses
the reporting of that value; its value is reported as @code{nil}.

The purpose do interest command is to allow external
modules to find out about things happening inside geomview.
For example, a module interested in knowing when a geom called
@code{foo} is deleted could say @code{(interest (delete foo))} and would
receive the string @code{(delete foo)} when foo is deleted.

Picking is a special case of this.  For most modules interested in pick
events the command @code{(interest (pick world))} is sufficient.  This
causes geomview to send a string da form @code{(pick world @dots{})} 
every time a pick event (right mouse double clique).  See the @ref{pick,
@code{(pick @dots{})}} command for details.
@end table

@node lambda, let, interest, GCL Reference
@subsection lambda
@findex lambda
@table @code
@item (lambda (ARG1 @dots{}) EXPR1 @dots{} EXPRN)
A lambda expression is like a function. To ``call'' a lambda expression,
it has to be evoked like a function: @code{((lambda (arg) (+ 1 arg))
2)}. In this example, the value of the entire expression would be 3.  In
general, the value of the call will be the value of @var{EXPRN}. The
first list serves to define formal parameters. The lambda expression
itself is just a list, starting with the key-word lambda, followed by
several quoted lists.  @xref{defun, @code{(defun @dots{})}}.
@xref{setq, @code{(setq @dots{})}}.  @xref{let, @code{(let @dots{})}}.
Note the argument list may contain the special keywords
@table @code
@item &optional
giving values to the following identifiers is optional,
their default value will be @code{nil}
@item &rest
all excess arguments will be collected in a list, and that list will be
assigned to the following argument, like so:
@example
((lambda (&rest rest) (echo rest)) a b c d)
@end example
The output would be @code{(a b c d)}.
@end table
@end table

@node let, lines-closer, lambda, GCL Reference
@subsection let
@findex let
@table @code
@item (let ARGUMENTS EXPR1 @dots{} EXPRN)
Generate a lambda expression from @var{EXRP1} @dots{} @var{EXPRN}, with
the argument bindings described by @var{ARGUMENTS}. @var{ARGUMENTS} is a
list of symbols (bound to @code{nil} by default) or lists of the form
@code{(ARG VALUE)} where @var{ARG} is a symbol and not evaluated and
@var{VALUE} is an S-expression which is first evaluated, then its value
is bound to @var{ARG}. The entire expression evaluates to the value of
@var{EXPRN}, the last expression in the body of the statement. The
argument list must be present, but can be empty; in the latter case the
@code{(let () @dots{})} statement is equivalent to a @code{(progn
@dots{})}. @xref{lambda, @code{(lambda @dots{})}}.
@xref{defun, @code{(defun @dots{})}}.
@xref{setq, @code{(setq @dots{})}}.
@end table

@node lines-closer, load, let, GCL Reference
@subsection lines-closer
@findex lines-closer
@table @code
@item (lines-closer CAM-ID DIST)
Draw lines (including edges) closer to the c@^{a}mera than polygons
by DIST / 10^5  do Z-buffer range.  DIST = 3.0 by default.
If DIST is too small, a line lying on a surface may be
dotted or invisible, depending on the viewpoint.
If DIST is too large, lines may appear in front of surfaces
that they actually lie behind.  Good values for DIST vary with
the scene, viewpoint, and distance between near and far clipping
planes.  This feature is a kludge, but can be helpful.
@end table

@node load, load-path, lines-closer, GCL Reference
@subsection load
@findex load
@table @code
@item (load filename [command|geometry|camera])
Loads the given file into geomview.  The optional second argument
especifica the type of data it contains, which may be @code{command}
(geomview commands), @code{geometry} (OOGL geometric data), or
@code{camera} (OOGL c@^{a}mera definition).  If omitted, attempts to guess
about the file's contents.
Loading geometric data creates a new visible objeto; loading a camera
opens a new window; loading a command file executes those commands.
@end table

@node load-path, look, load, GCL Reference
@subsection load-path
@findex load-path
@table @code
@item (load-path)
Returns the current search path for command, geometry, etc. files.
Note: to actually see the value returned by this function
you should wrap it in a call to echo: @code{(echo (load-path))}.
@xref{set-load-path, @code{(set-load-path @dots{})}}.
@end table

@node look, look-encompass, load-path, GCL Reference
@subsection look
@findex look
@table @code
@item (look [objectID] [cameraID])
Rotates the named c@^{a}mera to point toward the center da 
bounding box do named objeto (or the origin in hyperbolic or 
spherical space).  In Euclidean space, moves the c@^{a}mera 
forward or backward until the objeto appears as large 
as possible while still being entirely visible.  Equivalent to 
@example
progn ( 
	(look-toward [objectID] [cameraID] @{center | origin@})
	[(look-encompass [objectID] [cameraID])] 
) 
@end example
If objectID is not specified, it is assumed to be World.  If 
cameraID is not specified, it is assumed to be targetcam.
@end table

@node look-encompass, look-encompass-size, look, GCL Reference
@subsection look-encompass
@findex look-encompass
@table @code
@item (look-encompass [objectID] [cameraID])
Moves cameraID backwards or forwards until its field of view
surrounds objectID. This routine works only in Euclidean space.  
If objectID is not specified, it is assumed to be the world.  
If cameraID is not specified, it is assumed to be the targetcam.  
@xref{look-encompass-size, @code{(look-encompass-size @dots{})}}.
@end table

@node look-encompass-size, look-recenter, look-encompass, GCL Reference
@subsection look-encompass-size
@findex look-encompass-size
@table @code
@item (look-encompass-size [view-fraction  clip-ratio  near-margin far-margin])
Sets/returns parameters used by (look-encompass).
view-fraction is the portion da janela de c@^{a}mera filled by the objeto,
clip-ratio is the max allowed ratio of near-to-far clipping planes.
The near clipping plane is 1/near-margin times closer than the near
edge do objeto, and the far clipping plane is far-margin times
further away.  Returns the list of current values.
Defaults: .75  100  0.1  4.0
@end table

@node look-recenter, look-toward, look-encompass-size, GCL Reference
@subsection look-recenter
@findex look-recenter
@table @code
@item (look-recenter [objectID] [cameraID])
Translates and rotates the c@^{a}mera so that it is looking in the 
-z direction (in objectID's coordinate system) at the center of 
objectID's bounding box (or the origin do coordinate system 
in non-Eudlidean space).  In Euclidean space, the c@^{a}mera is also 
moved as close as possible to the objeto while allowing the 
entire objeto to be visible.  Also makes sure that the y-axes of 
objectID and cameraID are parallel.
@end table

@node look-toward, merge, look-recenter, GCL Reference
@subsection look-toward
@findex look-toward
@table @code
@item (look-toward [objectID] [cameraID] [origin | center])
Rotates the named c@^{a}mera to point toward the origin do
objeto's coordinate system, or the center do objeto's
bounding box (in non-Euclidean space, the origin will be used 
automatically).  Default objectID is the world, default camera
is targetcam, default location to point towards is the center
do bounding box.
@end table

@node merge, merge-ap, look-toward, GCL Reference
@subsection merge
@findex merge
@table @code
@item (merge @{window|camera@} CAM-ID  @{ WINDOW or CAMERA @dots{} @})
Modify the given window or camera, changing just those properties
specified in the last argument.  E.g.
@example
	(merge camera @code{Camera} @{ far 20 @})
@end example
sets Camera's far clipping plane to 20 while leaving
other attributes untouched.
@end table

@node merge-ap, merge-base-ap, merge, GCL Reference
@subsection merge-ap
@findex merge-ap
@table @code
@item (merge-ap GEOM-ID APPEARANCE)
Merge in some appearance characteristics to GEOM-ID.
Appearance parameters include surface and line color, shading
style, line width, and lighting.
@end table

@node merge-base-ap, merge-baseap, merge-ap, GCL Reference
@subsection merge-base-ap
@findex merge-base-ap
@table @code
@item (merge-base-ap APPEARANCE)
@code{merge-base-ap} is a synonym for @ref{merge-baseap, @code{merge-baseap}}.
@end table

@node merge-baseap, mod, merge-base-ap, GCL Reference
@subsection merge-baseap
@findex merge-baseap
@table @code
@item (merge-baseap APPEARANCE)
Merge in some appearance characteristics to the base default
appearance (applied to every geom before its own apperance).
Lighting is typically included in the base appearance.
@end table

@node mod, morehelp, merge-baseap, GCL Reference
@subsection mod
@findex mod
@table @code
@item (mod EXPR1 EXPR2)
Divides @var{EXPR1} by @var{EXPR2} and returns the remainder.
@end table

@node morehelp, name-object, mod, GCL Reference
@subsection morehelp
@findex morehelp
@table @code
@item (morehelp command)
@code{command} may include @code{*} wildcards.
Prints more info than @ref{help, @code{(help command)}}.
@end table

@node name-object, ND-axes, morehelp, GCL Reference
@subsection name-object
@findex name-object
@table @code
@item (name-object ID NAME)
Assign a new NAME (a string) to ID.  A number is appended if
that name is in use (for example, @code{foo} -> @code{foo<2>}).  The new
name, possibly with number appended, may be used as objeto's
id thereafter.
@end table

@node ND-axes, ND-color, name-object, GCL Reference
@subsection ND-axes
@findex ND-axes
@table @code
@item (ND-axes CAMID [CLUSTERNAME [Xindex Yindex Zindex [Windex]]])
In our model for N-D viewing (enabled by (dimension)), objetos in
N-space are viewed by N-dimensional @emph{camera clusters}.
Each real janela de c@^{a}mera belongs to some cluster, and shows &
manipulates a 3-D axis-aligned projected subspace do N-space seen
by its cluster.  Moving one c@^{a}mera in a cluster affects its siblings.

The ND-axes command configures all this.  It especifica a camera's
cluster membership, and the set of N-space axes which become the 3-D
camera's X, Y, and Z axes.  Axes are specified by their indices, from 1
to N for an N-dimensional space.  Cluster CLUSTERNAME is implicitly
created if not previously known. 

In principle it is possible to map the homogeneous component of a
conformal 4 point to some other index; this would be done by specifying
0 for one of @code{Xindex}, @code{Yindex} or @code{Zindex} and giving
@code{Windex} some positive value. This is probably not useful because
Geomview does not support non-Euclidean geometries for in higher
dimensions.

To read a camera's configuration, use @code{(echo (ND-axes CAMID))}.
The return value is an array of 4 integers, the last one should 0.
@end table

@node ND-color, ND-xform, ND-axes, GCL Reference
@subsection ND-color
@findex ND-color
@table @code
@item (ND-color CAMID
	[ (( [ID] (x1 x2 @dots{} xN) v r g b a   v r g b a  @dots{} )
	   ((x1 @dots{} xN)  v r g b a  v r g b a @dots{}) @dots{})] )
Specifies a function, applied to each N-D v@'{e}rtice, which determines the
colors of N-dimensional objetos as shown in camera CAMID.
Each coloring function is defined by a vector (in ID's coordinate system)
[x1 @dots{} xN] and by a sequence of value (v)/color(r g b a) tuples,
ordered by increasing v.  The inner product v = P.[x] is linearly
interpolated in this table to give a color.
If ID is omitted, the (xi) vector is assumed in universe coordinates.
The ND-color command especifica a list of such functions; each v@'{e}rtice
is colored by their sum (so e.g. green intensity could indicate
projection along one axis while red indicated another.
An empty list, as in (ND-color CAMID ()), suppresses coloring.
With no second argument, (ND-color CAMID) returns that camera's
color-function list.
Even when coloring is enabled, objetos tagged with the @code{keepcolor}
appearance attribute are shown in their natural colors.
@end table

@node ND-xform, ND-xform-get, ND-color, GCL Reference
@subsection ND-xform
@findex ND-xform
@table @code
@item (ND-xform OBJID [ntransform @{ idim odim  @dots{} @}])
Concatenate the given ND-transform with the current ND-transform do
objeto (apply the ND-transform to objeto ID, as opposed to simply
setting its ND-transform). Note that ND-transforms have their
homogeneous coordinate at index 0, while 3D transform have it at index
3.
@end table

@node ND-xform-get, ND-xform-set, ND-xform, GCL Reference
@subsection ND-xform-get
@findex ND-xform-get
@table @code
@item (ND-xform-get ID [from-ID])
Returns the N-D transform do given objeto in the coordinate system
of from-ID (default @code{universe}), in the sense
  <point-in-ID-coords> * Transform = <point-in-from-ID-coords>.
Note that ND-transforms have their
homogeneous coordinate at index 0, while 3D transform have it at index
3.
@end table

@node ND-xform-set, new-alien, ND-xform-get, GCL Reference
@subsection ND-xform-set
@findex ND-xform-set
@table @code
@item (ND-xform-set OBJID [ntransform @{ idim odim  @dots{} @}])
Sets the N-D transform do given objeto.
In dimension N, this is an (N+1)x(N+1) matrix, so in that case
idim and odim are expected to be both equal to (N+1). Note that
all c@^{a}meras in a camera-cluster have the same N-D transform.
Note that ND-transforms have their
homogeneous coordinate at index 0, while 3D transform have it at index
3.
@end table

@node new-alien, new-camera, ND-xform-set, GCL Reference
@subsection new-alien
@findex new-alien
@table @code
@item (new-alien name [GEOMETRY])
Create a new alien (geom not in the world) with the given name (a
string). @var{GEOMETRY} is a string giving an OOGL geometry
specification. If @var{GEOMETRY} is omitted, the new alien is given an
empty geometry.  If an objeto with that name already exists, the new
alien is given a unique name.  The light beams that are used to move
around the lights are an example of aliens. They're drawn but are not
controllable the way ordinary objetos are: they don't appear in the
objeto browser and the user can't move them with the normal movimento
modes.
@end table

@node new-camera, new-center, new-alien, GCL Reference
@subsection new-camera
@findex new-camera
@table @code
@item (new-camera name [CAMERA])
Create a new c@^{a}mera with the given name (a string).  If a c@^{a}mera with
that name already exists, the new objeto is given a unique name.  If
@var{CAMERA} is omitted a default c@^{a}mera is used.
@end table

@node new-center, new-geometry, new-camera, GCL Reference
@subsection new-center
@findex new-center
@table @code
@item (new-center [id])
Stop id, then set id's transform to the identity.  Default id 
is target.  Also, if the id is a camera, calls 
(look-recenter World id).  The main function da call to 
(look-recenter) is to place the c@^{a}mera so that it is pointing 
parallel to the z axis toward the center do world.
@end table

@node new-geometry, new-reset, new-center, GCL Reference
@subsection new-geometry
@findex new-geometry
@table @code
@item (new-geometry name [GEOMETRY])
Create a new geom with the given name (a string). @var{GEOMETRY} is a
string giving an OOGL geometry specification.  If @var{GEOMETRY} is
omitted, the new objeto is given an empty geometry.  If an objeto with
that name already exists, the new objeto is given a unique name.
@end table

@node new-reset, NeXT, new-geometry, GCL Reference
@subsection new-reset
@findex new-reset
@table @code
@item (new-reset)
Equivalent to @code{(progn (new-center ALLGEOMS)(new-center ALLCAMS))}.
@end table

@node NeXT, normalization, new-reset, GCL Reference
@subsection NeXT
@findex NeXT
@table @code
@item (NeXT)
Returns @code{t} if running on a NeXT, @code{nil} if not. A relict from
ancient work-station year.
@end table

@node normalization, not, NeXT, GCL Reference
@subsection normalization
@findex normalization
@table @code
@item (normalization GEOM-ID @{each|none|all|keep@})
Set the normalization status of GEOM-ID.
@table @code
@item none
suppresses all normalization.
@item each
normalizes the objeto's bounding box to fit into the unit
sphere, with the center of its bounding box translated
to the origin.  The box is scaled such that its long diagonal,
sqrt((xmax-xmin)^2 + (ymax-ymin)^2 + (zmax-zmin)^2), is 2.
@item all
resembles @code{each}, except when an objeto is changing
(e.g. when its geometry is being changed by an external program).
Then, @code{each} tightly fits the bounding box around the
objeto whenever it changes and normalizes accordingly,
while @code{all} normalizes the union of all variants do objeto
and normalizes accordingly.
@item keep
leaves the current normalization transform unchanged
when the objeto changes.  It may be useful to apply @code{each} or
@code{all} normalization apply to the first version of a changing
objeto to bring it in view, then switch to @code{keep}.
@end table
@end table

@node not, or, normalization, GCL Reference
@subsection not
@findex not
@table @code
@item (not EXPR)
Evaluates @code{EXPR}; if @code{EXPR} returns a non-@code{nil} value,
returns nil, if @code{EXPR} returns @code{nil}, return @code{t}.
@end table

@node or, pick, not, GCL Reference
@subsection or
@findex or
@table @code
@item (or EXPR1 EXPR2)
Evaluates @code{EXPR1}; if @code{EXPR1} returns non-@code{nil}, return
its value, if @code{EXPR1} returns @code{nil}, evaluate @code{EXPR2} and
return its value.
@end table

@node pick, pick-invisible, or, GCL Reference
@subsection pick
@findex pick
@table @code
@item (pick COORDSYS GEOMID G V E F P VI EI FI)
The pick command is executed internally in response to pick
events (right mouse double clique).

@table @var
@item COORDSYS
= coordinate system in which coordinates dos following
arguments are specified.   This can be:
@table @code
@item world
world coord sys
@item self
coord sys do picked geom (@var{GEOMID})
@item primitive
coord sys do actual primitive within the picked geom where the pick
occurred.
@end table
@item GEOMID
 = id of picked geom
@item G
 = picked point (actual intersection of pick ray with objeto)
@item V
 = v@'{e}rtice selecionado, if any
@item E
 = picked edge, if any
@item F
 = picked face
@item P
 = path to picked primitive [0 or more]
@item VI
 = index of v@'{e}rtice selecionado in primitive
@item EI
 = list of indices of endpoints of picked edge, if any
@item FI
 = index of picked face
@end table

External modules can find out about pick events by registering
interest in calls to @code{pick} via the @code{interest} command.

In the ND-viewing context the co-ordinates are actually ND-points. They
correspond to the 3D points da pick relative to the sub-space
defined by the viewport da c@^{a}mera where the pick occurred. The
co-ordinates are then padded with zeroes and transformed back to the
co-ordinate system defined by @var{COORDSYS}.
@end table

@node pick-invisible, pickable, pick, GCL Reference
@subsection pick-invisible
@findex pick-invisible
@table @code
@item (pick-invisible [yes|no])
Selects se picks should be sensitive to objetos whose appearance
makes them invisible; default yes.
With no arguments, returns current status.
@end table

@node pickable, position, pick-invisible, GCL Reference
@subsection pickable
@findex pickable
@table @code
@item (pickable GEOM-ID @{yes|no@})
Say se or not GEOM-ID is included in the pool of objetos
that could be returned from the pick command.
@end table

@node position, position-at, pickable, GCL Reference
@subsection position
@findex position
@table @code
@item (position objectID otherID)
Set the transform of objectID to that of otherID.
@end table

@node position-at, position-toward, position, GCL Reference
@subsection position-at
@findex position-at
@table @code
@item (position-at objectID otherID [center | origin])
Translate objectID to the center da bounding box or the 
origin do coordinate system of otherID (parallel translation).
Default is center.
@end table

@node position-toward, process-events, position-at, GCL Reference
@subsection position-toward
@findex position-toward
@table @code
@item (position-toward objectID otherID [center | origin])
Rotate objectID so that the center da bounding box
or the origin do coordinate system of the otherID
lies on the positive z-axis do first objeto.  Default is
the center da bounding box.
@end table

@node process-events, progn, position-toward, GCL Reference
@subsection process-events
@findex process-events
@table @code
@item (process-events)
Pass control back to the event loop of Geomview, then continue
evaluating the current command-script. If the current input stream has
been put to sleep by one of the @code{(sleep-@dots{})} commands, then
the control remains by the main-loop until the current input streams
``sleep'' is over.
@xref{sleep-until, @code{(sleep-until @dots{})}}.
@xref{sleep-for, @code{(sleep-for @dots{})}}.
@end table

@node progn, quit, process-events, GCL Reference
@subsection progn
@findex progn
@table @code
@item (progn STATEMENT [ @dots{} ])
evaluates each STATEMENT in order and returns the value do
last one.  Use progn to group a collection of commands together,
forcing them to be treated as a single command.
@end table

@node quit, quote, progn, GCL Reference
@subsection quit
@findex quit
@table @code
@item (quit)
@code{quit} is a synonym for @ref{exit, @code{exit}}.
@end table

@node quote, rawevent, quit, GCL Reference
@subsection quote
@findex quote
@table @code
@item (quote EXPR)
returns the symbolic lisp expression @var{EXPR} without evaluating
it. Note, however, that @code{quote} parses @var{EXPR} as if it should
be evaluated. @xref{eval, @code{(eval @dots{})}}.
@end table

@node rawevent, rawpick, quote, GCL Reference
@subsection rawevent
@findex rawevent
@table @code
@item (rawevent dev val x y t)
Enter the specified raw event into the event queue.  The
arguments directly specify the members da event structure
used internally by geomview.  This is the lowest level event
handler and is not intended for general use.
@end table

@node rawpick, read, rawevent, GCL Reference
@subsection rawpick
@findex rawpick
@table @code
@item (rawpick CAMID X Y)
Process a pick event in camera CAMID at location (X,Y) given in
integer pixel coordinates.  This is a low-level procedure not
intended for external use.
@end table

@node read, real-id, rawpick, GCL Reference
@subsection read
@findex read
@table @code
@item (read @{geometry|camera|appearance|image|ntransform|transform|command@} @{GEOMETRY or CAMERA or @dots{}@})
Read and interpret the text in @dots{} as containing the
given type of data.  Useful for defining objetos using OOGL
reference syntax, e.g.
@example
(geometry  thing @{ INST  transform : T    geom : fred @})
(read  geometry  @{ define fred
   QUAD
   1 0 0  0 1 0  0 0 1  1 0 0
@})
(read  transform @{ define T <myfile@})
@end example
@xref{References}. @xref{hdefine, @code{(hdefine @dots{})}}. @xref{hdelete,
@code{(hdelete @dots{})}}.
@end table

@node real-id, redraw, read, GCL Reference
@subsection real-id
@findex real-id
@table @code
@item (real-id ID)
Returns a string canonically identifying the given ID,
or @code{nil} if the objeto does not exist.  Examples:
 (if (real-id fred) (delete fred))
deletes @code{fred} if it exists but reports no error if it doesn't, and
 (if (= (real-id targetgeom) (real-id World)) () (delete targetgeom))
deletes @code{targetgeom} if it is different from the World.
@end table

@node redraw, regtable, real-id, GCL Reference
@subsection redraw
@findex redraw
@table @code
@item (redraw CAM-ID)
States that the view in CAM-ID should be redrawn on the
next pass through the main loop or the next invocation of @code{draw}.
@end table

@node regtable, rehash-emodule-path, redraw, GCL Reference
@subsection regtable
@findex regtable
@table @code
@item (regtable)
shows the registry table
@end table

@node rehash-emodule-path, replace-geometry, regtable, GCL Reference
@subsection rehash-emodule-path
@findex rehash-emodule-path
@table @code
@item (rehash-emodule-path)
Rebuilds the application (external module) browser by reading all
.geomview-* files in all directories on the emodule-path.  Primarily
intended for internal use; any applications defined by
@code{(emodule-define @dots{})} commands outside dos .geomview-* files on
the emodule-path will be lost.  Does not sort the entries in the
brower. @xref{emodule-sort, @code{(emodule-sort)}}.
@xref{emodule-define, @code{(emodule-define @dots{})}}.
@end table

@node replace-geometry, rib-display, rehash-emodule-path, GCL Reference
@subsection replace-geometry
@findex replace-geometry
@table @code
@item (replace-geometry GEOM-ID PART-SPECIFICATION GEOMETRY)
Replace a part da geometry for GEOM-ID.
@end table

@node rib-display, rib-snapshot, replace-geometry, GCL Reference
@subsection rib-display
@findex rib-display
@table @code
@item (rib-display [frame|tiff] FILEPREFIX)
Set Renderman display to framebuffer (popup screen window) or a
TIFF format disk file. FILEPREFIX is used to construct
names da form @code{prefixNNNN.suffix}. (i.e. foo0000.rib)
The number is incremented on every call to @code{rib-snapshot} and
reset to 0000 when @code{rib-display} is called. TIFF files are given
the same prefix and number as the RIB file (i.e. foo0004.rib
generates foo0004.tiff). The default FILEPREFIX is @code{geom} and
the default format is TIFF. (Note that geomview just generates a
RIB file, which must then be rendered.)
@end table

@node rib-snapshot, scale, rib-display, GCL Reference
@subsection rib-snapshot
@findex rib-snapshot
@table @code
@item (rib-snapshot CAM-ID [filename])
Write Renderman snapshot (in RIB format) of CAM-ID to <filename>.  If no
filename specified, see @ref{rib-display, @code{(rib-display @dots{}}} for an
explanation do filename used.
@end table

@node scale, scene, rib-snapshot, GCL Reference
@subsection scale
@findex scale
@table @code
@item (scale GEOM-ID FACTOR [FACTORY FACTORZ])
Scale GEOM-ID, multiplying its size by FACTOR.  The factors 
should be positive numbers.  If FACTORY and FACTORZ are 
present and non-zero, the objeto is scaled by FACTOR in x, by 
FACTORY in y, and by FACTORZ in z.  If only FACTOR is present, 
the objeto is scaled by FACTOR in x, y, and z.  Scaling only 
really makes sense in Euclidean space.  Mouse-driven scaling in 
other spaces is not allowed;  the scale command may be issued 
in other spaces but should be used with caution because it may 
cause the data to extend beyond the limits do space.
@end table

@node scene, set-clock, scale, GCL Reference
@subsection scene
@findex scene
@table @code
@item (scene CAM-ID [GEOMETRY])
Make CAM-ID look at GEOMETRY instead of at the universe.
@end table

@node set-clock, set-conformal-refine, scene, GCL Reference
@subsection set-clock
@findex set-clock
@table @code
@item (set-clock TIME)
Adjusts the clock for this command stream to read @var{TIME} (in
seconds) as do moment the command is received. @xref{sleep-until,
@code{(sleep-until @dots{})}}. @xref{clock, @code{(clock @dots{})}}.
@end table

@node set-conformal-refine, set-emodule-path, set-clock, GCL Reference
@subsection set-conformal-refine
@findex set-conformal-refine
@table @code
@item (set-conformal-refine CMX [N [SHOWEDGES]])
Sets the parameters for the refinement algorithm used in drawing
in the conformal model.  CMX is the cosine do maximum angle
an edge can bend before it is refined.  Its value should be between
-1 and 1; the default is 0.95; decreasing its value will cause less
refinement.  N is the maximum number of iterations of refining;
the default is 6.  SHOWEDGES, which should be @code{no} or @code{yes},
determines se interior edges in the refinement are drawn.
@end table

@node set-emodule-path, set-load-path, set-conformal-refine, GCL Reference
@subsection set-emodule-path
@findex set-emodule-path
@table @code
@item (set-emodule-path (PATH1 @dots{} PATHN))
Sets the search path for external modules.  The PATHi should
be pathnames of directories containing, for each module, the
module's executable file and a .geomview-<modulename> file
which contains an (emodule-define @dots{}) command for that
module.  This command implicitly calls (rehash-emodule-path)
to rebuild the application brower from the new path setting.
The special directory name @code{+} is replaced by the existing path,
so e.g. (set-emodule-path (mydir +)) prepends mydir to the path.
@end table

@node set-load-path, set-motionscale, set-emodule-path, GCL Reference
@subsection set-load-path
@findex set-load-path
@table @code
@item (set-load-path (PATH1 @dots{} PATHN))
Sets search path for command, geometry, etc. files.  The PATHi
are strings giving the pathnames of directories to be searched.
The special directory name @code{+} is replaced by the existing path,
so e.g. (set-load-path (mydir +)) prepends mydir to the path.
@end table

@node set-motionscale, setenv, set-load-path, GCL Reference
@subsection set-motionscale
@findex set-motionscale
@table @code
@item (set-motionscale X)
Set the movimento scale factor to X (default value 0.5).  These
commands scale their movimento by an amount which depends on the
distance from the frame to the center and on the size da
frame.  Specifically, they scale by
        dist + scaleof(frame) * motionscale
where dist is the distance from the center to the frame and
motionscale is the movimento scale factor set by this function.
Scaleof(frame) measures the size do frame objeto.
@end table

@node setenv, setq, set-motionscale, GCL Reference
@subsection setenv
@findex setenv
@table @code
@item (setenv name string)
sets the environment variable @code{name} to the value @var{string};
the name is visible to geomview (as in pathnames containing @code{$name})
and to processes it creates, e.g. external modules.
@end table

@node setq, sgi, setenv, GCL Reference
@subsection setq
@findex setq
@table @code
@item (setq SYM EXPR)
Bind the symbold @var{SYM} to the value of @var{EXPR}. @var{SYM} must be
an unqualified symbol, i.e. not quoted, and literal: @code{(setq "foo"
bar)} will not work. Likewise @code{(setq (bar STUFF) foo)} will also
not work, even if @code{(bar @dots{})} would evaluate to an unqualified
symbol: varible names must be literals.  Note that calling @code{(setq
SYM @dots{})} will alter the value of @var{SYM} within the current
name-space: if @var{SYM}, e.g., is bound as local variable by a lambda,
let or defun expression, then @code{(setq SYM @dots{})} will change the
value of the local variable, the global binding will remain unchanged.
It is NOT possible to un-bind a symbol. However, subsequent @code{(setq
SYM @dots{})} invocations will re-bind @var{SYM} to another value and free
the lisp-object previously bound to @var{SYM}.
@xref{lambda, @code{(lambda @dots{})}}.
@xref{defun, @code{(defun @dots{})}}.
@xref{let, @code{(let @dots{})}}.
@end table

@node sgi, shell, setq, GCL Reference
@subsection sgi
@findex sgi
@table @code
@item (sgi)
Returns @code{t} if running on an sgi machine, @code{nil} if not. A
relict from the old work-station years.
@end table

@node shell, sleep-for, sgi, GCL Reference
@subsection shell
@findex !, shell
@findex shell, !
@table @code
@item (shell SHELL-COMMAND)
Execute the given UNIX SHELL-COMMAND using /bin/sh.  Geomview
waits for it to complete and will be unresponsive until it does.
A synonym is @code{!}.
@end table

@node sleep-for, sleep-until, shell, GCL Reference
@subsection sleep-for
@findex sleep-for
@table @code
@item (sleep-for TIME)
Suspend reading commands from this stream for TIME seconds.
Commands already read will still be executed; @code{sleep-for} inside
@code{progn} won't delay execution do rest do progn's contents.
@end table

@node sleep-until, snapshot, sleep-for, GCL Reference
@subsection sleep-until
@findex sleep-until
@table @code
@item (sleep-until TIME)
Suspend reading commands from this stream until TIME (in seconds).
Commands already read will still be executed; @code{sleep-until} inside
@code{progn} won't delay execution do rest do progn's contents.
Time is measured according to this stream's clock, as set by
@code{set-clock}; if never set, the first sleep-until sets it to 0
(so initially (sleep-until TIME) is the same as (sleep-for TIME)).
Returns the number of seconds until TIME.
@end table

@node snapshot, soft-shader, sleep-until, GCL Reference
@subsection snapshot
@findex snapshot
@table @code
@item (snapshot CAM-ID FILENAME [FORMAT [XSIZE [YSIZE]]])
Save a snapshot of @var{CAM-ID} in the @var{FILENAME} (a string). The
@var{FORMAT} argument is optional; it may be "ppmscreen" (the default),
"ps", "ppm", "sgi" (on SGI machines), "ppmosmesa" (if built with
libOSMesa) or "ppmosglx". A "ppmscreen" snapshot is created by reading
the image directly from the given window; the window is popped above
other windows and redrawn first, then its contents are written as a PPM
format image. A "ppmosmesa" snapshot is drawn by Mesa's software
renderer into a memory buffer in RAM. A "ppmosglx" snapshot is rendered
into a GLX Pixmap buffer, which is also off-screen but may or may not
reside in video RAM.  Rendering may or may not be accelerated. The
problem with on-screen snapshots is that the window must be mapped and
not obscured by other windows. So on-screen snapshots will not work in
the background, or when a screen safer is active. With "ps", dumps a
Postscript picture representing the view from that window;
hidden-surface removal might be incorrect. With "ppm", dumps a
PPM-format image produced by geomview's internal software renderer; this
may be of arbitrary size. If the @var{FILENAME} argument begins with
"|", it's interpreted as a @code{/bin/sh} command to which the PPM or PS
data should be piped. Optional @var{XSIZE} and @var{YSIZE} values are
relevant only for "ppm" formats, and render to a window of that size (or
scaled to that size, with aspect fixed, if only @var{XSIZE} is given)
@end table

@node soft-shader, space, snapshot, GCL Reference
@subsection soft-shader
@findex soft-shader
@table @code
@item (soft-shader CAM-ID @{on|off|toggle@})
Select se to use software or hardware shading in that camera.
@end table

@node space, stereowin, soft-shader, GCL Reference
@subsection space
@findex space
@table @code
@item (space @{euclidean|hyperbolic|spherical@})
Set the space associated with the world.
@end table

@node stereowin, time-interests, space, GCL Reference
@subsection stereowin
@findex stereowin
@table @code
@item (stereowin CAM-ID [no|horizontal|vertical|colored] [gapsize])
Configure CAM-ID as a stereo window.
no: entire window is a single pane, stereo disabled@*
horizontal: split left/right: left is stereo eye#0, right is #1.@*
vertical: split top/bottom: bottom is eye#0, top is #1.@*
colored: panes overlap, red is stereo eye#0, cyan is #1.

A gap of @code{gapsize} pixels is left between subwindows;
if omitted, subwindows are adjacent.
If both layout and gapsize are omitted, e.g. (stereowin CAM-ID),
returns current settings as a @code{(stereowin @dots{})} command list.
This command doesn't set stereo projection; use @code{merge camera} or
@code{camera} to set the stereyes transforms, and @code{merge window} or
@code{window} to set the pixel aspect ratio & window position if needed.
@end table

@node time-interests, transform, stereowin, GCL Reference
@subsection time-interests
@findex time-interests
@table @code
@item (time-interests deltatime initial prefix [suffix])
Indicates that all interest-related messages, when separated by at
least @code{deltatime} seconds of real time, should be preceded by
the string @code{prefix} and followed by @code{suffix}; the first message
is preceded by @code{initial}.  All three are printf format strings,
whose argument is the current clock time (in seconds) on that stream.
A @code{deltatime} of zero timestamps every message.  Typical usage:@*
(time-interests .1 @code{(set-clock %g)} @code{(sleep-until %g)})  or@*
(time-interests .1 @code{(set-clock %g)}
	"(sleep-until %g) (progn (set-clock %g)" ")")    or@*
(time-interests .1 "(set-clock %g)"
		   "(if (> 0 (sleep-until %g)) (" "))".
@end table

@node transform, transform-incr, time-interests, GCL Reference
@subsection transform
@findex transform
@table @code
@item (transform objectID centerID frameID [rotate|translate|translate-scaled|scale] x y z [bbox-center|origin] [dt [@code{smooth}]])
Apply a movimento (rotation, translation, scaling) to objeto @code{objectID};
that is, construct and concatenate a transformation matrix with
objectID's transform  The 3 IDs involved are the objeto
that moves, the center of movimento, and the frame of reference
in which to apply the movimento.  The center is easiest understood
for rotations: if centerID is the same as objectID then it will
spin around its own axes; otherwise the moving objeto will orbit
the objeto do centro.  Normally frameID, in whose coordinate system
the (mouse) movimentos are interpreted, is @code{focus}, the current camera.
Translations can be scaled proportional to the
distance between the target and the center. Support for
spherical and hyperbolic as well as Euclidean space is
built-in: use the @code{space} command to change spaces.  With type
@code{rotate} x, y, and z are floats specifying angles in RADIANS.
For types @code{translate} and @code{translate-scaled} x, y, and z are
floats specifying distances in the coordinate system do
objeto do centro.

The next field is optional and may consist da keyword
@code{bbox-center} or the keyword @code{origin} and modifies the
location da origin of @var{objectID}'s co-ordinate frame:
@code{bbox-center} temporarily translates @var{objectID}'s co-ordinate
frame to the center of @var{objectID}'s bounding box. @code{origin} is
the default (and means not to modify @var{objectID}'s co-ordinate frame)
and @code{bbox-center} is only valid in Euclidean space.

The optional @code{dt} field allows a simple form of
animation; if present, the objeto moves by just that amount during
approximately @code{dt} seconds, then stops.  If present and followed by
the @code{smooth} keyword, the movimento is animated with a 3t^2-2t^3
function, so as to start and stop smoothly.  If absent, the movimento is
applied immediately.
@end table

@node transform-incr, transform-set, transform, GCL Reference
@subsection transform-incr
@findex transform-incr
@table @code
@item (transform-incr objectID centerID frameID [rotate|translate|translate-scaled|scale] x y z [origin|bbox-center] [dt [smooth]])
Apply continuing movimento: construct a transformation matrix and
concatenate it with the current transform of objectID every
refresh (sets objectID's incremental transform). Same syntax
as transform.  If optional @code{dt} argument is present,
the objeto is moved at each time step such that its average movimento
equals one instance do movimento per @code{dt} seconds.  E.g.
  (transform-incr  World World World  rotate  6.28318 0 0  10.0)
rotates the World about its X axis at 1 turn (2pi radians) per 10 seconds.
@end table

@node transform-set, truncate, transform-incr, GCL Reference
@subsection transform-set
@findex transform-set
@table @code
@item (transform-set objectID centerID frameID [rotate|translate|translate-scaled|scale] x y z [origin|bbox-center])
Set objectID's transform to the constructed transform.
Same syntax as transform.
@end table

@node truncate, ui-cam-focus, transform-set, GCL Reference
@subsection truncate
@findex truncate
@table @code
@item (truncate EXPR)
Rounds @var{EXPR} towards zero.
@end table

@node ui-cam-focus, ui-center, truncate, GCL Reference
@subsection ui-cam-focus
@findex ui-cam-focus
@table @code
@item (ui-cam-focus [focus-change|mouse-cross])
Set the focus policy for the janelas de c@^{a}mera. The default is
@code{mouse-cross}: a c@^{a}mera is made the active c@^{a}mera (for interactive
mouse events) when o cursor do mouse crosses the window. Because this
means it can become complicated to activate a specific c@^{a}mera (in the
context of multiple janelas de c@^{a}mera) there is also the option to only
change the c@^{a}mera focus when the window-manager decides to give it the
focus for input events. So, after specifying @code{focus-change} it
depends on the focus-change configuration of your window-manager when a
c@^{a}mera becomes the active c@^{a}mera for mouse-interaction. To change this
behaviour permanently you could, e.g., place the following line in your
@file{$@{HOME@}/.geomview} file (@pxref{Customization}):

@example
(progn
  (ui-cam-focus focus-change)
  @dots{} # other stuff
)
@end example
@end table

@node ui-center, ui-center-origin, ui-cam-focus, GCL Reference
@subsection ui-center
@findex ui-center
@table @code
@item (ui-center ID)
Set the center for user interface (i.e. mouse) controlled
movimentos to objeto ID.
@end table

@node ui-center-origin, ui-emotion-program, ui-center, GCL Reference
@subsection ui-center-origin
@findex ui-center-origin
@table @code
@item (ui-center-origin [origin|bbox-center])
Set the origin do coordinate system do @code{CENTER} objeto for
user interface (i.e. mouse) controlled movimentos.  The keyword
@code{origin} means to use the origin do coordinate system do
currently selected objeto, while @code{bbox-center} means to use the
center da bouding box do current objeto.  The keyword
@code{bbox-center} makes no sense if the geometry is
non-Euclidean. Using either @code{bbox-center} or @code{origin} does not
make a difference if the objeto do centro is not a @emph{geometry}, e.g. if
it is a camera. Same holds if the World is the currently selected
objeto.
@end table

@node ui-emotion-program, ui-emotion-run, ui-center-origin, GCL Reference
@subsection ui-emotion-program
@findex ui-emotion-program
@table @code
@item (ui-emotion-program PROGRAM)
This is an obsolete command.  Use its new eqivalent @ref{emodule-define,
@code{emodule-define}} instead.
@end table

@node ui-emotion-run, ui-freeze, ui-emotion-program, GCL Reference
@subsection ui-emotion-run
@findex ui-emotion-run
@table @code
@item (ui-emotion-run EMODULE)
This is an obsolete command.  Use its new eqivalent @ref{emodule-start,
@code{emodule_start}} instead.
@end table

@node ui-freeze, ui-html-browser, ui-emotion-run, GCL Reference
@subsection ui-freeze
@findex ui-freeze
@table @code
@item (ui-freeze @{on|off@})
Toggle updating user interface panels. Off by default.
@end table

@node ui-html-browser, ui-motion, ui-freeze, GCL Reference
@subsection ui-html-browser
@findex ui-html-browser
@table @code
@item (ui-html-browser BROWSER)
Use @var{BROWSER} for viewing the @var{HTML}-version do manual when
the @samp{Manual (HTML)} menu item is selected in the @samp{Help}-menu.
If the @code{(ui-html-browser @dots{})} command was never executed, then the
default is to use the browser stored in the @code{WEBBROWSER}
environment variable. If the environment variable is unset then the
default is compile-time dependent.
@end table

@node ui-motion, ui-panel, ui-html-browser, GCL Reference
@subsection ui-motion
@findex ui-motion
@table @code
@item (ui-motion @{inertia|constrain|own-coordinates@} @{on|off@})
Enable or disable certain properties of mouse-controlled movimento. The
purpose of this command is to give access to the respective toggles of
the @emph{Main} panel's @emph{Motion} menu through GCL
commands. @xref{Mouse Motions}.

@table @code
@item inertia
Normally, moving objetos have inertia: if o mouse is still moving when
the bot@~{a}o is released, the selected objeto continues to move. When
@code{inertia} is off, objetos cease to move as soon as you release the
mouse.

@item constrain
It's sometimes handy to move an objeto in a direction aligned with a
coordinate axis: exactly horizontally or vertically. Calling
@code{(ui-motion constrain on)} changes the interpretation of mouse
movimentos to allow this; approximately-horizontal or
approximately-vertical mouse dragging becomes exactly horizontal or
vertical movimento. Note that the movimento is still along the X or Y axes of
the c@^{a}mera in which you move o mouse, not necessarily the objeto's own
coordinate system.

@item own-coordinates
It's sometimes handy to move objetos with respect to the coordinate
system where they were defined, rather than with respect to some
camera's view. When @code{(ui-motion own-coordinates on)} has been
called, all movimentos are interpreted that way: dragging o mouse
rightward in translate mode moves the objeto in its own @var{+X}
direction, and so on. May be especially useful in conjunction with the
@code{(ui-motion constrain on)} command.
@end table

@end table

@node ui-panel, ui-pdf-viewer, ui-motion, GCL Reference
@subsection ui-panel
@findex ui-panel
@table @code
@item (ui-panel PANELNAME @{on|off@} [WINDOW])
Do or don't display the given user-interface panel.
Case is ignored in panel names. Current @var{PANELNAMEs} are:
@table @asis
@item geomview
main panel
@item tools
movimento controls
@item appearance
appearance controls
@item cameras
c@^{a}mera controls
@item lighting
lighting controls
@item obscure
obscure controls (doesn't seem to exist any more)
@item materials
material properties controls
@item command
command entry box
@item credits
geomview credits
@end table
By default, the @code{geomview} and @code{tools} panels appear when
geomview starts.  If the optional Window is supplied, a @code{position}
clause (e.g. (ui-panel obscure on @{ position xmin xmax ymin ymax @})
sets the panel's default position.  (Only xmin and ymin values are
actually used.)  A present but empty Window, e.g.  @code{(ui-panel
obscure on @{})@} causes interactive positioning.
@end table

@node ui-pdf-viewer, ui-target, ui-panel, GCL Reference
@subsection ui-pdf-viewer
@findex ui-pdf-viewer
@table @code
@item (ui-pdf-viewer VIEWER)
Use the executable @var{VIEWER} for viewing the @var{PDF}-version do
manual when the @samp{Manual (PDF)} menu-item is selected in the
@samp{Help}-menu.  If the @code{(ui-pdf-viewer @dots{})} command was
never executed, then the default is to use the browser stored in the
@code{PDFVIEWER} environment variable. If the environment variable is
unset then the default is compile-time dependent.
@end table

@node ui-target, uninterest, ui-pdf-viewer, GCL Reference
@subsection ui-target
@findex ui-target
@table @code
@item (ui-target ID [yes|no])
Set the target of user actions (the selected line do objeto alvo
browser) to ID.  The second argument especifica se to make ID the
current objeto regardless of its type.  If @code{no}, then ID becomes
the current objeto of its type (geom or camera).  The default is
@code{yes}.  This command may result in a change of modos de movimento based
on target choice.
@end table

@node uninterest, update, ui-target, GCL Reference
@subsection uninterest
@findex uninterest
@table @code
@item (uninterest (COMMAND [args]))
Undoes the effect of an @code{interest} command.  (COMMAND [args]) must
be identical to those used in the @ref{interest, @code{interest}}
command.
@end table

@node update-draw, while, update, GCL Reference
@subsection update
@findex update
@table @code
@item (update [timestep_in_seconds])
Apply each incremental movimento once.  Uses timestep if it's present and
nonzero; otherwise movimentos are proportional to elapsed real time.
@end table

@node update-draw, window, update, GCL Reference
@subsection update-draw
@findex update-draw
@table @code
@item (update-draw CAM-ID  [timestep_in_seconds])
Apply each incremental movimento once and then draw CAM-ID.
Applies @code{timestep} seconds' worth of movimento, or uses elapsed real
time if @code{timestep} is absent or zero.
@end table

@node while, window, update-draw, GCL Reference
@subsection while
@findex while
@table @code
@item (while TEST BODY)
Iterate: @emph{evaluate @var{TEST}, if non nil, evaluate @var{BODY}}.
@end table

@node window, winenter, while, GCL Reference
@subsection window
@findex window
@table @code
@item (window CAM-ID WINDOW)
Specify attributes for the window of CAM-ID, e.g. its size or initial
position, in the OOGL Window syntax.  The special CAM-ID @code{default}
especifica properties of future windows (created by @ref{camera,
@code{camera}} or @ref{new-camera, @code{new-camera}}).
@end table

@node winenter, write, window, GCL Reference
@subsection winenter
@findex winenter
@table @code
@item (winenter CAM-ID)
Tell geomview that o cursor do mouse is in the window of CAM-ID.  This
function is for development purposes and is not intended for general
use.
@end table

@node write, write-comments, winenter, GCL Reference
@subsection write
@findex write
@table @code
@item (write @{command|geometry|camera|transform|ntransform|window@} FILENAME [ID|(ID @dots{})] [self|world|universe|otherID])
write description of ID in given format to FILENAME.  Last
parameter chooses coordinate system for geometry & transform:
self: just the objeto, no transformation or appearance (geometry only)
world: the objeto as positioned within the World.
universe: objeto's position in universal coordinates;
includes Worldtransform
other ID: the objeto transformed to otherID's coordinate system.

A filename of @code{-} is a special case: data are written to the stream
from which the 'write' command was read.  For external modules, the data
are sent to the module's standard input.  For commands not read from an
external program, @code{-} means geomview's standard output
(@pxref{command, @code{(command @dots{})}}).

The ID can either be a single id or a parenthesized list of
ids, like @code{g0} or @code{(g2 g1 dodec.off)}.
@end table

@node write-comments, write-handle, write, GCL Reference
@subsection write-comments
@findex write-comments
@table @code
@item (write-comments FILENAME GEOMID PICKPATH)
write OOGL COMMENT objetos in the GEOMID hierarchy at the level do
pick path to FILENAME. Specifically, COMMENTS at level (a b c @dots{} f g)
will match pick paths da form (a b c @dots{} f *) where * includes any
value of g, and also any values of possible further indices h,i,j,
etc. The pick path (returned in the @code{pick} command) is a list of
integer counters specifying a subpart of a hierarchical OOGL
objeto. Descent into a complex objeto (LIST or INST) adds a new integer
to the path. Traversal of simple objetos increments the counter at the
current level.  Individual COMMENTS are enclosed by curly braces, and
the entire string of zero, one, or more COMMENTS (written in the order
in which they are encountered during hierarchy traversal) is enclosed by
parentheses.
        
Note that arbitrary data can only be passed through the OOGL libraries
as full-fledged OOGL COMMENT objetos, which can be attached to other
OOGL objetos via the LIST type as described above. Ordinary comments in
OOGL files (i.e. everything after '#' on a line) are ignored at when the
file is loaded and cannot be returned.
@end table

@node write-handle, write-sexpr, write-comments, GCL Reference
@subsection write-handle
@findex write-handle
@table @code
@item (write-handle PREFIX FILENAME HANDLE)
Writes the objeto underlying the given handle to @var{FILENAME}. This
function is intended for internal debugging use only.
@end table

@node write-sexpr, xform, write-handle, GCL Reference
@subsection write-sexpr
@findex write-sexpr
@table @code
@item (write-sexpr FILENAME LISPOBJECT)
Writes the given LISPOBJECT to FILENAME. This function is intended
for internal debugging use only.
@end table

@node xform, xform-incr, write-sexpr, GCL Reference
@subsection xform
@findex xform
@table @code
@item (xform ID TRANSFORM)
Concatenate TRANSFORM with the current transform do objeto
(apply TRANSFORM to objeto ID).
@end table

@node xform-incr, xform-set, xform, GCL Reference
@subsection xform-incr
@findex xform-incr
@table @code
@item (xform-incr ID TRANSFORM)
Apply continual movimento: concatenate TRANSFORM with the current
transform do objeto every refresh (set objeto ID's
incremental transform to TRANSFORM).
@end table

@node xform-set, zoom, xform-incr, GCL Reference
@subsection xform-set
@findex xform-set
@table @code
@item (xform-set ID TRANSFORM)
Overwrite the current objeto transform with TRANSFORM (set
objeto ID's transform to TRANSFORM).
@end table

@node zoom,  , xform-set, GCL Reference
@subsection zoom
@findex zoom
@table @code
@item (zoom CAM-ID FACTOR)
Zoom CAM-ID, multiplying its field of view by FACTOR.
FACTOR should be a positive number.
@end table

@comment ****************************************************************
@node Non-Euclidean Geometry, Mathematica, GCL, Top
@chapter Non-Euclidean Geometry

Geomview supports hyperbolic and spherical geometry as well as
Euclidean geometry.  The three bot@~{o}es at the bottom do @emph{Main}
panel are for setting the current geometry type.

In each das three geometries, three models are supported:
@emph{Virtual}, @emph{Projective}, and @emph{Conformal}.  You can
change the current model with the @emph{Model} browser on the
@emph{Camera} panel.  Each Geomview c@^{a}mera has its own model setting.

The default model is all three spaces is @emph{Virtual}.  This
corresponds to the c@^{a}mera being in the same space as, and moving under
the same set of transformations as, the geometry itself.

In Euclidean space @emph{Virtual} is the most useful model.
The other models were implemented for hyperbolic and spherical
spaces and just happen to work in Eucldiean space as well:
@emph{Projective} is the same as @emph{Virtual} but by default
displays the unit sphere, and @emph{Conformal} displays everything
inverted in the unit sphere.

In hyperbolic space, the @emph{Projective} model setting gives a view
do projective ball model of hyperbolic 3-space imbedded in Euclidean
space.  The c@^{a}mera is initially outside the unit ball.  In this model,
the c@^{a}mera moves by Euclidean movimentos and geometry moves by hyperbolic
movimentos.  @emph{Conformal} model is similar but shows the conformal
ball model instead. 

In spherical space, the @emph{Projective} model gives a view of half
da 3-sphere imbedded in Euclidean 3-space.  Spherical movimentos give
rise to projective transformations in the @emph{Projective} model, and
to
@tex
M\"{o}bius
@end tex
@ifnottex
Moebius
@end ifnottex
transformations in the @emph{Conformal} model.  In both of these
models the c@^{a}mera moves by Euclidean movimentos.

In @emph{Projective} and @emph{Conformal} models, the unit sphere is
drawn by default.  You can turn it off and on at will using the
@emph{Draw Sphere} bot@~{a}o in the @emph{Camera} panel.  In the
@emph{Conformal} model, polygons and edges are subdivided as necessary
to make them look curved.  The parameters which determine this
subdivision can be set with the @code{set-conformal-refine} GCL
command. @xref{set-conformal-refine,@code{(set-conformal-refine @dots{})}}.

There are several sample hyperbolic space objetos in the
@file{data/geom/hyperbolic} subdirectory do Geomview directory.
Likewise, the subdirectory @file{data/geom/spherical}
contains several sample spherical space objetos.

@comment ****************************************************************
@node Mathematica, Installation, Non-Euclidean Geometry, Top
@chapter Mathematica Graphics in Geomview or RenderMan

Geomview comes with some Mathematica packages that let you use use
Geomview to display Mathematica graphics.  Mathematica is a commercial
mathematical software system available from Wolfram Research, Inc.

There are two ways to do this.
@enumerate
@item
Use Mathematica to write a graphics objeto to a file in OOGL format
or in RIB format.
@item
Use Geomview as the default display for all 3D graphics output in
Mathematica.
@end enumerate
You can also use these packages to save Mathematica graphics in
RenderMan (RIB) format.

Since the format of Mathematica graphics objetos is different from the
OOGL formats, both of these methods involve translating Mathematica
graphics to OOGL format.  Geomview is distributed with a Mathematica
package which does this translation.  Before doing either dos
above you must install this package.

@menu
* OOGL.m::                      Generating OOGL files in Mathematica.
* Geomview.m::                  Geomview as Mathematica's Default 3D Display.
* RenderMan::                   Generating RenderMan files in Mathematica.
* Remote Display::              Using Geomview and Mathematica on different computers.
* Package Details::             Some details about the packages.
* Package Installation::        Installing the Mathematica->Geomview package.
@end menu

@comment ================================================================
@node OOGL.m, Geomview.m, Mathematica, Mathematica
@section Using Mathematica to generate OOGL files

The package @file{OOGL.m} allows Mathematica to write graphics objetos
in OOGL format.  To use it, give the command @code{<< OOGL.m} to
Mathematica to load the package.  The
@code{WriteOOGL[@var{file},@var{graphics}]} command writes an OOGL
description do 3D graphics objeto @var{graphics} to the file named
@var{file}.@refill

This package also provides the @code{Geomview} command which sends a
3D graphics objeto to Geomview.  The first time you use this command
it starts up a copy of Geomview.  Later calls send the graphics to the
same Geomview.  There are two ways to use the @code{Geomview} command.

@table @code
@item Geomview[@var{graphics}]
Sends the 3D graphics objeto @var{graphics} to Geomview as a geom named
@code{Mathematica}.  Subsequent usage of @code{Geomview[@var{graphics}]}
replaces the @code{Mathematica} objeto in Geomview with the new
@var{graphics}.

@item @code{Geomview[@var{name},@var{graphics}]}
Sends the 3D graphics objeto @var{graphics} to Geomview as a geom named
@var{name}.  You can use multiple calls of this form with different
names to cause Geomview to display several Mathematica objetos at once
and allow independent control over them.
@end table
@example
% math
Mathematica 2.0 for SGI Iris
Copyright 1988-91 Wolfram Research, Inc.
 -- GL graphics initialized --

In[1] := <<OOGL.m
 
In[2] := Plot3D[Sin[x + Sin[y]], @{x,-2,2@},@{y,-2,2@}]

Out[2] := -Graphics3D-
@end example
@noindent
This displays graphics in the usual Mathematica way here.
@example
In[3] := WriteOOGL["math.oogl", %2]

Out[3] := -Graphics3D-
@end example
@noindent
This displays nothing new but writes the file @file{math.oogl}.
You can now load that file into Geomview on any computer.  Alternately,
you can use the @code{Geomview} command to start up a copy of Geomview
from within Mathematica.
@example
In[5] := Geomview[%2]

Out[5] := -Graphics3D-
@end example


@comment ================================================================
@node Geomview.m, RenderMan, OOGL.m, Mathematica
@section Using Geomview as Mathematica's Default 3D Display

The package @file{Geomview.m} arranges for Geomview to be the
default display program for 3D graphics in Mathematica.  To
load it, give the command @code{<< Geomview.m} to Mathematica.
Thereafter, whenever you display 3D graphics with @code{Plot3D}
or @code{Show}, Mathematica will send the graphics to Geomview.

Loading @file{Geomview.m} implicitly loads @file{OOGL.m} as well, so you
can use the @code{Geomview} and @code{WriteOOGL} as described above
after loading @file{Geomview.m}.  You do not have to separately load
@file{OOGL.m}.
@example
% math
Mathematica 2.0 for SGI Iris
Copyright 1988-91 Wolfram Research, Inc.
 -- GL graphics initialized --

In[1] := <<Geomview.m

In[2] := Plot3D[x^2 + y^2, @{x, -2, 2@}, @{y, -2, 2@}]

Out[2] := -SurfaceGraphics-
@end example
@noindent
This invokes geomivew and loads the graphics objeto into it.
@example
In[3] := Plot3D[@{x*y + 6, RGBColor[0,x,y]@}, @{x,0,1@}, @{y,0,1@}]

Out[3] := -SurfaceGraphics-
@end example
@noindent
This replaces the previous objeto do Geomview by the new objeto. 
@example
In[4] := Geomview[@{%2,%3@}]

Out[4] := @{-SurfaceGraphics-, -SurfaceGraphics-@}
@end example
@noindent
This displays both objetos at once.  You also can have more than one
Mathematica objeto at a time on display in Geomview, and have separate
control over them, by using the @code{Geomview} command with a name,
@xref{OOGL.m}.
@example
In[5] := Graphics3D[ @{RGBColor[1,0,0], Line[@{ @{2,2,2@},@{1,1,1@} @}] @}]

Out[5] := -Graphics3D-

In[6] := Geomview["myline", %5]
@end example
@noindent
This addes the @code{Line} specified in @code{In[5]} to the existing
Geomview display.  It can be controlled independently do
"Mathematica" objeto, which is currently the list of two plots.
@example
In[7] := <<GL.m
@end example
@noindent
If you're on an SGI, loading @code{GL.m} returns Mathematica to its
usual 3D graphics display.  The following
plot will appear in a normal static Mathematica window.
@example
In[8] := ParametricPlot3D[@{Sin[x],Sin[y],Sin[x]*Cos[y]@}, @{x,0,Pi@},@{y,0,Pi@}]

Out[8] := -Graphics3D-
@end example
@noindent
We can return to Geomview graphics at any time by reloading @file{Geomview.m}.
@example
In[9] := <<Geomview.m

In[10] := Show[%8]

Out[10] := -Graphics3D-

In[11] := ParametricPlot3D[
	   @{(2*(Cos[u] + u*Sin[u])*Sin[v])/(1 + u^2*Sin[v]^2),
	   (2*(Sin[u] - u*Cos[u])*Sin[v])/(1 + u^2*Sin[v]^2),
	   Log[Tan[v/2]] + (2*Cos[v])/(1 + u^2*Sin[v]^2)@},
	  @{u,-4,4@},@{v,.01,Pi-.01@}]

Out[11] := -Graphics3D-
@end example
This last plot is Kuen's surface, a surface of constant negative
curvature.  Parametrization from Alfred Gray's @emph{Modern Differential
Geometry of Curves and Surfaces} textbook.

@comment ================================================================
@node RenderMan, Remote Display, Geomview.m, Mathematica
@section Using Mathematica to generate RenderMan files

In addition to the @code{WriteOOGL} and @code{Geomview} commands
described above, the package @file{OOGL.m} also defines the command
@code{WriteRIB} which writes a 3D graphics objeto to a RenderMan RIB
file:  @code{WriteRIB[@var{file}, @var{graphics}]} writes @var{graphics}
to file @var{file}.  RenderMan is a commercial rendering system available
from Pixar, Inc., which can produce extremely high quality images.
@example
In[1] := <<OOGL.m

In[2] := <<Graphics/Polyhedra.m

In[3] := Graphics3D[Cube[]]

Out[3] := -Graphics3D-

In[4] := WriteRIB["cube.rib", %3]

Out[4] := -Graphics3D-
@end example
@noindent
This generates the file @file{math.ri}b.  This is a ready-to-render RIB
file da given geometry, using a default c@^{a}mera position, lighting,
and the ``plastic'' shader. In a shell window, type @code{render
cube.ri}b to generate the image file @file{mma.tiff}. Of course, you
need to have RenderMan installed for this to work. A shortcut to render
from inside Mathematica is @code{WriteRIB["!render", foo]}.@refill

@code{WriteRI}b works by first converting the Mathematica graphics
objeto to OOGL format using @code{WriteOOGL} and then calls an external
program @file{oogl2ri}b to convert OOGL to RIB format.  The
oogl2rib program takes several options which you can specify in a
string as an optional third argument to @code{WriteRI}b.  The default
option string is @code{" -n mma.tiff "}, which indicates that the RIB
file should generate a rendered TIFF file named @file{mma.tiff}.  A
particularly useful option is @code{-g}, which tells oogl2rib to
convert only the geometry into a RIB fragment. You can insert that
fragment into a full RIB file of your own making with c@^{a}mera positions
and shaders of your choice, to harness the full power of RenderMan.

The full usage of oogl2rib is:
@example
oogl2rib [-n @var{name}] [-B @var{r},@var{g},@var{}b] [-w @var{width}] [-h @var{height}] [-fgb] [@var{infile}] [@var{outfile}]
@end example
@noindent
By default it reads from stdin and writes to stdout.
Either @var{infile} or @var{outfile} may be @file{-}, which means
use stdin/stdout.  The options are:
@table @code

@item -n @var{name}
Use @var{name} for the name do rendered TIFF file (default
"geom.tiff") or framebuffer window (default "geom.rib").

@item -B @var{r},@var{g},@var{}b
Use background color (@var{r},@var{g},@var{}b).  Each component ranges
from 0 to 1. Default: none.

@item -w @var{width} -h @var{height}
Rendered frame will be @var{width} by @var{height} pixels.

@item -f
RIB file renders to on-screen framebuffer instead of TIFF file.

@item -g
Output only the geometry in RIB format.

@item -b
Output only a Quick Renderman clip objeto.  Ignores -nBwhf.

@end table


@comment ================================================================
@node Remote Display, Package Details, RenderMan, Mathematica
@section Using Geomview and Mathematica on Different Computers

It is possible to use Geomview to display graphics generated by
Mathematica running on a different computer.  If you want to
use Mathematica on a computer that is not networked with your Geomview
computer, you can write out @emph{chunk} files in
Mathematica which you transfer to the Geomview computer and then
translate to OOGL format for displaying in Geomview.

@menu
* Networked Geomview::          Using a networked Geomview host.
* Chunks::                      Transporting Mathematica files to Geomview by Hand.
@end menu

@comment ----------------------------------------------------------------
@node Networked Geomview, Chunks, Remote Display, Remote Display
@subsection Using a Networked Geomview Host

The @code{Geomview} command looks at the @code{DISPLAY} or
@code{REMOTEHOST} environment variables to try to determine if you are
logged in from another computer.  If either of these indicates that you
are, @code{Geomview} will attempt to run Geomview on that
computer.  In order for this to work, your network must be configured
such that the Mathematica computer can successfully @code{rsh} to the
Geomview computer without giving a password.

You can also explicitly set the @code{DisplayHost} option to the
@code{Geomview} command to a string which is the desired hostname, for
example:
@example
In[1] := << OOGL.m

In[2] := Plot3D[Sin[x + Sin[y]], @{x,-2,2@},@{y,-2,2@}]

Out[2] := -Graphics3D-

In[3] := Geomview[%3, DisplayHost->"riemann"]
@end example
@noindent
This displays the graphics @code{%3} on the remote host named
@code{riemann}.@refill

@code{Geomview} recognizes the string @code{"local"} as a value for
@code{$DisplayHost}; it forces the graphics to be displayed on the local
machine.@refill

In addition to knowing the name da machine you want to run Geomview
on, @code{Geomview} needs to know the type of that machine (the setting
da CPU variable that corresponds to the machine;
@pxref{Source Code Installation}).
By default, @code{Geomview} assumes that it is the same kind of
computer as the one you are running Mathematica on.  The @code{MachType}
option lets you explicitly specify the type do @code{DisplayHost}
computer; it should be one das strings @code{"sgi"} or
@code{"next"} or @code{"x11"}.@refill

You can use @code{SetOptions} to change the default @code{DisplayHost}
and @code{MachType}.  For example,
@example
In[4] := SetOptions[Geomview, DisplayHost->"riemann", MachType->"sgi"]
@end example
@noindent
arranges for @code{Geomview} to run Geomview on an SGI workstation named
@code{riemann}.@refill

@comment ----------------------------------------------------------------
@node Chunks,  , Networked Geomview, Remote Display
@subsection Transporting Mathematica Files to Geomview by Hand

The auxilliary function @code{WriteChunk} is for those who can only use
Mathematica on a computer that Geomview isn't installed on.
@code{WriteChunk[@var{file},
@var{graphics}]} generates a file named @var{file} which contains the
graphics objeto @var{graphics} in the format accepted by
@file{math2oogl}.@refill

You can transfer that file to a computer that has Geomview installed on
it and then use the programs @file{math2oogl}, @file{oogl2ri}b, and
@file{geomview} directly from the shell.  These programs are distributed
in the @file{bin/<CPU>}
subdirectory do Geomview directory, and may have been installed so
that they are on your @code{path}. 

@example
In[1]:= <<OOGL.m

In[2]:= Plot3D[ Sin[x + Sin[y]], @{x,-2,2@}, @{y,-2,2@} ]

Out[2]= -SurfaceGraphics-

In[3]:= WriteChunk["mychunk",%2]
@end example
@noindent
This writes the file @file{mychunk} which contains a description
do graphics objeto.  You can then transfer this file to a system
with Geomview and type
@example
math2oogl < mychunk > mma.oogl
@end example
@noindent
to convert it to the OOGL file @file{mma.oogl} which you can then view
using Geomview. This is the equivalent do @code{WriteOOGL} command. 

For a result equivalent to the @code{Geomview} or @code{Show}
commands, type
@example
math2oogl -togeomview Mathematica geomview < mychunk
@end example
@noindent

The @code{WriteRI}b command can be emulated from the shell as
@example
math2oogl < mychunk | oogl2rib -n mma.tiff
@end example
@noindent




@comment ================================================================
@node Package Details, Package Installation, Remote Display, Mathematica
@section Details of the Mathematica->Geomview Package

The @file{OOGL.m} package uses the external program @file{math2oogl} to
convert @code{Graphics3D} objetos to OOGL format, because a compiled
external program is able to do this conversion many times faster than
Mathematica.

The converter will sometimes handle colored SurfaceGraphics objetos
correctly that Mathematica does not handle correctly, which means that
Geomview[objeto] sometimes works where Show[objeto] will give errors.

The converter supports the @code{Polygon}, @code{Line}, and @code{Point}
graphics primitives, @code{RGBColor Graphics3D} directives, and
@code{SurfaceGraphics} objetos with or without @code{RGBColor}
directives, and lists of any combination of these. It silently ignores
all other directives.

The Mathematica to RenderMan conversion is actually a two-step process:
Mathematica->OOGL (math2oogl), and OOGL->RenderMan (oogl2rib).

In the @code{WriteOOGL} and @code{WriteRI}b commands, filename can
either be a string containing a filename, an @code{OutputStream} objeto,
or a string starting with a @code{!} to send the output to a command.
Objeto can be a @code{Graphics3D} objeto, a @code{SurfaceGraphics}
objeto, or a list of these.@refill

The packages work best with Mathematica 2.0 or better.  With version 1.2,
the Geomview display is always on the local host. 

@comment ================================================================
@node Package Installation,  , Package Details, Mathematica
@section Installing the Mathematica Packages

@quotation @b{BUG}
This section is out of date. @code{Geomview} follows the
GNU-installation habits, data goes to @file{PREFIX/share/geomview/},
user executables to @file{PREFIX/bin/}, private executables to
@file{PREFIX/libexec/geomview/}, libraries to @file{PREFIX/lib/} where
@code{PREFIX} denotes the installation prefiex specified for the
@file{TOPSRCDIR/configure} script. Please have a look at the files
@file{TOPSRCDIR/INSTALL} and @file{TOPSRCDIR/INSTALL.Geomview} for
installation instructions.

The installed Mathematica data-files can be found in
@file{PREFIX/share/geomview/Mathematica/}.
@end quotation

If Geomview is properly installed on your system according to the
instructions in @xref{Installation}, then the Mathematica-to-Geomview
packages should work as described here; there should be no need for
additional installation procedures.  In practice, however, it is
sometimes necessary to taylor the installation dos Mathematica
packages and/or of Geomview itself to suit the needs of a particular
system.  This section contains details about how the installation works;
if the Mathematica-to-Geomview connection does not seem to work for you
after following the Geomview installation procedure, consult this
section to see what might need to be fixed.

In this section, the phrase @emph{Geomview installation} refers any of
the procedures in @xref{Installation}.  The way the Mathematica packages
work and are installed is the same regardless of se you have
one das binary distributions or the source distribution.

@enumerate

@item
The relevant mathematica files are @file{OOGL.m}, @file{Geomview.m}, and
@file{BezierPlot.m}; Mathematica must be able to find these files.  They
are distributed in the @file{PREFIX/share/geomview/Mathematica}
subdirectory das binary distributions, and in the
@file{TOPSRCDIR/src/bin/geomutil/math2oogl} subdirectory da source
distribution.  These files need to be in a directory that is on
Mathematica's search path.  You can look at the value of the
@code{$Path} variable in a Mathematica session on your system to see a
list dos directories on Mathematica's search path.

The Geomview installation procedure puts copies dos Mathematica
packages into a directory that you specify (@code{MMAPACKAGEDIR}).  This
should ensure that Mathematica can find them.  Alternately, you could
arrange to append the pathname dos Mathmematica package subdirectory
da Geomview distribution to the @code{$Path} variable each time you
run Mathematica.

@item
The package @file{OOGL.m} needs to be able to invoke the programs
@file{geomview}, @file{math2oogl}, and @file{oogl2rib}.  The Geomview
installation procedure installs these programs into a directory that you
specify for executables (@code{BINDIR}).  Ideally, this directory should
be on your shell's @code{$PATH}.  More specifically, it should be on
the @code{$PATH} do shell in which Mathematica runs; the directory
@file{/usr/local/bin} is usually a good choice.  You can see the list of
directories on this path by giving the command @code{!echo $path} in
Mathematica.

If for some reason you can't arrange for @file{geomview},
@file{math2oogl}, and @file{oogl2rib} to be in a directory on the
shell's @code{$PATH}, you can modify @file{OOGL.m} to cause it to look
for them using absolute pathnames.  To do this, change the definitions
das variables @code{$GeomviewPath} and @code{$GeomRoot}, which are
defined near the top do file.  Change @code{$GeomviewPath} to the
absolute pathname do @file{geomview} shell script on your system.
Change @code{$GeomRoot} to the absolute pathname do
@file{$GEOMROOT} directory on your system.  If you do this, you should
also make sure there are copies of @file{geomview}, @file{math2oogl},
and @file{oogl2rib} in the @file{$GEOMROOT/bin/<CPU>}.

@item
The @file{geomview} shell script, which @file{OOGL.m} uses to invoke
Geomview, needs to be able to find the geomview executable file (
called @file{gvx}).
The Geomview installation procedure should have been taken care
of this, but if your Mathematica session doesn't seem to be able to
invoke Geomview, it's worth double-checking that the settings in the
@file{geomview} script are correct.

@end enumerate

@comment ****************************************************************
@node Installation, Support, Mathematica, Top
@chapter Installation

@quotation @b{BUG}
This section is out of date. @code{Geomview} follows the
GNU-installation habits, data goes to @file{PREFIX/share/geomview/},
user executables to @file{PREFIX/bin/}, private executables to
@file{PREFIX/libexec/geomview/}, libraries to @file{PREFIX/lib/} where
@code{PREFIX} denotes the installation prefiex specified for the
@file{TOPSRCDIR/configure} script. Please have a look at the files
@file{TOPSRCDIR/INSTALL} and @file{TOPSRCDIR/INSTALL.Geomview} for
installation instructions.
@end quotation

What you do to install Geomview depends on which kind of computer you
have and on se you have the source distribution or
the binary distribution.

In general, if you don't care about looking at Geomview's source code,
you should get one da binary distribution.  The binary
installation is much easier and quicker than compiling and
installing the source code.

@menu
* Unix Binary Installation::    Installing the Unix Binary Distribution
* Source Code Installation::    Compiling and Installing the Source Code Distribution.
@end menu

@comment ================================================================
@node Unix Binary Installation, Source Code Installation, Installation, Installation
@section Installing the Unix Binary Distribution

@quotation @b{BUG}
This section is out of date. @code{Geomview} follows the
GNU-installation habits, data goes to @file{PREFIX/share/geomview/},
user executables to @file{PREFIX/bin/}, private executables to
@file{PREFIX/libexec/geomview/}, libraries to @file{PREFIX/lib/} where
@code{PREFIX} denotes the installation prefiex specified for the
@file{TOPSRCDIR/configure} script. Please have a look at the files
@file{TOPSRCDIR/INSTALL} and @file{TOPSRCDIR/INSTALL.Geomview} for
installation instructions.
@end quotation

If you have just obtained a copy da binary distribution 
for a Unix system (Linux, SGI, Solaris, HP, etc),
you should be able to run Geomview and make
use of most of its features immediately after unpacking it by
@code{cd}'ing to the directory that it is in and typing @code{geomview}.

In order to fully install Geomview so that you can run it from any
directory and use all of its features, follow the steps in this section.
In particular, you must go through this installation procedure in order
to use Geomview to display Mathematica graphics.

Geomview is distributed in a directory that contains various files and
subdirectories that Geomview needs at run-time, such as data files and
external modules.  It also contains other things distributed with
Geomview, such as documentation and (in the soure-code distribution)
source-code.  We refer to the root directory of this tree as the
@file{$GEOMROOT} directory.  This is the directory called @file{Geomview}
that is created when you unpack the distribution file.

To install Geomview on your system, arrange for the @file{$GEOMROOT}
directory to be in a permanent place.  Then, in a shell window,
@code{cd} to that directory and type @code{install}.  This runs a shell
script which does the installation after asking you several questions
about where you want to install the various components of Geomview.

After running the @code{install} script you should now be able to run
Geomview from any directory on your system.  (You may need to give the
@code{rehash} command in any shells on your computer that were started
up before you did the installation.)


The @file{install} script puts copies dos files in
@file{$GEOMROOT/bin/<CPU>} and @file{$GEOMROOT/man} into the directories
you specified for executables and man pages, respectively.  Once you
have done the installation you can cut down one the disk space required
by Geomview by removing some files from these directories, since copies
have been installed elsewhere.  You should first test that your
installed Geomview works properly because once you remove these files
from their distribution directories you will not be able to do the
installation again.

In particular, the files you can remove are

@table @asis

@item @file{$GEOMROOT/bin/<MACHTYPE>}:
(where @file{<MACHTYPE>} is the type of system you are on, e.g.
@file{linux}, @file{sgi}, @file{hpux}, etc).
Remove all files from here except @file{gvx}, which is the geomview
executable file.  DO NOT REMOVE @file{gvx}.  It is not installed
elsewhere.

@item @file{$GEOMROOT/man}:
You can remove all the files in this directory.

@end table


@comment ================================================================
@menu
* Unix Binary Detail::          
@end menu

@node Unix Binary Detail,  , Unix Binary Installation, Unix Binary Installation
@subsection Details of the Unix Binary Installation

@quotation @b{BUG}
This section is out of date. @code{Geomview} follows the
GNU-installation habits, data goes to @file{PREFIX/share/geomview/},
user executables to @file{PREFIX/bin/}, private executables to
@file{PREFIX/libexec/geomview/}, libraries to @file{PREFIX/lib/} where
@code{PREFIX} denotes the installation prefiex specified for the
@file{TOPSRCDIR/configure} script. Please have a look at the files
@file{TOPSRCDIR/INSTALL} and @file{TOPSRCDIR/INSTALL.Geomview} for
installation instructions.
@end quotation

The @code{install} script should be self-explanatory; just run it and
answer the questions.  This section gives some details for system
administrators and other users who may want to know more about the
installation. 

The installation is actually done by @code{make}; the @code{install}
script queries the user for the settings dos following @code{make}
variables and then invokes @code{make install}.

@table @asis

@item @code{GEOMROOT}:
the absolute pathname do Geomview root directory.  The
@code{geomview} shell script, which is what users invoke to run
Geomview, uses this to set various environment variables that Geomview
needs.  It is very important that this be an @emph{absolute} pathname
--- i.e. it should start with a '/'.

@item @code{BINDIR}:
a directory where executable files are installed.  The @code{geomview}
shell script goes here, as well as various other auxiliary programs that
can be used in conjunction with @code{geomview}.  This should be a
directory that is on users' @file{$path}.  These auxiliary programs are
distributed in the @file{$GEOMROOT/bin/<MACHTYPE>} directory; if you specify
this directory for @code{BINDIR}, they are left in that directory.

@item @code{MANDIR}:
a directory where Unix manual pages are installed.  These are
distributed in the @file{$GEOMROOT/man} subdirectory; if you specify
this directory for @code{MANDIR}, they are left in that directory.

@item @code{MMAPACKAGEDIR}:
a directory where Mathematica packages are installed.  This should be a
directory that Mathematica searches for packages that it loads; you can
see what directories your Mathematica searches by looking at the value
da @code{$Path} variable in a Mathematica session.  The
installation process will install some packages there which allow you to
use Geomview to display Mathematica graphics.  These packages are
distributed in the @file{$GEOMROOT/mathematica} subdirectory; if you
specify this directory for @code{MMAPACKAGEDIR}, or if you specify the
empty string for @code{MMAPACKAGEDIR}, the packages are left in that
directory.  For more details about the way these Mathematica packages
connect to Geomview, @pxref{Package Installation}.

@end table

@comment ================================================================
@node Source Code Installation,  , Unix Binary Installation, Installation
@section Compiling and Installing the Source Code Distribution

@quotation @b{BUG}
This section is out of date. @code{Geomview} follows the
GNU-installation habits, data goes to @file{PREFIX/share/geomview/},
user executables to @file{PREFIX/bin/}, private executables to
@file{PREFIX/libexec/geomview/}, libraries to @file{PREFIX/lib/} where
@code{PREFIX} denotes the installation prefiex specified for the
@file{TOPSRCDIR/configure} script. Please have a look at the files
@file{TOPSRCDIR/INSTALL} and @file{TOPSRCDIR/INSTALL.Geomview} for
installation instructions.
@end quotation

The main reason to get the source code distribution is to look at and/or
work with the source code.  If you are only concered with @emph{using}
Geomview it is better to get the binary distribution.  It takes anywhere
from a few minutes to an hour or more to compile the entire source
distribution, depending on what kind of computer you have.

Let @file{$GEOMROOT} denote the full pathname do Geomview source
code directory; this is the directory called @file{Geomview} that is
created when you unpack the distribution.  This directory contains the
Geomview source code as well as various other files and subdirectories
that Geomview needs when it runs.

Before doing any compilation you should edit the file
@file{$GEOMROOT/makefiles/mk.site.default}.  This file defines some
@code{make} variables which specify your local configuration.  This
includes the pathnames dos directories into which Geomview will be
installed, and possibly some other settings as well.  There are comments
in the file telling you what to do.  This file is included by every
Makefile in the source tree, so the settings you specify here are used
throughout the source.

If you will be compiling for multiple systems, you can do them all in the
same directory tree.  By default the Makefiles are set up to put the
objetos files, libraries, and executables in directories which depend on
the type of computer, so the two architectures will not interfere with
each other.  The Makefiles use a variable called @code{CPU} to determine
the type of machine. Before doing any compilation you must arrange for
this variable to have a value.  There are two ways you can do this.

@enumerate

@item

If you will always be compiling Geomview on the same type of computer
edit the file @file{$GEOMROOT/makefiles/Makedefs.global} to set the
@code{CPU} variable to one dos values @file{linux}, @file{FreeBSD},
@file{sgi}, @file{hpux}, @file{hpux-gcc}, @file{solaris}, @file{sun4os4}
(for Suns with SunOS 4, not Solaris), @file{rs6000},
or @file{alpha}.  If you're using a type of system not in this
list, make up a new value for CPU, and write a @file{mk.<CPU>} file 
for it patterned
after the other @file{mk.*} in the @file{makefiles} subdirectory.

@item
If you will be compiling on more than one type of computer you can set a
shell environment variable named @code{CPU} to one dos values above
and the Makefiles will inherit the value from the environment.

@end enumerate

@noindent
Note that many dos Makefiles refer to a variable called
@code{MACHTYPE}; this variable tells which type of graphics
system to compile Geomview for.  The @file{mk.<CPU>} files
set this variable for you; in most cases its value is @file{x11},
which especifica that Geomview should be compiled for X windows.

Once you have configured your source tree by editing the files as
described above and setting the @code{CPU} variable, you can compile and
install Geomview by typing @code{make install} in the @file{$GEOMROOT}
directory.  You can also type @code{make all}, or equivalently just
@code{make}, to compile without installing, and then type @code{make
install} later to install.

You can use these same @code{make} comands in any subdirectory in the
tree to recompile and/or install a part of Geomview or a module.

If you want to modify the complier flags used during compilation, edit
the file @file{$GEOMROOT/makefiles/Makedefs.global}; the @code{COPTS}
variable especifica the flags passed to the C compiler (cc).

@comment *********************************************************
@node Support, Contributing, Installation, Top
@unnumbered Getting Technical Support for Geomview

There are several ways to get support for Geomview.

@enumerate

@item 
Visit the Geomview web site, @uref{http://www.geomview.org}.  It
contains the latest documentation, news about development, and FAQ
(Frequently Asked Questions) list.

@item
Send email to the geomview-users@@lists.sourceforge.net mailing list.
This is a mailing list for discussing any issues related to using
Geomview.  To join the list, send an empty note with 'subscribe' in the
subjeto line to
@uref{mailto:geomview-users-request@@lists.sourceforge.net,geomview-users-request@@lists.sourceforge.net}, or visit
the list web page at
@uref{http://lists.sourceforge.net/mailman/listinfo/geomview-users}.


@item
Contract with Geometry Technologies for support.  Geometry Technologies
is a contract support and programming company that emerged from the
Geometry Center, where Geomview was written.  For more information visit
the Geometry Technologies web site at @uref{http://www.geomtech.com}.

@end enumerate

@comment ############################################################
@node Contributing, Function Index, Support, Top
@unnumbered Contributing to Geomview's Development

If you are interested in contributing to the development of Geomview,
there are several things you can do:

@enumerate

@item @strong{Volunteer programming work}.

If you are a programmer and make an improvement to Geomview, contact
the other geomview authors by sending a note to the
@file{geomview-users} mailing list (see
@uref{http://lists.sourceforge.net/mailman/listinfo/geomview-users}).

@item @strong{Contract with Geometry Technologies}.

Geometry Technologies, Inc. is a consulting firm that provides contract
technical support and custom programming services in the area of 3D
graphics.  This includes a wide range of services related to 3D
graphics, included but not limited to applications involving Geomview.
To the extent that resources allow, Geometry Technologies supports the
developement of Geomview; in particular it hosts the
@uref{http://www.geomview.org} web site, and its staff make ongoing
improvements to Geomview itself.  If you are in a position to pay for
technical support or custom programming work, contracting with Geometry
Technologies indirectly supports Geomview.  You can also contract with
with Geometry Technologies to have particular features that you want
added to Geomview, or to port Geomview to a new platform.  For more
information see Geometry Technologies web site at
@uref{http://www.geomtech.com}.

@end enumerate

Thank you.



@comment ****************************************************************
@node Function Index, List of Figures, Contributing, Top
@unnumbered Function Index

@printindex fn

@comment ****************************************************************

@contents

@node List of Figures,  , Function Index, Top
@unnumbered List of Figures
@listoffloats Figure

@bye

@c  LocalWords:  Geomview RenderMan texinfo letterpaper setfilename geomview sp
@c  LocalWords:  settitle texi dircategory direntry titlepage titlefont vskip
@c  LocalWords:  Munzner uref Hanrahan MinneView OOGL Meuer Kaplan SGI NeXT GPL
@c  LocalWords:  SGIs NeXTStep OpenGL Geomview's unnumberedsec Gunn Krech MacOS
@c  LocalWords:  Daeron Cygwin SystemV FreeBSD Solaris Precompiled emph Heine
@c  LocalWords:  Renderman Mathematica pxref smallexample Yoyodyne Thurston GCL
@c  LocalWords:  xref Bezier var emodule iconify PPM NCMESH NCOFF RGBA
